// Fake - just to not interpret next documentation section as file documentation :(.
export {}
/**
 * EntityPath defines ownership between symbols (separated by a dot) and referenced from the actual owning module.
 *
 * *E.g*, for a particular module the attribute `foo` of class `Bar` is `Foo.bar`.
 */
export type EntityPath = string

/**
 * Documentation section.
 */
export interface DocumentationSection {
    /**
     * Section's title.
     */
    title?: string
    /**
     * Associated semantic.
     */
    semantic: Semantic
    /**
     * Section's content.
     */
    content: string
    /**
     * Content's type.
     */
    contentType: string
}

/**
 * An entity documentation.
 */
export interface Documentation {
    /**
     * List of the sections.
     */
    sections: DocumentationSection[]
}

/**
 * Entity code's description.
 */
export interface Code {
    /**
     * Entity's declaration.
     */
    declaration: string
    /**
     * Optional associated implementation.
     */
    implementation?: string
    /**
     * File path in which the declaration is included.
     */
    filePath: string
    /**
     * Starting line of the declaration.
     */
    startLine: number
    /**
     * Ending line of the declaration.
     */
    endLine: number

    /**
     * References to other entities in the declaration.
     */
    references: Record<string, EntityPath>
}

/**
 * Semantic representation.
 *
 * They represent metadata transmitted to the frontend renderer to display appropriately the elements.
 */
export interface Semantic {
    /**
     * Role, a unique meaning (*e.g.* `Class`, `Interface`, `TypeAlias`, *etc.*).
     */
    role: string
    /**
     * Some labels.
     */
    labels: string[]
    /**
     * Some attributes.
     */
    attributes: Record<string, string>
    /**
     * Some relation with other entities (grouped by a category keyword, *e.g.* `InheritedBy`).
     */
    relations: Record<string, EntityPath[]>
}
/**
 * Base structure to represent an entity within the code, e.g. class, structure, function, variable,
 * *etc.*.
 */
export interface Entity {
    /**
     * Name.
     */
    name: string
    /**
     * Documentation.
     */
    documentation: Documentation
    /**
     * Code information.
     */
    code: Code
    /**
     * Semantic associated.
     */
    semantic: Semantic
    /**
     * The path (e.g. `ModuleFoo.TypeBar.attrBaz`).
     *
     * It starts with the library name, each segment separated by `.`.
     */
    path: EntityPath
    /**
     * The navigation path, *e.g.* `@nav/api/submoduleA/Foo.bar`.
     */
    navPath: string
}
/**
 * Callable representation.
 */
export type Callable = Entity

/**
 * Attribute representation.
 */
export type Attribute = Entity

/**
 * Type representation.
 */
export interface Type extends Entity {
    /**
     * List of owned callable.
     */
    callables: Callable[]
    /**
     * List of owned attributes.
     */
    attributes: Attribute[]
}

/**
 * File representation.
 */
export interface File {
    /**
     * Name.
     */
    name: string
    /**
     * Path.
     */
    path: string
    /**
     * Documentation.
     */
    documentation: Documentation
}

/**
 * Child module representation.
 */
export type ChildModule = Omit<Entity, 'code' | 'documentation'> & {
    /**
     * Whether it includes children modules.
     */
    isLeaf: boolean
}

/**
 * Module representation.
 */
export type Module = Omit<Entity, 'code'> & {
    /**
     * Children modules.
     */
    children: ChildModule[]
    /**
     * Callable components.
     */
    callables: Callable[]
    /**
     * Types components.
     */
    types: Type[]
    /**
     * Attributes components.
     */
    attributes: Attribute[]
    /**
     * Files components.
     */
    files: File[]
}

/**
 * Represents the specification for a project documented using `@mkdocs-ts/code-api`.
 */
export interface Project {
    /**
     * Name of the root module being documented.
     * Its associated json data should be located at `${dataFolder}/${entryModule}.json`.
     */
    entryModule: string
    /**
     * The URL (relative or absolute) of the root folder containing the generated JSON models
     * for the API documentation.
     */
    dataFolder: string
    /**
     * Defines the navigation paths for the root of the multiple modules involved in the API documentation
     * for which documentation has been generated by the plugin.
     *
     * **Keys** are the name of the modules, **values** their corresponding navigation path.
     * For internal navigation paths (hosted in the same application), they have the format e.g. `@nav/api/foo`
     * where `@nav` represents the root node of the application. For documentation hosted elsewhere, absolute
     * URL is required (e.g. `https://w3nest.org/foo-doc/latest?nav='/api').
     *
     * <note level="warning">
     * It should at least includes on item: the navigation path for the `entryModule`. For instance
     * for a project `Foo` exposed in the application at `/api`, it becomes `{Foo: '@nav/api`}`.
     * </note>
     *
     */
    /**
     * Defines the navigation paths for the modules involved in the project and documented using the Code API plugin.
     *
     * - **Keys** are module names (e.g., `Foo`, `Bar`).
     * - **Values** are the corresponding navigation targets:
     *   - For internal links (within the same app), use the format: `@nav/<path>`, e.g. `@nav/api`.
     *   - For external documentation, use a full URL, e.g. `https://w3nest.org/foo-doc/latest?nav=/api`.
     *
     * <note level="warning">
     * At minimum, this map must include the entry for the root module being documented.
     * For example, if the project's entry module is named `Foo` and its documentation is served under `/api`,
     * you should include: `{ Foo: '@nav/api' }`.
     * </note>
     */
    rootModulesNav: Record<string, string>
}
