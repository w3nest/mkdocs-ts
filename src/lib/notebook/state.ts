import {
    BehaviorSubject,
    Subject,
    filter,
    ReplaySubject,
    switchMap,
    from,
    map,
    firstValueFrom,
    Observable,
} from 'rxjs'
import { OutputsView } from './cell-views'
import * as webpm from '@w3nest/webpm-client'
import { AnyVirtualDOM } from 'rx-vdom'
import {
    CellCommonAttributes,
    defaultCellAttributes,
    Dependencies,
    DeportedOutputsView,
    InterpreterCellView,
    JsCellExecutor,
    JsCellView,
    MdCellView,
    NotebookPage,
    PyCellExecutor,
    PyCellView,
    Views,
} from '.'
import { Router } from '../router'
import { fromFetch } from 'rxjs/fetch'
import type { MdParsingOptions } from '../markdown'
import { defaultDisplayFactory, DisplayFactory } from './display-utils'
import { WorkerCellView } from './worker-cell-view'
import { Pyodide, PyodideNamespace } from './py-execution'
import { Resolvable } from '../navigation.node'
import { ContextTrait, Contextual, NoContext } from '../context'

export type CellStatus =
    | 'unready'
    | 'ready'
    | 'success'
    | 'error'
    | 'pending'
    | 'executing'

/**
 * Represents the scope of a cell.
 *
 * This is a work in progress: at least functions and classes are missing.
 */
export interface Scope {
    /**
     * The `let` variables: keyed by their name and mapped to their values.
     */
    let: Record<string, unknown>
    /**
     * The `const` variables: keyed by their name and mapped to their values.
     */
    const: Record<string, unknown>

    /**
     * The exported globals of python runtime.
     */
    python: Record<string, unknown>
}

/**
 * Type of the outputs generated by a cell.
 *
 * The type `undefined` is a signal to clear the outputs displayed.
 */
export type Output = AnyVirtualDOM | undefined

/**
 * Arguments used to execute a cell, see {@link CellTrait.execute}.
 */
export interface ExecArgs {
    /**
     * Cell ID.
     */
    cellId: string
    /**
     * Source to execute.
     */
    src: string

    /**
     * The function used to load a submodule from a notebook page.
     *
     * @param path Navigation path of the submodule.
     * @param ctx Execution context used for logging and tracing.
     * @returns The exported symbols.
     */
    load: (path: string, ctx: ContextTrait) => Promise<Record<string, unknown>>

    /**
     * Subject in which output (*e.g.* when using  Ì€display` in a {@link JsCellView}) are sent.
     */
    output$: Subject<Output>

    /**
     * The factory used to pick up the right mapping between variable and view when `display` is called.
     */
    displayFactory: DisplayFactory

    /**
     * Owning state of the cell.
     */
    owningState: State
    /**
     * Entering scope of the cell.
     */
    scope: Scope
}

/**
 * Trait for a Cell within a {@link NotebookPage}.
 */
export interface CellTrait {
    /**
     * Cell unique ID.
     */
    cellId: string
    /**
     * Observable over the source content of the cell.
     */
    content$: BehaviorSubject<string>
    /**
     * Define the implementation of cell execution.
     */
    execute: (args: ExecArgs, ctx?: ContextTrait) => Promise<Scope>
}

export function getCellUid(): string {
    const rnd = Math.floor(Math.random() * Math.pow(10, 6))
    return `cell-${String(rnd)}`
}

interface ContentTrait {
    layout: {
        content: ({ router }: { router: Router }) => Resolvable<AnyVirtualDOM>
    }
}
function hasContentViewTrait(node: unknown): node is ContentTrait {
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    return (node as ContentTrait)?.layout?.content !== undefined
}

export class ExecCellError extends Error {
    description: string
    line: number
    column: number
    src: string[]
    constructor(params: {
        description: string
        line: number
        column: number
        src: string[]
    }) {
        super(params.description)
        Object.assign(this, params)
    }
}

export class AstParsingError extends ExecCellError {}

export class RunTimeError extends ExecCellError {
    public readonly scopeIn: Scope
    constructor(params: {
        description: string
        line: number
        column: number
        src: string[]
        scopeIn: Scope
    }) {
        super(params)
        this.scopeIn = params.scopeIn
    }
}

/**
 * Represents the state of a {@link NotebookPage}.
 */
export class State {
    /**
     * Observables over the cell's entering scopes keyed by the cell's ID.
     */
    public readonly scopes$: Record<
        string,
        BehaviorSubject<Scope | undefined>
    > = {}

    /**
     * The factory used to pick up the right mapping between variable and view when `display` is called.
     */
    public readonly displayFactory: DisplayFactory = defaultDisplayFactory()

    /**
     * Observable that emits the ID of invalidated cells.
     */
    public readonly invalidated$ = new Subject<string>()
    /**
     * Observables over the cell's output keyed by the cell's ID.
     */
    public readonly outputs$: Record<string, ReplaySubject<Output>> = {}

    /**
     * Observables over the cell's errors keyed by the cell's ID.
     */
    public readonly errors$: Record<
        string,
        ReplaySubject<ExecCellError | undefined>
    > = {}

    /**
     * Observables over the cell's source keyed by the cell's ID.
     */
    public readonly src$: Record<string, BehaviorSubject<string>> = {}
    /**
     * Observables over the cell's status keyed by the cell's ID.
     */
    public readonly cellsStatus$: Record<string, BehaviorSubject<CellStatus>> =
        {}

    /**
     * Observables over the cell IDs included in the associated {@link NotebookPage}.
     */
    public readonly cellIds$ = new BehaviorSubject<string[]>([])

    /**
     * Observables over whether the cell is currently executing keyed by the cell's ID.
     */
    public readonly executing$: Record<string, BehaviorSubject<boolean>> = {}

    /**
     * The deported output views as a list of their associated cell ID.
     */
    public readonly deportedOutputsViews: string[] = []

    /**
     * List of the cell IDs in the page.
     */
    public readonly ids: string[] = []
    /**
     * List of the cells in the page.
     */
    public readonly cells: CellTrait[] = []

    /**
     * The initial scope (provided to the first cell when executed).
     */
    public readonly initialScope: Scope
    /**
     * Optional related parent state (*e.g.* {@link MdCellView} own their own executing state created upon execution).
     */
    public readonly parent?: { state: State; cellId: string }

    /**
     * The application router, used to import modules from other notebook pages.
     */
    public readonly router: Router

    public readonly modules: Record<string, { state: State; exports: Scope }> =
        {}

    public readonly context: ContextTrait
    /**
     * Pyodide execution should be namespaced by notebook page,
     * this variable holds the symbols.
     *
     * This is a python dictionary initialized with `pyodide.globals.get("dict")()`
     * when the notebook page is loaded and reused across python cells.
     */
    private pyNamespace?: PyodideNamespace

    constructor(
        params: {
            initialScope?: Partial<Scope>
            router: Router
            displayFactory?: DisplayFactory
            parent?: { state: State; cellId: string }
        },
        ctx?: ContextTrait,
    ) {
        Object.assign(this, { router: params.router, parent: params.parent })
        this.context = ctx ?? new NoContext()
        ctx = this.context.start('new State', ['Notebook'])
        this.displayFactory = [
            ...this.displayFactory,
            ...(params.displayFactory ?? []),
        ]
        this.initialScope = {
            let: params.initialScope?.let ?? {},
            const: {
                webpm,
                Views,
                ...(params.initialScope?.const ?? {}),
            },
            python: params.initialScope?.python ?? {},
        }

        if (params.parent !== undefined) {
            const parent = params.parent
            parent.state.invalidated$
                .pipe(filter((cellId) => cellId === parent.cellId))
                .subscribe(() => {
                    if (this.ids.length === 0) {
                        return
                    }
                    this.unreadyCells({ afterCellId: this.ids[0] })
                    Object.values(this.outputs$).forEach((output$) => {
                        output$.next(undefined)
                    })
                })
        }
        ctx.exit()
    }
    ctx(ctx?: ContextTrait) {
        if (ctx) {
            return ctx
        }
        return this.context
    }

    getPyNamespace(pyodide: Pyodide): PyodideNamespace {
        this.pyNamespace ??= pyodide.globals.get('dict')()
        return this.pyNamespace
    }

    appendCell(cell: CellTrait) {
        this.ids.push(cell.cellId)
        this.cellIds$.next(this.ids)
        this.cells.push(cell)
        if (!(cell.cellId in this.outputs$)) {
            this.outputs$[cell.cellId] = new ReplaySubject()
            this.errors$[cell.cellId] = new ReplaySubject()
            this.executing$[cell.cellId] = new BehaviorSubject(false)
            this.src$[cell.cellId] = cell.content$
        }

        this.cellsStatus$[cell.cellId] = new BehaviorSubject<CellStatus>(
            this.ids.length === 1 ? 'ready' : 'unready',
        )
        this.scopes$[cell.cellId] =
            Object.keys(this.scopes$).length === 0
                ? new BehaviorSubject<Scope | undefined>(this.initialScope)
                : new BehaviorSubject<Scope | undefined>(undefined)
        cell.content$.subscribe((src) => {
            this.updateSrc({ cellId: cell.cellId, src })
        })
    }

    createJsCell(elem: HTMLElement): JsCellView {
        const cell = JsCellView.FromDom({ elem, state: this })
        this.appendCell(cell)
        return cell
    }

    createPyCell(elem: HTMLElement): PyCellView {
        const cell = PyCellView.FromDom({ elem, state: this })
        this.appendCell(cell)
        return cell
    }

    createMdCell(
        elem: HTMLElement,
        parserOptions: MdParsingOptions,
    ): MdCellView {
        const cell = MdCellView.FromDom({ elem, state: this, parserOptions })
        this.appendCell(cell)
        return cell
    }

    createInterpreterCell(elem: HTMLElement): InterpreterCellView {
        const cell = InterpreterCellView.FromDom({ elem, state: this })
        this.appendCell(cell)
        return cell
    }

    createWorkerCell(elem: HTMLElement): WorkerCellView {
        const cell = WorkerCellView.FromDom({ elem, state: this })
        this.appendCell(cell)
        return cell
    }

    createDeportedOutputsView(elem: HTMLElement): OutputsView {
        const cellId = DeportedOutputsView.FromDomAttributes.cellId(elem)
        if (!cellId) {
            throw Error("Can not find 'cell-id' to create deported output.")
        }
        if (!(cellId in this.outputs$)) {
            this.outputs$[cellId] = new ReplaySubject()
            this.executing$[cellId] = new BehaviorSubject(false)
            this.errors$[cellId] = new ReplaySubject()
        }
        this.deportedOutputsViews.push(cellId)
        return DeportedOutputsView.FromDom({
            elem,
            output$: this.outputs$[cellId],
        })
    }

    updateSrc({ cellId, src }: { cellId: string; src: string }) {
        if (!(cellId in this.src$)) {
            this.src$[cellId] = new BehaviorSubject(src)
        }
        this.cellsStatus$[cellId].next('ready')
        this.unreadyCells({ afterCellId: cellId })
        if (this.parent) {
            this.parent.state.unreadyCells({ afterCellId: this.parent.cellId })
        }
    }
    getResolvedScope(cellId: string): Scope {
        if (
            !(cellId in this.scopes$) ||
            this.scopes$[cellId].value === undefined
        ) {
            throw Error(`Can not find scope for ${cellId}`)
        }
        return this.scopes$[cellId].value
    }
    @Contextual({ async: true, key: (id: string) => id })
    async execute(id: string, rootExecution = true, ctx?: ContextTrait) {
        ctx = this.ctx(ctx)

        if (this.ids.length === 0) {
            return this.initialScope
        }
        const index = this.ids.indexOf(id)
        this.cellsStatus$[id].next('pending')
        if (!this.scopes$[id].value) {
            ctx.info('No scope available, run previous cell')
            await this.execute(this.ids[index - 1], false, ctx)
        }
        const inputScope = this.getResolvedScope(id)

        ctx.info('Input scope retrieved', inputScope)
        const output$ = this.outputs$[id]

        output$.next(undefined)
        this.cellsStatus$[id].next('executing')
        this.executing$[id].next(true)
        this.errors$[id].next(undefined)
        try {
            const scope = await this.cells[index].execute(
                {
                    src: this.src$[id].value,
                    scope: inputScope,
                    output$,
                    displayFactory: this.displayFactory,
                    load: this.loadModule(id),
                    cellId: id,
                    owningState: this,
                },
                ctx,
            )
            this.cellsStatus$[id].next('success')
            const nextId = this.ids[index + 1]
            const remainingIds = this.ids.slice(index + 2)
            if (nextId) {
                this.scopes$[nextId].next(scope)
                this.cellsStatus$[nextId].next('ready')
            }
            if (nextId) {
                this.scopes$[nextId].next(scope)
            }
            remainingIds.forEach((id) => {
                if (rootExecution) {
                    this.cellsStatus$[id].next('unready')
                }
                this.scopes$[id].next(undefined)
                this.executing$[id].next(false)
            })
            return scope
        } catch (e: unknown) {
            this.errors$[id].next(e as ExecCellError)
            throw e
        }
    }
    private invalidateCells(cellId: string) {
        this.invalidated$.next(cellId)
    }

    private dispose() {
        this.cells.forEach((cell) => {
            this.invalidateCells(cell.cellId)
        })
        Object.values(this.modules).forEach(({ state }) => {
            state.dispose()
        })
    }

    unreadyCells({ afterCellId }: { afterCellId: string }) {
        const index = this.ids.indexOf(afterCellId)
        this.invalidateCells(afterCellId)
        const remainingIds = this.ids.slice(index + 1)
        remainingIds.forEach((id) => {
            this.cellsStatus$[id].next('unready')
            this.scopes$[id].next(undefined)
            this.executing$[id].next(false)
            this.invalidateCells(id)
        })
    }

    private loadModule(cellId: string) {
        const components = ({
            state,
        }: {
            state: State
            cellOptions: CellCommonAttributes
        }) => {
            return {
                'js-cell': (elem: HTMLElement) => {
                    const id =
                        elem.getAttribute('cell-id') ?? elem.getAttribute('id')
                    const reactive = elem.getAttribute('reactive') === 'true'
                    const uid = Math.floor(Math.random() * Math.pow(10, 6))
                    const cell = new JsCellExecutor({
                        cellId: id ?? `cell-${String(uid)}`,
                        content$: new BehaviorSubject(elem.textContent ?? ''),
                        state: state,
                        cellAttributes: {
                            reactive,
                        },
                    })
                    state.appendCell(cell)
                    return { tag: 'div' as const }
                },
                'py-cell': (elem: HTMLElement) => {
                    const id =
                        elem.getAttribute('cell-id') ?? elem.getAttribute('id')
                    const uid = Math.floor(Math.random() * Math.pow(10, 6))
                    const cell = new PyCellExecutor({
                        cellId: id ?? `cell-${String(uid)}`,
                        content$: new BehaviorSubject(elem.textContent ?? ''),
                        state: state,
                        cellAttributes: {},
                    })
                    state.appendCell(cell)
                    return { tag: 'div' as const }
                },
            }
        }

        return async (path: string, ctx: ContextTrait) => {
            ctx.info(`Load module ${path}`)
            const router = this.router
            if (path in this.modules) {
                this.modules[path].state.dispose()
            }
            const nav = router.getNav({ path }, ctx)
            if (!(nav instanceof Observable)) {
                throw Error(`Can not find module at ${path}`)
            }
            const module$ = nav.pipe(
                filter((nav) => hasContentViewTrait(nav)),
                map((nav) => {
                    const nbPage = nav.layout.content({
                        router,
                    })
                    if (nbPage instanceof NotebookPage) {
                        return nbPage
                    }
                    throw Error(
                        `The page imported with ${path} is not a 'NotebookPage'`,
                    )
                }),
                switchMap((nbPage) => {
                    const parsingOptions = nbPage.options.markdown ?? {}
                    return fromFetch(nbPage.url).pipe(
                        map((resp) => ({
                            resp,
                            parsingOptions,
                            nbCtx: nbPage.context,
                        })),
                    )
                }),
                switchMap(({ resp, parsingOptions, nbCtx }) =>
                    from(resp.text()).pipe(
                        map((src) => ({ src, parsingOptions, nbCtx })),
                    ),
                ),
                switchMap(({ src, parsingOptions, nbCtx }) => {
                    const state = new State(
                        {
                            router,
                            parent: { state: this, cellId },
                        },
                        nbCtx,
                    )
                    Dependencies.parseMd({
                        ...parsingOptions,
                        src: extractExportedCode(src),
                        router,
                        views: {
                            ...components({
                                state,
                                cellOptions: defaultCellAttributes,
                            }),
                        },
                    })
                    return from(state.execute(state.ids.slice(-1)[0])).pipe(
                        map((scope) => {
                            this.modules[path] = { exports: scope, state }
                            return this.modules[path]
                        }),
                    )
                }),
            )

            const { exports } = await firstValueFrom(module$)
            return {
                ...exports.const,
                ...exports.let,
                ...exports.python,
            }
        }
    }
}

function extractExportedCode(text: string) {
    let acc = ''
    text.split('\n').reduce((isExported, line) => {
        const startsExport =
            line.startsWith('<js-cell') || line.startsWith('<py-cell')
        const endsExport =
            line.startsWith('</js-cell>') || line.startsWith('</py-cell')

        if (isExported || startsExport) {
            acc += `${line}\n`
        }
        if (startsExport) {
            return true
        }
        if (endsExport) {
            return false
        }
        return isExported
    }, false)
    return acc
}
