import {
    BehaviorSubject,
    Subject,
    filter,
    ReplaySubject,
    switchMap,
    from,
    map,
    firstValueFrom,
} from 'rxjs'
import { OutputsView } from './cell-views'
import * as webpm from '@w3nest/webpm-client'
import { AnyVirtualDOM } from 'rx-vdom'
import {
    CellCommonAttributes,
    defaultCellAttributes,
    Dependencies,
    DeportedOutputsView,
    InterpreterCellView,
    JsCellExecutor,
    JsCellView,
    MdCellView,
    NotebookPage,
    PyCellExecutor,
    PyCellView,
    Views,
} from '.'
import { Router } from '../router'
import { fromFetch } from 'rxjs/fetch'
import type { MdParsingOptions } from '../markdown'
import { defaultDisplayFactory, DisplayFactory } from './display-utils'
import { WorkerCellView } from './worker-cell-view'
import { Pyodide, PyodideNamespace } from './py-execution'
import { AnyView, Resolvable, resolve } from '../navigation.node'
import { ContextTrait, Contextual, NoContext } from '../context'
import { ExecInput } from './execution-common'

export type CellStatus =
    | 'unready'
    | 'ready'
    | 'success'
    | 'error'
    | 'pending'
    | 'executing'

/**
 * Represents the scope of a cell.
 *
 * This is a work in progress: at least functions and classes are missing.
 */
export interface Scope {
    /**
     * The `let` variables: keyed by their name and mapped to their values.
     */
    let: Record<string, unknown>
    /**
     * The `const` variables: keyed by their name and mapped to their values.
     */
    const: Record<string, unknown>

    /**
     * The exported globals of python runtime.
     */
    python: Record<string, unknown>
}

/**
 * Type of the outputs generated by a cell.
 *
 * The type `undefined` is a signal to clear the outputs displayed.
 */
export type Output = AnyVirtualDOM | undefined

/**
 * Arguments used to execute a cell, see {@link CellTrait.execute}.
 */
export type ExecArgs = Omit<ExecInput, 'invalidated$'> & {
    /**
     * The function used to load a submodule from a notebook page.
     *
     * @param path Navigation path of the submodule.
     * @param ctx Execution context used for logging and tracing.
     * @returns The exported symbols.
     */
    load: (path: string, ctx: ContextTrait) => Promise<Record<string, unknown>>

    /**
     * Owning state of the cell.
     */
    owningState: State
}

/**
 * Trait for a Cell within a {@link NotebookPage}.
 */
export interface CellTrait {
    /**
     * Cell unique ID.
     */
    cellId: string
    /**
     * Observable over the source content of the cell.
     */
    content$: BehaviorSubject<string>
    /**
     * Define the implementation of cell execution.
     */
    execute: (args: ExecArgs, ctx?: ContextTrait) => Promise<Scope>
}

export function getCellUid(): string {
    const rnd = Math.floor(Math.random() * Math.pow(10, 6))
    return `cell-${String(rnd)}`
}

interface ContentTrait {
    layout: {
        content: ({ router }: { router: Router }) => Resolvable<AnyVirtualDOM>
    }
}
function hasContentViewTrait(node: unknown): node is ContentTrait {
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    return (node as ContentTrait)?.layout?.content !== undefined
}

export interface ExecCellError {
    cellId: string
    kind: 'AST' | 'Runtime'
    message: string
    src: string[]
    lineNumber?: number
    column?: number
    stackTrace?: string[]
    scopeIn?: Scope
}

/**
 * Parameters to instantiate a {@link State}.
 */
export interface NotebookStateParameters {
    /**
     * Application's router.
     */
    router: Router
    /**
     * Initial scope provided to the first executing cell.
     */
    initialScope?: Partial<Scope>
    /**
     * Additional custom {@link DisplayFactory} invoked when `display` is used.
     */
    displayFactory?: DisplayFactory
}

/**
 * Defines a factory function signature for creating a specific type of cell.
 *
 * Each factory function is responsible for constructing a cell's behavior and view
 * based on the provided notebook state and HTML representation.
 *
 * Factory functions are registered in {@link State.CellsFactory} and are invoked
 * when parsing Markdown source containing corresponding cell elements.
 */
export type CellFactory = (p: {
    // The notebook page state.
    state: State
    // The HTML cell declaration in the Markdown source.
    elem: HTMLElement
    // Markdown parsing options.
    parserOptions: MdParsingOptions
}) => CellTrait & AnyView

/**
 * Represents the state of a {@link NotebookPage} or {@link NotebookSection}.
 */
export class State {
    /**
     * A registry of cell factory functions.
     *
     * The keys in this mapping correspond to the tag names of cell elements
     * in the Markdown source. Each registered factory function defines how
     * a specific cell type should be instantiated and rendered.
     *
     * **Registering a New Cell Type**
     *
     * To add a new cell type, extend `State.CellsFactory` as shown below:
     *
     * <code-snippet language="javascript">
     * State.CellsFactory = {
     *     ...State.CellsFactory,
     *     'custom-cell': (p:{state: State, elem: HTMLElement}) => {
     *          const src = elem.textContent()
     *          const attFoo = elem.getAttribute('foo')
     *          // Return an instance of `CellTrait & AnyView`
     *      }
     * }
     * </code-snippet>
     *
     * Once registered, the following Markdown source:
     *
     * <code-snippet language="markdown">
     * The next cell is a `custom-cell`:
     *
     * <custom-cell foo="42">
     *     ...
     * </custom-cell>
     *
     * </code-snippet>
     *
     * Will be recognized and processed accordingly.
     */
    public static CellsFactory: Record<string, CellFactory> = {
        'js-cell': (p) => {
            return JsCellView.FromDom(p)
        },
        'md-cell': (p) => {
            return MdCellView.FromDom(p)
        },
        'py-cell': (p) => {
            return PyCellView.FromDom(p)
        },
        'interpreter-cell': (p) => {
            return InterpreterCellView.FromDom(p)
        },
        'worker-cell': (p) => {
            return WorkerCellView.FromDom(p)
        },
    }

    /**
     * Observables over the cell's entering scopes keyed by the cell's ID.
     */
    public readonly scopes$: Record<
        string,
        BehaviorSubject<Scope | undefined>
    > = {}
    /**
     * Observables over the cell's exiting scopes keyed by the cell's ID.
     */
    public readonly exitScopes$: Record<string, ReplaySubject<Scope>> = {}
    /**
     * The factory used to pick up the right mapping between variable and view when `display` is called.
     */
    public readonly displayFactory: DisplayFactory = defaultDisplayFactory()

    /**
     * Observable that emits the ID of invalidated cells.
     */
    public readonly invalidated$ = new Subject<string>()
    /**
     * Observables over the cell's output keyed by the cell's ID.
     */
    public readonly outputs$: Record<string, ReplaySubject<Output>> = {}

    /**
     * Observables over the cell's errors keyed by the cell's ID.
     */
    public readonly errors$: Record<
        string,
        ReplaySubject<ExecCellError | undefined>
    > = {}

    /**
     * Observables over the cell's source keyed by the cell's ID.
     */
    public readonly src$: Record<string, BehaviorSubject<string>> = {}
    /**
     * Observables over the cell's status keyed by the cell's ID.
     */
    public readonly cellsStatus$: Record<string, BehaviorSubject<CellStatus>> =
        {}

    /**
     * Observables over the cell IDs included in the associated {@link NotebookPage}.
     */
    public readonly cellIds$ = new BehaviorSubject<string[]>([])

    /**
     * Observables over whether the cell is currently executing keyed by the cell's ID.
     */
    public readonly executing$: Record<string, BehaviorSubject<boolean>> = {}

    /**
     * The deported output views as a list of their associated cell ID.
     */
    public readonly deportedOutputsViews: string[] = []

    /**
     * List of the cell IDs in the page.
     */
    public readonly ids: string[] = []
    /**
     * List of the cells in the page.
     */
    public readonly cells: CellTrait[] = []

    /**
     * The initial scope (provided to the first cell when executed).
     */
    public readonly initialScope: Scope
    /**
     * Optional related parent state (*e.g.* {@link MdCellView} own their own executing state created upon execution).
     */
    public readonly parent?: { state: State; cellId: string }

    /**
     * The application router, used to import modules from other notebook pages.
     */
    public readonly router: Router

    public readonly modules: Record<string, { state: State; exports: Scope }> =
        {}

    public readonly context: ContextTrait
    /**
     * Pyodide execution should be namespaced by notebook page,
     * this variable holds the symbols.
     *
     * This is a python dictionary initialized with `pyodide.globals.get("dict")()`
     * when the notebook page is loaded and reused across python cells.
     */
    private pyNamespace?: PyodideNamespace

    constructor(
        params: NotebookStateParameters & {
            parent?: { state: State; cellId: string }
        },
        ctx?: ContextTrait,
    ) {
        Object.assign(this, { router: params.router, parent: params.parent })
        this.context = ctx ?? new NoContext()
        ctx = this.context.start('new State', ['Notebook'])
        this.displayFactory = [
            ...this.displayFactory,
            ...(params.displayFactory ?? []),
        ]
        this.initialScope = {
            let: params.initialScope?.let ?? {},
            const: {
                webpm,
                Views,
                ...(params.initialScope?.const ?? {}),
            },
            python: params.initialScope?.python ?? {},
        }

        if (params.parent !== undefined) {
            const parent = params.parent
            parent.state.invalidated$
                .pipe(filter((cellId) => cellId === parent.cellId))
                .subscribe(() => {
                    if (this.ids.length === 0) {
                        return
                    }
                    this.unreadyCells({ afterCellId: this.ids[0] })
                    Object.values(this.outputs$).forEach((output$) => {
                        output$.next(undefined)
                    })
                })
        }
        ctx.exit()
    }
    ctx(ctx?: ContextTrait) {
        if (ctx) {
            return ctx
        }
        return this.context
    }

    getPyNamespace(pyodide: Pyodide): PyodideNamespace {
        this.pyNamespace ??= pyodide.globals.get('dict')()
        return this.pyNamespace
    }

    getCellsFactory(): Record<
        string,
        (elem: HTMLElement, parserOptions?: MdParsingOptions) => AnyView
    > {
        const deportedOutput = (elem: HTMLElement) => {
            return this.createDeportedOutputsView(elem)
        }
        return Object.entries(State.CellsFactory).reduce(
            (acc, [k, v]) => {
                const fct = (
                    elem: HTMLElement,
                    parserOptions: MdParsingOptions,
                ) => {
                    const cell = v({ state: this, elem, parserOptions })
                    this.appendCell(cell)
                    return cell
                }
                return { ...acc, [k]: fct }
            },
            {
                'cell-output': deportedOutput,
            },
        )
    }

    appendCell(cell: CellTrait) {
        this.ids.push(cell.cellId)
        this.cellIds$.next(this.ids)
        this.cells.push(cell)
        if (!(cell.cellId in this.outputs$)) {
            this.outputs$[cell.cellId] = new ReplaySubject()
            this.errors$[cell.cellId] = new ReplaySubject()
            this.executing$[cell.cellId] = new BehaviorSubject(false)
            this.src$[cell.cellId] = cell.content$
        }

        this.cellsStatus$[cell.cellId] = new BehaviorSubject<CellStatus>(
            this.ids.length === 1 ? 'ready' : 'unready',
        )
        this.scopes$[cell.cellId] =
            Object.keys(this.scopes$).length === 0
                ? new BehaviorSubject<Scope | undefined>(this.initialScope)
                : new BehaviorSubject<Scope | undefined>(undefined)
        this.exitScopes$[cell.cellId] = new ReplaySubject<Scope>(1)
        cell.content$.subscribe((src) => {
            this.updateSrc({ cellId: cell.cellId, src })
        })
    }

    createDeportedOutputsView(elem: HTMLElement): OutputsView {
        const cellId = DeportedOutputsView.FromDomAttributes.cellId(elem)
        if (!cellId) {
            throw Error("Can not find 'cell-id' to create deported output.")
        }
        if (!(cellId in this.outputs$)) {
            this.outputs$[cellId] = new ReplaySubject()
            this.executing$[cellId] = new BehaviorSubject(false)
            this.errors$[cellId] = new ReplaySubject()
        }
        this.deportedOutputsViews.push(cellId)
        return DeportedOutputsView.FromDom({
            elem,
            output$: this.outputs$[cellId],
        })
    }

    updateSrc({ cellId, src }: { cellId: string; src: string }) {
        if (!(cellId in this.src$)) {
            this.src$[cellId] = new BehaviorSubject(src)
        }
        this.cellsStatus$[cellId].next('ready')
        this.unreadyCells({ afterCellId: cellId })
        if (this.parent) {
            this.parent.state.unreadyCells({ afterCellId: this.parent.cellId })
        }
    }
    getResolvedScope(cellId: string): Scope {
        if (
            !(cellId in this.scopes$) ||
            this.scopes$[cellId].value === undefined
        ) {
            throw Error(`Can not find scope for ${cellId}`)
        }
        return this.scopes$[cellId].value
    }
    @Contextual({ async: true, key: (id: string) => id })
    async execute(id: string, rootExecution = true, ctx?: ContextTrait) {
        ctx = this.ctx(ctx)

        if (this.ids.length === 0) {
            return this.initialScope
        }
        const index = this.ids.indexOf(id)
        this.cellsStatus$[id].next('pending')
        if (!this.scopes$[id].value) {
            ctx.info('No scope available, run previous cell')
            await this.execute(this.ids[index - 1], false, ctx)
        }
        const inputScope = this.getResolvedScope(id)

        ctx.info('Input scope retrieved', inputScope)
        const output$ = this.outputs$[id]

        output$.next(undefined)
        this.cellsStatus$[id].next('executing')
        this.executing$[id].next(true)
        this.errors$[id].next(undefined)
        this.unreadyCells({ afterCellId: id })
        const scope = await this.cells[index].execute(
            {
                src: this.src$[id].value,
                scope: inputScope,
                output$,
                error$: this.errors$[id],
                displayFactory: this.displayFactory,
                load: this.loadModule(id),
                cellId: id,
                owningState: this,
            },
            ctx,
        )
        this.exitScopes$[id].next(scope)
        this.cellsStatus$[id].next('success')
        const nextId = this.ids[index + 1]
        const remainingIds = this.ids.slice(index + 2)
        if (nextId) {
            this.scopes$[nextId].next(scope)
            this.cellsStatus$[nextId].next('ready')
        }
        remainingIds.forEach((id) => {
            if (rootExecution) {
                this.cellsStatus$[id].next('unready')
            }
            this.scopes$[id].next(undefined)
            this.executing$[id].next(false)
        })
        return scope
    }
    private invalidateCells(cellId: string) {
        this.invalidated$.next(cellId)
    }

    public dispose() {
        this.cells.forEach((cell) => {
            this.invalidateCells(cell.cellId)
        })
        Object.values(this.modules).forEach(({ state }) => {
            state.dispose()
        })
    }

    unreadyCells({ afterCellId }: { afterCellId: string }) {
        const index = this.ids.indexOf(afterCellId)
        this.invalidateCells(afterCellId)
        const remainingIds = this.ids.slice(index + 1)
        remainingIds.forEach((id) => {
            this.cellsStatus$[id].next('unready')
            this.scopes$[id].next(undefined)
            this.executing$[id].next(false)
            this.invalidateCells(id)
        })
    }

    private loadModule(cellId: string) {
        const components = ({
            state,
        }: {
            state: State
            cellOptions: CellCommonAttributes
        }) => {
            return {
                'js-cell': (elem: HTMLElement) => {
                    const id =
                        elem.getAttribute('cell-id') ?? elem.getAttribute('id')
                    const reactive = elem.getAttribute('reactive') === 'true'
                    const uid = Math.floor(Math.random() * Math.pow(10, 6))
                    const cell = new JsCellExecutor({
                        cellId: id ?? `cell-${String(uid)}`,
                        content$: new BehaviorSubject(elem.textContent ?? ''),
                        state: state,
                        cellAttributes: {
                            reactive,
                        },
                    })
                    state.appendCell(cell)
                    return { tag: 'div' as const }
                },
                'py-cell': (elem: HTMLElement) => {
                    const id =
                        elem.getAttribute('cell-id') ?? elem.getAttribute('id')
                    const uid = Math.floor(Math.random() * Math.pow(10, 6))
                    const cell = new PyCellExecutor({
                        cellId: id ?? `cell-${String(uid)}`,
                        content$: new BehaviorSubject(elem.textContent ?? ''),
                        state: state,
                        cellAttributes: {},
                    })
                    state.appendCell(cell)
                    return { tag: 'div' as const }
                },
            }
        }

        return async (path: string, ctx: ContextTrait) => {
            ctx.info(`Load module ${path}`)
            const router = this.router
            if (path in this.modules) {
                this.modules[path].state.dispose()
            }
            const nav = await router.getNav({ path }, ctx)
            if (nav === 'not-found') {
                throw Error(`Can not find module at ${path}`)
            }
            if (!hasContentViewTrait(nav)) {
                throw Error(
                    'The navigation node does not defines expected content',
                )
            }
            const content = nav.layout.content({
                router,
            })
            const module$ = resolve(content).pipe(
                map((nbPage) => {
                    if (nbPage instanceof NotebookPage) {
                        return nbPage
                    }
                    throw Error(
                        `The page imported with ${path} is not a 'NotebookPage'`,
                    )
                }),
                switchMap((nbPage) => {
                    const parsingOptions = nbPage.options?.markdown ?? {}
                    return fromFetch(nbPage.url).pipe(
                        map((resp) => ({
                            resp,
                            parsingOptions,
                            nbCtx: nbPage.context,
                        })),
                    )
                }),
                switchMap(({ resp, parsingOptions, nbCtx }) =>
                    from(resp.text()).pipe(
                        map((src) => ({ src, parsingOptions, nbCtx })),
                    ),
                ),
                switchMap(({ src, parsingOptions, nbCtx }) => {
                    const state = new State(
                        {
                            router,
                            parent: { state: this, cellId },
                        },
                        nbCtx,
                    )
                    Dependencies.parseMd({
                        ...parsingOptions,
                        src: extractExportedCode(src),
                        router,
                        views: {
                            ...components({
                                state,
                                cellOptions: defaultCellAttributes,
                            }),
                        },
                    })
                    return from(state.execute(state.ids.slice(-1)[0])).pipe(
                        map((scope) => {
                            this.modules[path] = { exports: scope, state }
                            return this.modules[path]
                        }),
                    )
                }),
            )

            const { exports } = await firstValueFrom(module$)
            return {
                ...exports.const,
                ...exports.let,
                ...exports.python,
            }
        }
    }
}

function extractExportedCode(text: string) {
    let acc = ''
    text.split('\n').reduce((isExported, line) => {
        const startsExport =
            line.startsWith('<js-cell') || line.startsWith('<py-cell')
        const endsExport =
            line.startsWith('</js-cell>') || line.startsWith('</py-cell')

        if (isExported || startsExport) {
            acc += `${line}\n`
        }
        if (startsExport) {
            return true
        }
        if (endsExport) {
            return false
        }
        return isExported
    }, false)
    return acc
}
