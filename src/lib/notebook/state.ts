import { BehaviorSubject, Subject, Subscription, filter } from 'rxjs'
import { OutputsView } from './cell-views'
import * as webpm from '@youwol/webpm-client'
import { AnyVirtualDOM, CSSAttribute } from '@youwol/rx-vdom'
import { Views } from '.'

export type CellStatus = 'unready' | 'ready' | 'success' | 'error'

/**
 * Represents the scope of a cell.
 *
 * This is a work in progress: at least functions and classes are missing.
 */
export type Scope = {
    /**
     * The `let` variables: keyed by their name and mapped to their values.
     */
    let: { [k: string]: unknown }
    /**
     * The `const` variables: keyed by their name and mapped to their values.
     */
    const: { [k: string]: unknown }
}

/**
 * The empty scope, `webpm` is included to allow resources installation.
 */
export const emptyScope: Scope = {
    let: {},
    const: { webpm, Views },
}

/**
 * Type of the outputs generated by a cell.
 *
 * The type `undefined` is a signal to clear the outputs displayed.
 */
export type Output = AnyVirtualDOM | undefined

/**
 * Arguments used to execute a cell, see {@link CellTrait.execute}.
 */
export type ExecArgs = {
    /**
     * Cell ID.
     */
    cellId: string
    /**
     * Source to execute.
     */
    src: string
    /**
     * Subject in which output (*e.g.* when using  Ì€display` in a {@link JsCellView}) are sent.
     */
    output$: Subject<Output>
    /**
     * Owning state of the cell.
     */
    owningState: State
    /**
     * Entering scope of the cell.
     */
    scope: Scope
}

/**
 * Trait for a Cell within a {@link NotebookPage}.
 */
export interface CellTrait {
    /**
     * Cell unique ID.
     */
    cellId: string
    /**
     * Observable over the source content of the cell.
     */
    content$: BehaviorSubject<string>
    /**
     * Define the implementation of cell execution.
     */
    execute: (args: ExecArgs) => Promise<Scope>
}

/**
 * Represents the state of a {@link NotebookPage}.
 */
export class State {
    /**
     * Observables over the cell's entering scopes keyed by the cell's ID.
     */
    public readonly scopes$: {
        [k: string]: BehaviorSubject<Scope | undefined>
    } = {}

    /**
     * Observable that emits the ID of invalidated cells.
     */
    public readonly invalidated$ = new Subject<string>()
    /**
     * Observables over the cell's output keyed by the cell's ID.
     */
    public readonly outputs$: { [k: string]: Subject<Output> } = {}
    /**
     * Observables over the cell's source keyed by the cell's ID.
     */
    public readonly src$: { [k: string]: BehaviorSubject<string> } = {}
    /**
     * Observables over the cell's status keyed by the cell's ID.
     */
    public readonly cellsStatus$: { [k: string]: BehaviorSubject<CellStatus> } =
        {}

    /**
     * Observables over the cell IDs included in the associated {@link NotebookPage}.
     */
    public readonly cellIds$ = new BehaviorSubject<string[]>([])

    /**
     * Observables over whether the cell is currently executing keyed by the cell's ID.
     */
    public readonly executing$: { [k: string]: BehaviorSubject<boolean> } = {}

    /**
     * The deported output views as a list of their associated cell ID.
     */
    public readonly deportedOutputsViews: string[] = []

    /**
     * List of the cell IDs in the page.
     */
    public readonly ids: string[] = []
    /**
     * List of the cells in the page.
     */
    public readonly cells: CellTrait[] = []

    /**
     * The initial scope (provided to the first cell when executed).
     */
    public readonly initialScope: Scope
    /**
     * Optional related parent state (*e.g.* {@link MdCellView} own their own executing state created upon execution).
     */
    public readonly parent?: { state: State; cellId: string }

    constructor(params: {
        initialScope: Scope
        parent?: { state: State; cellId: string }
    }) {
        Object.assign(this, params)
        if (params.parent) {
            params.parent.state.invalidated$
                .pipe(filter((cellId) => cellId === params.parent.cellId))
                .subscribe(() => {
                    if (this.ids.length === 0) {
                        return
                    }
                    this.unreadyCells({ afterCellId: this.ids[0] })
                    Object.values(this.outputs$).forEach((output$) =>
                        output$.next(undefined),
                    )
                })
        }
    }

    appendCell(cell: CellTrait) {
        this.ids.push(cell.cellId)
        this.cellIds$.next(this.ids)
        this.cells.push(cell)
        if (!this.outputs$[cell.cellId]) {
            this.outputs$[cell.cellId] = new Subject()
            this.executing$[cell.cellId] = new BehaviorSubject(false)
            this.src$[cell.cellId] = cell.content$
        }

        this.cellsStatus$[cell.cellId] = new BehaviorSubject<CellStatus>(
            this.ids.length === 1 ? 'ready' : 'unready',
        )
        this.scopes$[cell.cellId] =
            Object.keys(this.scopes$).length == 0
                ? new BehaviorSubject(this.initialScope)
                : new BehaviorSubject(undefined)
        cell.content$.subscribe((src) => {
            this.updateSrc({ cellId: cell.cellId, src })
        })
    }

    registerDeportedOutputsView({
        cellId,
        classList,
        style,
    }: {
        cellId: string
        classList: string
        style: CSSAttribute
    }): OutputsView {
        if (!this.outputs$[cellId]) {
            this.outputs$[cellId] = new Subject()
            this.executing$[cellId] = new BehaviorSubject(false)
        }
        const view = new OutputsView({
            output$: this.outputs$[cellId],
            style,
            classList,
        })
        this.deportedOutputsViews.push(cellId)
        return view
    }

    updateSrc({ cellId, src }: { cellId: string; src: string }) {
        if (!this.src$[cellId]) {
            this.src$[cellId] = new BehaviorSubject(src)
        }
        this.cellsStatus$[cellId].next('ready')
        this.unreadyCells({ afterCellId: cellId })
        if (this.parent) {
            this.parent.state.unreadyCells({ afterCellId: this.parent.cellId })
        }
    }
    async execute(id: string) {
        if (this.ids.length === 0) {
            return this.initialScope
        }
        const index = this.ids.indexOf(id)
        if (!this.scopes$[id].value) {
            await this.execute(this.ids[index - 1])
        }
        const scope$ = this.scopes$[id]
        const output$ = this.outputs$[id]

        output$.next(undefined)
        this.executing$[id].next(true)
        const scope = await this.cells[index].execute({
            src: this.src$[id].value,
            scope: scope$.getValue(),
            output$,
            cellId: id,
            owningState: this,
        })
        this.cellsStatus$[id].next('success')
        const nextId = this.ids[index + 1]
        const remainingIds = this.ids.slice(index + 2)
        if (nextId) {
            this.scopes$[nextId].next(scope)
            this.cellsStatus$[nextId].next('ready')
        }
        nextId && this.scopes$[nextId].next(scope)
        remainingIds.forEach((id) => {
            this.cellsStatus$[id].next('unready')
            this.scopes$[id].next(undefined)
            this.executing$[id].next(false)
        })
        return scope
    }
    private invalidateCells(cellId: string) {
        this.invalidated$.next(cellId)
    }
    unreadyCells({ afterCellId }: { afterCellId: string }) {
        const index = this.ids.indexOf(afterCellId)
        this.invalidateCells(afterCellId)
        const remainingIds = this.ids.slice(index + 1)
        remainingIds.forEach((id) => {
            this.cellsStatus$[id].next('unready')
            this.scopes$[id].next(undefined)
            this.executing$[id].next(false)
            this.invalidateCells(id)
        })
    }
}
