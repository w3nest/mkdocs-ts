{
    "name": "MainModule",
    "documentation": {
        "sections": [
            {
                "content": "Main module of the library.",
                "contentType": "markdown",
                "semantic": {
                    "role": "",
                    "labels": [],
                    "attributes": {},
                    "relations": {}
                }
            }
        ]
    },
    "path": "",
    "attributes": [],
    "types": [
        {
            "name": "GenericView",
            "documentation": {
                "sections": [
                    {
                        "content": "Represents a generic view of a router that can manages multiple layouts.\n\nThis view leverages a provided layout factory to map the  NavNodeData.layout \nspecified in  [Navigation](@nav/api/MainModule.Navigation)  to the appropriate layout.\n\nIf a layout kind is not found, the  [LayoutNotFoundView](@nav/api/MainModule.LayoutNotFoundView)  is displayed.\n\n<note level=\"hint\">\nThe layout factory is invoked only when there is a change in the layout kind during navigation.\nThis optimization prevents unnecessary redrawing of the entire view if the layout kind remains unchanged.\nThe layouts themselves should dynamically reflect the state of the  [Router.target$](@nav/api/MainModule.Router.target$)  observable.\n</note>",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "GenericView",
            "attributes": [
                {
                    "name": "children",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "Children of the element.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "GenericView.children",
                    "code": {
                        "filePath": "src/lib/generic.view.ts",
                        "declaration": "public readonly children: ChildrenLike",
                        "implementation": "",
                        "startLine": 66,
                        "endLine": 67,
                        "references": {
                            "children": "@nav/api/MainModule.GenericView.children",
                            "VirtualDOM.children": "-1"
                        }
                    }
                },
                {
                    "name": "class",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "The class associated with the element, equivalent to the  `className`  property of  `HTMLElement` .",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "GenericView.class",
                    "code": {
                        "filePath": "src/lib/generic.view.ts",
                        "declaration": "public readonly class = 'w-100 h-100'",
                        "implementation": "",
                        "startLine": 65,
                        "endLine": 66,
                        "references": {
                            "class": "@nav/api/MainModule.GenericView.class",
                            "VirtualDOM.class": "-1"
                        }
                    }
                },
                {
                    "name": "tag",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "The tag of the element, equivalent to the  `tagName`  property of  `HTMLElement` .",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "GenericView.tag",
                    "code": {
                        "filePath": "src/lib/generic.view.ts",
                        "declaration": "public readonly tag = 'div'",
                        "implementation": "",
                        "startLine": 64,
                        "endLine": 65,
                        "references": {
                            "tag": "@nav/api/MainModule.GenericView.tag",
                            "VirtualDOM.tag": "-1"
                        }
                    }
                }
            ],
            "callables": [
                {
                    "name": "new GenericView",
                    "documentation": {
                        "sections": [
                            {
                                "content": "Creates a new instance.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            },
                            {
                                "title": "Arguments",
                                "content": "\n*  **params**: The parameters.\n*  **layoutsFactory**: The layout factory. Keys correspond to  NavigationCommon.layout.kind \nvalues, binding navigation nodes to their layouts.\n*  **onNotFound**: The ID of the layout to use when  [Router.target$](@nav/api/MainModule.Router.target$)  cannot resolve the\nnavigation path because it does not exist.\n*  **onPending**: The ID of the layout to use when  [Router.target$](@nav/api/MainModule.Router.target$)  cannot resolve the\nnavigation path because navigation is currently resolving.\n*  **router**: The application's router instance.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "arguments",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "GenericView.new GenericView",
                    "code": {
                        "filePath": "src/lib/generic.view.ts",
                        "declaration": "constructor(params: {\n        router: Router<LayoutUnion<LayoutOptionsMap>, THeader>\n        layoutsFactory: LayoutFactory<LayoutOptionsMap, THeader>\n        onNotFound: LayoutKindUnion<LayoutOptionsMap>\n        onPending: LayoutKindUnion<LayoutOptionsMap>\n    })",
                        "implementation": "constructor(params: {\n        router: Router<LayoutUnion<LayoutOptionsMap>, THeader>\n        layoutsFactory: LayoutFactory<LayoutOptionsMap, THeader>\n        onNotFound: LayoutKindUnion<LayoutOptionsMap>\n        onPending: LayoutKindUnion<LayoutOptionsMap>\n    }) {\n        Object.assign(this, params)\n        const layout$ = this.router.target$.pipe(\n            map((target) => {\n                if (isResolvedTarget(target)) {\n                    return target.node.layout.kind\n                }\n                if (target.reason === 'Pending') {\n                    return this.onPending\n                }\n                return this.onNotFound\n            }),\n            distinctUntilChanged(),\n        )\n        this.children = [\n            child$({\n                source$: layout$,\n                vdomMap: (layoutKind) => {\n                    if (layoutKind in this.layoutsFactory) {\n                        type TLayoutOptions =\n                            LayoutOptionsMap[LayoutKindUnion<LayoutOptionsMap>]\n                        return this.layoutsFactory[\n                            layoutKind as LayoutKindUnion<LayoutOptionsMap>\n                        ]({\n                            router: this.router as unknown as Router<\n                                TLayoutOptions,\n                                THeader\n                            >,\n                        })\n                    }\n                    return new LayoutNotFoundView({\n                        unknownKey: layoutKind as string,\n                        availableKeys: Object.keys(this.layoutsFactory),\n                        path: this.router.parseUrl().path,\n                    })\n                },\n            }),\n        ]\n    }",
                        "startLine": 85,
                        "endLine": 129,
                        "references": {
                            "new GenericView": "@nav/api/MainModule.GenericView.constructor",
                            "LayoutFactory": "@nav/api/MainModule.LayoutFactory",
                            "LayoutOptionsMap": "1171",
                            "THeader": "1172",
                            "LayoutKindUnion": "@nav/api/MainModule.LayoutKindUnion",
                            "Router": "@nav/api/MainModule.Router",
                            "LayoutUnion": "@nav/api/MainModule.LayoutUnion",
                            "GenericView": "@nav/api/MainModule.GenericView"
                        }
                    },
                    "semantic": {
                        "role": "constructor",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    }
                }
            ],
            "code": {
                "filePath": "src/lib/generic.view.ts",
                "declaration": "export class GenericView<LayoutOptionsMap, THeader>\n    implements VirtualDOM<'div'>",
                "implementation": "export class GenericView<LayoutOptionsMap, THeader>\n    implements VirtualDOM<'div'>\n{\n    public readonly tag = 'div'\n    public readonly class = 'w-100 h-100'\n    public readonly children: ChildrenLike\n\n    public readonly router: Router<LayoutUnion<LayoutOptionsMap>, THeader>\n    public readonly layoutsFactory: LayoutFactory<LayoutOptionsMap, THeader>\n    public readonly onNotFound: string\n    public readonly onPending: string\n\n    /**\n     * Creates a new instance.\n     *\n     * @param params The parameters.\n     * @param params.router The application's router instance.\n     * @param params.layoutsFactory The layout factory. Keys correspond to {@link NavigationCommon.layout.kind}\n     * values, binding navigation nodes to their layouts.\n     * @param params.onNotFound The ID of the layout to use when {@link Router.target$} cannot resolve the\n     * navigation path because it does not exist.\n     * @param params.onPending The ID of the layout to use when {@link Router.target$} cannot resolve the\n     * navigation path because navigation is currently resolving.\n     */\n    constructor(params: {\n        router: Router<LayoutUnion<LayoutOptionsMap>, THeader>\n        layoutsFactory: LayoutFactory<LayoutOptionsMap, THeader>\n        onNotFound: LayoutKindUnion<LayoutOptionsMap>\n        onPending: LayoutKindUnion<LayoutOptionsMap>\n    }) {\n        Object.assign(this, params)\n        const layout$ = this.router.target$.pipe(\n            map((target) => {\n                if (isResolvedTarget(target)) {\n                    return target.node.layout.kind\n                }\n                if (target.reason === 'Pending') {\n                    return this.onPending\n                }\n                return this.onNotFound\n            }),\n            distinctUntilChanged(),\n        )\n        this.children = [\n            child$({\n                source$: layout$,\n                vdomMap: (layoutKind) => {\n                    if (layoutKind in this.layoutsFactory) {\n                        type TLayoutOptions =\n                            LayoutOptionsMap[LayoutKindUnion<LayoutOptionsMap>]\n                        return this.layoutsFactory[\n                            layoutKind as LayoutKindUnion<LayoutOptionsMap>\n                        ]({\n                            router: this.router as unknown as Router<\n                                TLayoutOptions,\n                                THeader\n                            >,\n                        })\n                    }\n                    return new LayoutNotFoundView({\n                        unknownKey: layoutKind as string,\n                        availableKeys: Object.keys(this.layoutsFactory),\n                        path: this.router.parseUrl().path,\n                    })\n                },\n            }),\n        ]\n    }\n}",
                "startLine": 61,
                "endLine": 130,
                "references": {
                    "GenericView": "@nav/api/MainModule.GenericView",
                    "LayoutFactory": "@nav/api/MainModule.LayoutFactory",
                    "LayoutOptionsMap": "1171",
                    "THeader": "1172",
                    "LayoutKindUnion": "@nav/api/MainModule.LayoutKindUnion",
                    "Router": "@nav/api/MainModule.Router",
                    "LayoutUnion": "@nav/api/MainModule.LayoutUnion",
                    "VirtualDOM.children": "-1",
                    "VirtualDOM.class": "-1",
                    "VirtualDOM.tag": "-1"
                }
            },
            "semantic": {
                "role": "class",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "GlobalMarkdownViews",
            "documentation": {
                "sections": [
                    {
                        "content": "Provides a collection of global Markdown views that can be referenced when using  [parseMd](undefined) .\n\nCustom views are defined as functions with the following structure:\n- **Arguments**:\n  -  `elem` : The HTML element as declared in the Markdown file. You can access its raw text content using\n     `elem.textContent`  and its attributes using  `elem.getAttribute` .\n  -  `options` : An instance of  [MdParsingOptions](@nav/api/MainModule.MdParsingOptions) , providing additional context for parsing.\n- **Returns**: A  [ViewGenerator](@nav/api/MainModule.ViewGenerator)  that implements the corresponding behavior for the HTML element.\n\nThese views enable dynamic, reusable components to be seamlessly integrated into Markdown content.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "GlobalMarkdownViews",
            "attributes": [
                {
                    "name": "factory",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "A static factory object containing pre-defined Markdown inline views.\n\nSee  [MdWidgets](@nav/api/MainModule/MdWidgets)  regarding implementations.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "GlobalMarkdownViews.factory",
                    "code": {
                        "filePath": "src/lib/markdown.ts",
                        "declaration": "static factory: Record<string, ViewGenerator> = {\n        /**\n         * Transforms a `<code-snippet></code-snippet>` element into {@link CodeSnippetView}.\n         */\n        'code-snippet': (elem: HTMLElement) =>\n            CodeSnippetView.fromHTMLElement(elem),\n        /**\n         * Transforms a `<note></note>`  element into {@link NoteView}.\n         */\n        note: (...args) => NoteView.fromHTMLElement(...args),\n        /**\n         * Transforms a `<code-badges></code-badges>`  element into {@link CodeBadgesView}.\n         */\n        'code-badges': (elem: HTMLElement) =>\n            CodeBadgesView.fromHTMLElement(elem),\n    }",
                        "implementation": "",
                        "startLine": 98,
                        "endLine": 99,
                        "references": {
                            "factory": "@nav/api/MainModule.GlobalMarkdownViews.factory",
                            "ViewGenerator": "@nav/api/MainModule.ViewGenerator"
                        }
                    }
                }
            ],
            "callables": [],
            "code": {
                "filePath": "src/lib/markdown.ts",
                "declaration": "export class GlobalMarkdownViews",
                "implementation": "export class GlobalMarkdownViews {\n    /**\n     * A static factory object containing pre-defined Markdown inline views.\n     *\n     * See {@link MdWidgets} regarding implementations.\n     */\n    static factory: Record<string, ViewGenerator> = {\n        /**\n         * Transforms a `<code-snippet></code-snippet>` element into {@link CodeSnippetView}.\n         */\n        'code-snippet': (elem: HTMLElement) =>\n            CodeSnippetView.fromHTMLElement(elem),\n        /**\n         * Transforms a `<note></note>`  element into {@link NoteView}.\n         */\n        note: (...args) => NoteView.fromHTMLElement(...args),\n        /**\n         * Transforms a `<code-badges></code-badges>`  element into {@link CodeBadgesView}.\n         */\n        'code-badges': (elem: HTMLElement) =>\n            CodeBadgesView.fromHTMLElement(elem),\n    }\n}",
                "startLine": 92,
                "endLine": 115,
                "references": {
                    "GlobalMarkdownViews": "@nav/api/MainModule.GlobalMarkdownViews",
                    "ViewGenerator": "@nav/api/MainModule.ViewGenerator"
                }
            },
            "semantic": {
                "role": "class",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "LayoutNotFoundView",
            "documentation": {
                "sections": [
                    {
                        "content": "The view displayed when a layout referenced in  [Navigation](@nav/api/MainModule.Navigation)  is not found.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "LayoutNotFoundView",
            "attributes": [
                {
                    "name": "children",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "Children of the element.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "LayoutNotFoundView.children",
                    "code": {
                        "filePath": "src/lib/generic.view.ts",
                        "declaration": "public readonly children: ChildrenLike",
                        "implementation": "",
                        "startLine": 136,
                        "endLine": 137,
                        "references": {
                            "children": "@nav/api/MainModule.LayoutNotFoundView.children",
                            "VirtualDOM.children": "-1"
                        }
                    }
                },
                {
                    "name": "class",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "The class associated with the element, equivalent to the  `className`  property of  `HTMLElement` .",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "LayoutNotFoundView.class",
                    "code": {
                        "filePath": "src/lib/generic.view.ts",
                        "declaration": "public readonly class = 'mkdocs-LayoutNotFoundView'",
                        "implementation": "",
                        "startLine": 137,
                        "endLine": 138,
                        "references": {
                            "class": "@nav/api/MainModule.LayoutNotFoundView.class",
                            "VirtualDOM.class": "-1"
                        }
                    }
                },
                {
                    "name": "tag",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "The tag of the element, equivalent to the  `tagName`  property of  `HTMLElement` .",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "LayoutNotFoundView.tag",
                    "code": {
                        "filePath": "src/lib/generic.view.ts",
                        "declaration": "public readonly tag = 'div'",
                        "implementation": "",
                        "startLine": 135,
                        "endLine": 136,
                        "references": {
                            "tag": "@nav/api/MainModule.LayoutNotFoundView.tag",
                            "VirtualDOM.tag": "-1"
                        }
                    }
                }
            ],
            "callables": [],
            "code": {
                "filePath": "src/lib/generic.view.ts",
                "declaration": "export class LayoutNotFoundView implements VirtualDOM<'div'>",
                "implementation": "export class LayoutNotFoundView implements VirtualDOM<'div'> {\n    public readonly tag = 'div'\n    public readonly children: ChildrenLike\n    public readonly class = 'mkdocs-LayoutNotFoundView'\n\n    constructor({\n        unknownKey,\n        availableKeys,\n        path,\n    }: {\n        unknownKey: string\n        availableKeys: string[]\n        path: string\n    }) {\n        const availableKeysStr = availableKeys.reduce(\n            (acc, key) => `${acc}\\n*  **${key}**`,\n            '',\n        )\n        this.children = [\n            parseMd({\n                src: `\n<note level=\"warning\" title=\"Unknown Layout\">\nThe provided layout key - **${unknownKey}** - for node \\`${path}\\` is not part of the registered ones:\n${availableKeysStr}\n</note>                \n                `,\n            }),\n        ]\n    }\n}",
                "startLine": 134,
                "endLine": 164,
                "references": {
                    "LayoutNotFoundView": "@nav/api/MainModule.LayoutNotFoundView",
                    "VirtualDOM.children": "-1",
                    "VirtualDOM.class": "-1",
                    "VirtualDOM.tag": "-1"
                }
            },
            "semantic": {
                "role": "class",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "MockBrowser",
            "documentation": {
                "sections": [
                    {
                        "content": "Implements the  [BrowserInterface](@nav/api/MainModule.BrowserInterface)  for managing browser navigation within a mocked browser.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "MockBrowser",
            "attributes": [],
            "callables": [
                {
                    "name": "parseUrl",
                    "documentation": {
                        "sections": [
                            {
                                "content": "Retrieves the target from the current URL.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            },
                            {
                                "title": "Returns",
                                "content": "The current navigation path as a string.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "returns",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "MockBrowser.parseUrl",
                    "code": {
                        "filePath": "src/lib/browser.interface.ts",
                        "declaration": "parseUrl(): UrlTarget",
                        "implementation": "parseUrl(): UrlTarget {\n        return this.history.length > 0\n            ? this.history.slice(-1)[0]\n            : parseUrl('/')\n    }",
                        "startLine": 136,
                        "endLine": 141,
                        "references": {
                            "parseUrl": "@nav/api/MainModule.MockBrowser.parseUrl",
                            "UrlTarget": "@nav/api/MainModule.UrlTarget"
                        }
                    },
                    "semantic": {
                        "role": "method",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    }
                },
                {
                    "name": "pushState",
                    "documentation": {
                        "sections": [
                            {
                                "content": "Pushes a new state to the browser's history stack.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            },
                            {
                                "title": "Arguments",
                                "content": "\n*  **data**: The state data to associate with the history entry, including the navigation path.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "arguments",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "MockBrowser.pushState",
                    "code": {
                        "filePath": "src/lib/browser.interface.ts",
                        "declaration": "pushState(data: { target: UrlTarget }): void",
                        "implementation": "pushState(data: { target: UrlTarget }): void {\n        this.history.push(data.target)\n    }",
                        "startLine": 132,
                        "endLine": 135,
                        "references": {
                            "pushState": "@nav/api/MainModule.MockBrowser.pushState",
                            "UrlTarget": "@nav/api/MainModule.UrlTarget"
                        }
                    },
                    "semantic": {
                        "role": "method",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    }
                }
            ],
            "code": {
                "filePath": "src/lib/browser.interface.ts",
                "declaration": "export class MockBrowser implements BrowserInterface",
                "implementation": "export class MockBrowser implements BrowserInterface {\n    public readonly router: Router\n    public readonly basePath: string\n    public readonly history: UrlTarget[] = []\n    constructor(params: { router: Router; basePath: string }) {\n        Object.assign(this, params)\n    }\n    pushState(data: { target: UrlTarget }): void {\n        this.history.push(data.target)\n    }\n\n    parseUrl(): UrlTarget {\n        return this.history.length > 0\n            ? this.history.slice(-1)[0]\n            : parseUrl('/')\n    }\n}",
                "startLine": 125,
                "endLine": 142,
                "references": {
                    "MockBrowser": "@nav/api/MainModule.MockBrowser",
                    "Router": "@nav/api/MainModule.Router",
                    "UrlTarget": "@nav/api/MainModule.UrlTarget",
                    "BrowserInterface.parseUrl": "@nav/api/MainModule.BrowserInterface.parseUrl",
                    "BrowserInterface.pushState": "@nav/api/MainModule.BrowserInterface.pushState",
                    "BrowserInterface": "@nav/api/MainModule.BrowserInterface"
                }
            },
            "semantic": {
                "role": "class",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "Router",
            "documentation": {
                "sections": [
                    {
                        "content": "Represents the router of the application.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "Router",
            "attributes": [
                {
                    "name": "basePath",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "The base path on which the router is defined.\n\nIf the application is served from  `https://my-domain/my-app/version`  it is  `/my-app/version` .",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "Router.basePath",
                    "code": {
                        "filePath": "src/lib/router.ts",
                        "declaration": "public readonly basePath: string",
                        "implementation": "",
                        "startLine": 117,
                        "endLine": 118,
                        "references": {
                            "basePath": "@nav/api/MainModule.Router.basePath"
                        }
                    }
                },
                {
                    "name": "browserClient",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "Browser client, see  [WebBrowser](@nav/api/MainModule.WebBrowser)  for regular scenario (library running within a tab of a web browser).",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "Router.browserClient",
                    "code": {
                        "filePath": "src/lib/router.ts",
                        "declaration": "public readonly browserClient: BrowserInterface",
                        "implementation": "",
                        "startLine": 178,
                        "endLine": 179,
                        "references": {
                            "browserClient": "@nav/api/MainModule.Router.browserClient",
                            "BrowserInterface": "@nav/api/MainModule.BrowserInterface"
                        }
                    }
                },
                {
                    "name": "explorerState",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "Encapsulates the state of the navigation view (node selected, expanded, *etc.*)",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "Router.explorerState",
                    "code": {
                        "filePath": "src/lib/router.ts",
                        "declaration": "public readonly explorerState: ImmutableTree.State<\n        AnyNavNode<TLayout, THeader>\n    >",
                        "implementation": "",
                        "startLine": 159,
                        "endLine": 160,
                        "references": {
                            "explorerState": "@nav/api/MainModule.Router.explorerState",
                            "AnyNavNode": "@nav/api/MainModule.AnyNavNode",
                            "TLayout": "1223",
                            "THeader": "1224"
                        }
                    }
                },
                {
                    "name": "navigation",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "Definition of the navigation.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "Router.navigation",
                    "code": {
                        "filePath": "src/lib/router.ts",
                        "declaration": "public readonly navigation: Navigation<TLayout, THeader>",
                        "implementation": "",
                        "startLine": 129,
                        "endLine": 130,
                        "references": {
                            "navigation": "@nav/api/MainModule.Router.navigation",
                            "Navigation": "@nav/api/MainModule.Navigation",
                            "TLayout": "1223",
                            "THeader": "1224"
                        }
                    }
                },
                {
                    "name": "path$",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "Observable that emit the current navigation path.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "Router.path$",
                    "code": {
                        "filePath": "src/lib/router.ts",
                        "declaration": "public readonly path$: Subject<string> = new ReplaySubject<string>(1)",
                        "implementation": "",
                        "startLine": 154,
                        "endLine": 155,
                        "references": {
                            "path$": "@nav/api/MainModule.Router.path$"
                        }
                    }
                },
                {
                    "name": "redirects",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "Handles navigation redirections.\n\nThis function is invoked whenever a specific path is requested for navigation.\nIt allows modifying the target path before the navigation occurs.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "Router.redirects",
                    "code": {
                        "filePath": "src/lib/router.ts",
                        "declaration": "public readonly redirects: (target: string) => Promise<string | undefined> =\n        (target) => Promise.resolve(target)",
                        "implementation": "",
                        "startLine": 141,
                        "endLine": 142,
                        "references": {
                            "redirects": "@nav/api/MainModule.Router.redirects"
                        }
                    }
                },
                {
                    "name": "retryNavPeriod",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "When using a dynamic definition of the routes (see  [Navigation](@nav/api/MainModule.Navigation) ),\nit may be the case that the routes are not yet available when navigating to a page.\nAttempt to re-navigate to the page is executed every  `retryNavPeriod`  second.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "Router.retryNavPeriod",
                    "code": {
                        "filePath": "src/lib/router.ts",
                        "declaration": "public readonly retryNavPeriod: number = 1000",
                        "implementation": "",
                        "startLine": 124,
                        "endLine": 125,
                        "references": {
                            "retryNavPeriod": "@nav/api/MainModule.Router.retryNavPeriod"
                        }
                    }
                },
                {
                    "name": "target$",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "Observable that emit the current page target.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "Router.target$",
                    "code": {
                        "filePath": "src/lib/router.ts",
                        "declaration": "public readonly target$: Subject<\n        Target<TLayout, THeader> | UnresolvedTarget\n    > = new ReplaySubject<Target<TLayout, THeader> | UnresolvedTarget>(1)",
                        "implementation": "",
                        "startLine": 147,
                        "endLine": 148,
                        "references": {
                            "target$": "@nav/api/MainModule.Router.target$",
                            "UnresolvedTarget": "@nav/api/MainModule.UnresolvedTarget",
                            "Target": "@nav/api/MainModule.Target",
                            "TLayout": "1223",
                            "THeader": "1224"
                        }
                    }
                }
            ],
            "callables": [
                {
                    "name": "new Router",
                    "documentation": {
                        "sections": [
                            {
                                "content": "Initialize a router instance.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            },
                            {
                                "title": "Arguments",
                                "content": "\n*  **params**: See corresponding documentation in the class's attributes.\n*  **basePath**: Deprecated should not be used.\n*  **browserClient**: See  [BrowserInterface](@nav/api/MainModule.BrowserInterface) .\n*  **navigation**: See  [Router.navigation](@nav/api/MainModule.Router.navigation) .\n*  **redirects**: See  [Router.redirects](@nav/api/MainModule.Router.redirects) .\n*  **retryNavPeriod**: See  [Router.retryNavPeriod](@nav/api/MainModule.Router.retryNavPeriod) .",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "arguments",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "Router.new Router",
                    "code": {
                        "filePath": "src/lib/router.ts",
                        "declaration": "constructor(params: {\n        navigation: Navigation<TLayout, THeader>\n        basePath?: string\n        retryNavPeriod?: number\n        redirects?: (target: string) => Promise<string | undefined>\n        browserClient?: (p: {\n            router: Router\n            basePath: string\n        }) => BrowserInterface\n    })",
                        "implementation": "constructor(params: {\n        navigation: Navigation<TLayout, THeader>\n        basePath?: string\n        retryNavPeriod?: number\n        redirects?: (target: string) => Promise<string | undefined>\n        browserClient?: (p: {\n            router: Router\n            basePath: string\n        }) => BrowserInterface\n    }) {\n        Object.assign(this, params)\n        this.basePath = this.basePath || document.location.pathname\n        this.browserClient = params.browserClient\n            ? params.browserClient({ router: this, basePath: this.basePath })\n            : new WebBrowser({ router: this, basePath: this.basePath })\n\n        const { rootNode, reactiveNavs, promiseNavs } = createRootNode({\n            navigation: this.navigation,\n            router: this,\n        })\n        this.explorerState = new ImmutableTree.State({\n            rootNode,\n            expandedNodes: ['/'],\n        })\n        this.bindReactiveNavs(reactiveNavs)\n        this.bindPromiseNavs(promiseNavs)\n\n        this.target$\n            .pipe(\n                filter((page) => {\n                    return isResolvedTarget(page)\n                }),\n            )\n            .subscribe((page) => {\n                if (page.sectionId === undefined) {\n                    this.scrollTo()\n                }\n            })\n        fireAndForget(this.navigateTo(this.parseUrl()))\n    }",
                        "startLine": 190,
                        "endLine": 230,
                        "references": {
                            "new Router": "@nav/api/MainModule.Router.constructor",
                            "Router": "@nav/api/MainModule.Router",
                            "BrowserInterface": "@nav/api/MainModule.BrowserInterface",
                            "Navigation": "@nav/api/MainModule.Navigation",
                            "TLayout": "1223",
                            "THeader": "1224"
                        }
                    },
                    "semantic": {
                        "role": "constructor",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    }
                },
                {
                    "name": "emitHtmlUpdated",
                    "documentation": {
                        "sections": [
                            {
                                "content": "Clients need to invoke this function when dynamic change on the current main HTML page have occurred after the\ninitial rendering. Other views dependening on it (*e.g.* the table of content) will refresh as well.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "Router.emitHtmlUpdated",
                    "code": {
                        "filePath": "src/lib/router.ts",
                        "declaration": "emitHtmlUpdated()",
                        "implementation": "emitHtmlUpdated() {\n        this.htmlUpdated$.next(true)\n    }",
                        "startLine": 489,
                        "endLine": 492,
                        "references": {
                            "emitHtmlUpdated": "@nav/api/MainModule.Router.emitHtmlUpdated"
                        }
                    },
                    "semantic": {
                        "role": "method",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    }
                },
                {
                    "name": "fireNavigateTo",
                    "documentation": {
                        "sections": [
                            {
                                "content": "Fire navigation to given path with no  `await` .",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            },
                            {
                                "title": "Arguments",
                                "content": "\n*  **target**: The path to navigate to.\nIf a string is provided, a  [UrlTarget](@nav/api/MainModule.UrlTarget)  is constructed using  [parseUrl](@nav/api/MainModule.parseUrl) .\n*  **onError**: Callback called if errors happen.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "arguments",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "Router.fireNavigateTo",
                    "code": {
                        "filePath": "src/lib/router.ts",
                        "declaration": "fireNavigateTo(\n        target: UrlTarget | string,\n        onError?: (err: unknown) => void,\n    )",
                        "implementation": "fireNavigateTo(\n        target: UrlTarget | string,\n        onError?: (err: unknown) => void,\n    ) {\n        fireAndForget(this.navigateTo(target), onError)\n    }",
                        "startLine": 245,
                        "endLine": 251,
                        "references": {
                            "fireNavigateTo": "@nav/api/MainModule.Router.fireNavigateTo",
                            "UrlTarget": "@nav/api/MainModule.UrlTarget"
                        }
                    },
                    "semantic": {
                        "role": "method",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    }
                },
                {
                    "name": "getNav",
                    "documentation": {
                        "sections": [
                            {
                                "content": "Retrieves the navigation node corresponding to a given path, or  `undefined`  if it does not exist.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            },
                            {
                                "title": "Arguments",
                                "content": "\n*  **path**: The target path.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "arguments",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "Router.getNav",
                    "code": {
                        "filePath": "src/lib/router.ts",
                        "declaration": "public getNav({\n        path,\n    }: {\n        path: string\n    }): Observable<Navigation<TLayout, THeader>> | 'not-found' | 'unresolved'",
                        "implementation": "public getNav({\n        path,\n    }: {\n        path: string\n    }): Observable<Navigation<TLayout, THeader>> | 'not-found' | 'unresolved' {\n        const parts = path\n            .split('/')\n            .slice(1)\n            .filter((d) => d !== '')\n\n        if (parts.length === 0) {\n            return of(this.navigation)\n        }\n        const node = parts.reduce(\n            ({ tree, resolvedPath, keepGoing }, part) => {\n                if (!keepGoing) {\n                    return { tree, resolvedPath, keepGoing }\n                }\n                if (tree.routes === undefined) {\n                    return 'not-found'\n                }\n                const routes = tree.routes\n                if (\n                    typeof routes === 'function' ||\n                    routes instanceof Observable\n                ) {\n                    // the navigation is a catch-all routes\n                    return {\n                        tree:\n                            resolvedPath in this.navUpdates\n                                ? this.navUpdates[resolvedPath]\n                                : routes,\n                        resolvedPath,\n                        keepGoing: false,\n                    }\n                }\n\n                if (`/${part}` in routes) {\n                    const route = routes[`/${part}`]\n\n                    if (!(route instanceof Promise)) {\n                        return {\n                            tree: route,\n                            resolvedPath: sanitizeNavPath(\n                                `${resolvedPath}/${part}`,\n                            ),\n                            keepGoing: true,\n                        }\n                    }\n\n                    const fullPath = sanitizeNavPath(`${resolvedPath}/${part}`)\n                    if (fullPath in this.navResolved) {\n                        return {\n                            tree: this.navResolved[fullPath],\n                            resolvedPath: sanitizeNavPath(\n                                `${resolvedPath}/${part}`,\n                            ),\n                            keepGoing: true,\n                        }\n                    }\n                    // a retry in some period of time will be executed\n                    return {\n                        tree: route,\n                        resolvedPath,\n                        keepGoing: false,\n                    }\n                }\n                return 'not-found'\n            },\n            { tree: this.navigation, resolvedPath: `/`, keepGoing: true },\n        )\n        if (node === 'not-found') {\n            return 'not-found'\n        }\n        // node.tree: Navigation |  Promise<Navigation> | LazyRoutesCb | LazyRoutesCb$\n        if (node.tree instanceof Observable || node.tree instanceof Promise) {\n            // case: Promise<Navigation> or LazyRoutesCb$ -> a retry in some period of time will be executed\n            return 'unresolved'\n        }\n        if (typeof node.tree === 'function') {\n            // case: LazyRoutesCb, remove starting '/'\n            const relative =\n                node.resolvedPath === '/'\n                    ? path\n                    : sanitizeNavPath(path.split(node.resolvedPath)[1])\n            const parent = sanitizeNavPath(\n                relative.split('/').slice(0, -1).join('/'),\n            )\n            const parentNav = node.tree({ path: parent, router: this })\n            if (!parentNav) {\n                return 'not-found'\n            }\n            return resolve(parentNav).pipe(\n                mergeMap((resolved) => {\n                    const target = sanitizeNavPath(\n                        relative.split('/').slice(-1)[0],\n                    )\n                    return resolve(resolved[target])\n                }),\n            )\n        }\n        // node.tree: Navigation\n        return of(node.tree)\n    }",
                        "startLine": 369,
                        "endLine": 473,
                        "references": {
                            "getNav": "@nav/api/MainModule.Router.getNav",
                            "Navigation": "@nav/api/MainModule.Navigation",
                            "TLayout": "1223",
                            "THeader": "1224"
                        }
                    },
                    "semantic": {
                        "role": "method",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    }
                },
                {
                    "name": "navigateTo",
                    "documentation": {
                        "sections": [
                            {
                                "content": "Navigate to a specific target.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            },
                            {
                                "title": "Arguments",
                                "content": "\n*  **target**: The URL target.\nIf a string is provided, a  [UrlTarget](@nav/api/MainModule.UrlTarget)  is constructed using  [parseUrl](@nav/api/MainModule.parseUrl) .",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "arguments",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "Router.navigateTo",
                    "code": {
                        "filePath": "src/lib/router.ts",
                        "declaration": "async navigateTo(target: UrlTarget | string)",
                        "implementation": "async navigateTo(target: UrlTarget | string) {\n        target = typeof target === 'string' ? parseUrl(target) : target\n\n        const path = await this.redirects(sanitizeNavPath(target.path))\n        if (!path) {\n            return\n        }\n        const sectionId = target.sectionId\n\n        const nav = timer(0, this.retryNavPeriod).pipe(\n            switchMap(() => {\n                const nav = this.getNav({ path })\n                if (nav instanceof Observable) {\n                    return nav\n                }\n                return of(nav)\n            }),\n            tap((nav) => {\n                if (nav === 'unresolved') {\n                    console.log('Try to wait...')\n                    this.target$.next({\n                        path,\n                        reason: 'Pending',\n                    })\n                }\n            }),\n            filter((nav) => nav !== 'unresolved'),\n            take(1),\n        )\n        const resolved = await firstValueFrom(nav)\n        if (resolved === 'not-found') {\n            this.target$.next({\n                path,\n                reason: 'NotFound',\n            })\n            return\n        }\n        this.browserClient.pushState({ target })\n        this.path$.next(path)\n\n        this.target$.next({\n            node: resolved,\n            path,\n            sectionId: sectionId === '' ? undefined : sectionId,\n        })\n        await this.expandNavigationTree(path)\n    }",
                        "startLine": 258,
                        "endLine": 305,
                        "references": {
                            "navigateTo": "@nav/api/MainModule.Router.navigateTo",
                            "UrlTarget": "@nav/api/MainModule.UrlTarget"
                        }
                    },
                    "semantic": {
                        "role": "method",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    }
                },
                {
                    "name": "parseUrl",
                    "documentation": {
                        "sections": [
                            {
                                "content": "Returns the current navigation path.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "Router.parseUrl",
                    "code": {
                        "filePath": "src/lib/router.ts",
                        "declaration": "parseUrl(): UrlTarget",
                        "implementation": "parseUrl(): UrlTarget {\n        return this.browserClient.parseUrl()\n    }",
                        "startLine": 234,
                        "endLine": 237,
                        "references": {
                            "parseUrl": "@nav/api/MainModule.Router.parseUrl",
                            "UrlTarget": "@nav/api/MainModule.UrlTarget"
                        }
                    },
                    "semantic": {
                        "role": "method",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    }
                },
                {
                    "name": "scrollTo",
                    "documentation": {
                        "sections": [
                            {
                                "content": "Scroll the main HTML content to focus on an HTML element.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            },
                            {
                                "title": "Arguments",
                                "content": "\n*  **target**: The target HTML element, or its id.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "arguments",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "Router.scrollTo",
                    "code": {
                        "filePath": "src/lib/router.ts",
                        "declaration": "scrollTo(target?: string | HTMLElement)",
                        "implementation": "scrollTo(target?: string | HTMLElement) {\n        if (\n            !this.scrollableElement ||\n            !('scrollTo' in this.scrollableElement)\n        ) {\n            return\n        }\n        const scrollableElement = this.scrollableElement\n        if (!target) {\n            scrollableElement.scrollTo({\n                top: 0,\n                left: 0,\n            })\n            return\n        }\n        const br = scrollableElement.getBoundingClientRect()\n        const div =\n            target instanceof HTMLElement\n                ? target\n                : findElementById(scrollableElement, target)\n\n        if (!div) {\n            console.warn(`Can not scroll to element`, target)\n            return\n        }\n        this.browserClient.pushState({\n            target: { ...this.parseUrl(), sectionId: div.id },\n        })\n        setTimeout(() => {\n            scrollableElement.scrollTo({\n                top: div.offsetTop - br.top - 1,\n                left: 0,\n                behavior: 'smooth',\n            })\n        }, 0)\n    }",
                        "startLine": 327,
                        "endLine": 363,
                        "references": {
                            "scrollTo": "@nav/api/MainModule.Router.scrollTo"
                        }
                    },
                    "semantic": {
                        "role": "method",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    }
                },
                {
                    "name": "setScrollableElement",
                    "documentation": {
                        "sections": [
                            {
                                "content": "Set the element in page that can be 'scrolled' to reach target destination's section ID (reference from URL).",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            },
                            {
                                "title": "Arguments",
                                "content": "\n*  **element**: Scrollable element.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "arguments",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "Router.setScrollableElement",
                    "code": {
                        "filePath": "src/lib/router.ts",
                        "declaration": "setScrollableElement(element: HTMLElement)",
                        "implementation": "setScrollableElement(element: HTMLElement) {\n        this.scrollableElement = element\n        this.target$\n            .pipe(\n                take(1),\n                filter((target) => 'node' in target),\n            )\n            .subscribe((target) => {\n                this.scrollTo(target.sectionId)\n            })\n    }",
                        "startLine": 311,
                        "endLine": 322,
                        "references": {
                            "setScrollableElement": "@nav/api/MainModule.Router.setScrollableElement"
                        }
                    },
                    "semantic": {
                        "role": "method",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    }
                }
            ],
            "code": {
                "filePath": "src/lib/router.ts",
                "declaration": "export class Router<TLayout = unknown, THeader = unknown>",
                "implementation": "export class Router<TLayout = unknown, THeader = unknown> {\n    /**\n     * The base path on which the router is defined.\n     *\n     * If the application is served from `https://my-domain/my-app/version` it is `/my-app/version`.\n     */\n    public readonly basePath: string\n\n    /**\n     * When using a dynamic definition of the routes (see {@link Navigation}),\n     * it may be the case that the routes are not yet available when navigating to a page.\n     * Attempt to re-navigate to the page is executed every `retryNavPeriod` second.\n     */\n    public readonly retryNavPeriod: number = 1000\n\n    /**\n     * Definition of the navigation.\n     */\n    public readonly navigation: Navigation<TLayout, THeader>\n\n    /**\n     * Handles navigation redirections.\n     *\n     * This function is invoked whenever a specific path is requested for navigation.\n     * It allows modifying the target path before the navigation occurs.\n     *\n     * @param target - The requested path that the user intends to navigate to.\n     * @returns The modified path to navigate to, or the original path if no changes are needed.\n     *          If `undefined` is returned, the navigation will be canceled.\n     */\n    public readonly redirects: (target: string) => Promise<string | undefined> =\n        (target) => Promise.resolve(target)\n\n    /**\n     * Observable that emit the current page target.\n     */\n    public readonly target$: Subject<\n        Target<TLayout, THeader> | UnresolvedTarget\n    > = new ReplaySubject<Target<TLayout, THeader> | UnresolvedTarget>(1)\n\n    /**\n     * Observable that emit the current navigation path.\n     */\n    public readonly path$: Subject<string> = new ReplaySubject<string>(1)\n\n    /**\n     * Encapsulates the state of the navigation view (node selected, expanded, *etc.*)\n     */\n    public readonly explorerState: ImmutableTree.State<\n        AnyNavNode<TLayout, THeader>\n    >\n\n    public scrollableElement: HTMLElement | undefined\n\n    public readonly htmlUpdated$ = new Subject<unknown>()\n\n    public readonly status: Record<\n        'Warning' | 'Error',\n        Record<string, unknown[]>\n    > = { Warning: {}, Error: {} }\n\n    private navUpdates: Record<string, LazyRoutesCb<TLayout, THeader>> = {}\n    private navResolved: Record<string, Navigation<TLayout, THeader>> = {}\n\n    /**\n     * Browser client, see {@link WebBrowser} for regular scenario (library running within a tab of a web browser).\n     */\n    public readonly browserClient: BrowserInterface\n\n    /**\n     * Initialize a router instance.\n     *\n     * @param params See corresponding documentation in the class's attributes.\n     * @param params.navigation See {@link Router.navigation}.\n     * @param params.basePath Deprecated should not be used.\n     * @param params.retryNavPeriod See {@link Router.retryNavPeriod}.\n     * @param params.redirects See {@link Router.redirects}.\n     * @param params.browserClient See {@link BrowserInterface}.\n     */\n    constructor(params: {\n        navigation: Navigation<TLayout, THeader>\n        basePath?: string\n        retryNavPeriod?: number\n        redirects?: (target: string) => Promise<string | undefined>\n        browserClient?: (p: {\n            router: Router\n            basePath: string\n        }) => BrowserInterface\n    }) {\n        Object.assign(this, params)\n        this.basePath = this.basePath || document.location.pathname\n        this.browserClient = params.browserClient\n            ? params.browserClient({ router: this, basePath: this.basePath })\n            : new WebBrowser({ router: this, basePath: this.basePath })\n\n        const { rootNode, reactiveNavs, promiseNavs } = createRootNode({\n            navigation: this.navigation,\n            router: this,\n        })\n        this.explorerState = new ImmutableTree.State({\n            rootNode,\n            expandedNodes: ['/'],\n        })\n        this.bindReactiveNavs(reactiveNavs)\n        this.bindPromiseNavs(promiseNavs)\n\n        this.target$\n            .pipe(\n                filter((page) => {\n                    return isResolvedTarget(page)\n                }),\n            )\n            .subscribe((page) => {\n                if (page.sectionId === undefined) {\n                    this.scrollTo()\n                }\n            })\n        fireAndForget(this.navigateTo(this.parseUrl()))\n    }\n\n    /**\n     * Returns the current navigation path.\n     */\n    parseUrl(): UrlTarget {\n        return this.browserClient.parseUrl()\n    }\n\n    /**\n     * Fire navigation to given path with no `await`.\n     *\n     * @param target  The path to navigate to.\n     * If a string is provided, a {@link UrlTarget} is constructed using {@link parseUrl}.\n     * @param onError Callback called if errors happen.\n     */\n    fireNavigateTo(\n        target: UrlTarget | string,\n        onError?: (err: unknown) => void,\n    ) {\n        fireAndForget(this.navigateTo(target), onError)\n    }\n\n    /**\n     * Navigate to a specific target.\n     *\n     * @param target The URL target.\n     * If a string is provided, a {@link UrlTarget} is constructed using {@link parseUrl}.\n     */\n    async navigateTo(target: UrlTarget | string) {\n        target = typeof target === 'string' ? parseUrl(target) : target\n\n        const path = await this.redirects(sanitizeNavPath(target.path))\n        if (!path) {\n            return\n        }\n        const sectionId = target.sectionId\n\n        const nav = timer(0, this.retryNavPeriod).pipe(\n            switchMap(() => {\n                const nav = this.getNav({ path })\n                if (nav instanceof Observable) {\n                    return nav\n                }\n                return of(nav)\n            }),\n            tap((nav) => {\n                if (nav === 'unresolved') {\n                    console.log('Try to wait...')\n                    this.target$.next({\n                        path,\n                        reason: 'Pending',\n                    })\n                }\n            }),\n            filter((nav) => nav !== 'unresolved'),\n            take(1),\n        )\n        const resolved = await firstValueFrom(nav)\n        if (resolved === 'not-found') {\n            this.target$.next({\n                path,\n                reason: 'NotFound',\n            })\n            return\n        }\n        this.browserClient.pushState({ target })\n        this.path$.next(path)\n\n        this.target$.next({\n            node: resolved,\n            path,\n            sectionId: sectionId === '' ? undefined : sectionId,\n        })\n        await this.expandNavigationTree(path)\n    }\n\n    /**\n     * Set the element in page that can be 'scrolled' to reach target destination's section ID (reference from URL).\n     *\n     * @param element Scrollable element.\n     */\n    setScrollableElement(element: HTMLElement) {\n        this.scrollableElement = element\n        this.target$\n            .pipe(\n                take(1),\n                filter((target) => 'node' in target),\n            )\n            .subscribe((target) => {\n                this.scrollTo(target.sectionId)\n            })\n    }\n    /**\n     * Scroll the main HTML content to focus on an HTML element.\n     *\n     * @param target The target HTML element, or its id.\n     */\n    scrollTo(target?: string | HTMLElement) {\n        if (\n            !this.scrollableElement ||\n            !('scrollTo' in this.scrollableElement)\n        ) {\n            return\n        }\n        const scrollableElement = this.scrollableElement\n        if (!target) {\n            scrollableElement.scrollTo({\n                top: 0,\n                left: 0,\n            })\n            return\n        }\n        const br = scrollableElement.getBoundingClientRect()\n        const div =\n            target instanceof HTMLElement\n                ? target\n                : findElementById(scrollableElement, target)\n\n        if (!div) {\n            console.warn(`Can not scroll to element`, target)\n            return\n        }\n        this.browserClient.pushState({\n            target: { ...this.parseUrl(), sectionId: div.id },\n        })\n        setTimeout(() => {\n            scrollableElement.scrollTo({\n                top: div.offsetTop - br.top - 1,\n                left: 0,\n                behavior: 'smooth',\n            })\n        }, 0)\n    }\n\n    /**\n     * Retrieves the navigation node corresponding to a given path, or `undefined` if it does not exist.\n     *\n     * @param path The target path.\n     */\n    public getNav({\n        path,\n    }: {\n        path: string\n    }): Observable<Navigation<TLayout, THeader>> | 'not-found' | 'unresolved' {\n        const parts = path\n            .split('/')\n            .slice(1)\n            .filter((d) => d !== '')\n\n        if (parts.length === 0) {\n            return of(this.navigation)\n        }\n        const node = parts.reduce(\n            ({ tree, resolvedPath, keepGoing }, part) => {\n                if (!keepGoing) {\n                    return { tree, resolvedPath, keepGoing }\n                }\n                if (tree.routes === undefined) {\n                    return 'not-found'\n                }\n                const routes = tree.routes\n                if (\n                    typeof routes === 'function' ||\n                    routes instanceof Observable\n                ) {\n                    // the navigation is a catch-all routes\n                    return {\n                        tree:\n                            resolvedPath in this.navUpdates\n                                ? this.navUpdates[resolvedPath]\n                                : routes,\n                        resolvedPath,\n                        keepGoing: false,\n                    }\n                }\n\n                if (`/${part}` in routes) {\n                    const route = routes[`/${part}`]\n\n                    if (!(route instanceof Promise)) {\n                        return {\n                            tree: route,\n                            resolvedPath: sanitizeNavPath(\n                                `${resolvedPath}/${part}`,\n                            ),\n                            keepGoing: true,\n                        }\n                    }\n\n                    const fullPath = sanitizeNavPath(`${resolvedPath}/${part}`)\n                    if (fullPath in this.navResolved) {\n                        return {\n                            tree: this.navResolved[fullPath],\n                            resolvedPath: sanitizeNavPath(\n                                `${resolvedPath}/${part}`,\n                            ),\n                            keepGoing: true,\n                        }\n                    }\n                    // a retry in some period of time will be executed\n                    return {\n                        tree: route,\n                        resolvedPath,\n                        keepGoing: false,\n                    }\n                }\n                return 'not-found'\n            },\n            { tree: this.navigation, resolvedPath: `/`, keepGoing: true },\n        )\n        if (node === 'not-found') {\n            return 'not-found'\n        }\n        // node.tree: Navigation |  Promise<Navigation> | LazyRoutesCb | LazyRoutesCb$\n        if (node.tree instanceof Observable || node.tree instanceof Promise) {\n            // case: Promise<Navigation> or LazyRoutesCb$ -> a retry in some period of time will be executed\n            return 'unresolved'\n        }\n        if (typeof node.tree === 'function') {\n            // case: LazyRoutesCb, remove starting '/'\n            const relative =\n                node.resolvedPath === '/'\n                    ? path\n                    : sanitizeNavPath(path.split(node.resolvedPath)[1])\n            const parent = sanitizeNavPath(\n                relative.split('/').slice(0, -1).join('/'),\n            )\n            const parentNav = node.tree({ path: parent, router: this })\n            if (!parentNav) {\n                return 'not-found'\n            }\n            return resolve(parentNav).pipe(\n                mergeMap((resolved) => {\n                    const target = sanitizeNavPath(\n                        relative.split('/').slice(-1)[0],\n                    )\n                    return resolve(resolved[target])\n                }),\n            )\n        }\n        // node.tree: Navigation\n        return of(node.tree)\n    }\n\n    private async expandNavigationTree(path: string) {\n        const ids = pathIds(path)\n        for (const id of ids.slice(0, -1)) {\n            const node = this.explorerState.getNodeResolved(id)\n            this.explorerState.getChildren(node)\n            await firstValueFrom(this.explorerState.getChildren$(node))\n        }\n        const node = this.explorerState.getNodeResolved(ids.slice(-1)[0])\n        this.explorerState.selectNodeAndExpand(node)\n    }\n\n    /**\n     * Clients need to invoke this function when dynamic change on the current main HTML page have occurred after the\n     * initial rendering. Other views dependening on it (*e.g.* the table of content) will refresh as well.\n     */\n    emitHtmlUpdated() {\n        this.htmlUpdated$.next(true)\n    }\n\n    private bindReactiveNavs(\n        reactiveNavs: Record<string, LazyRoutesCb$<TLayout, THeader>>,\n    ) {\n        Object.entries(reactiveNavs).forEach(([href, v]) => {\n            v.subscribe((resolver) => {\n                this.navUpdates[href] = resolver\n                const oldNode = this.explorerState.getNodeResolved(href)\n                const children = createLazyChildren$({\n                    resolver: resolver,\n                    hrefBase: href,\n                    path: '',\n                    withExplicit: [],\n                    router: this,\n                })\n                const newNode = new oldNode.factory({\n                    ...oldNode,\n                    children,\n                }) as AnyNavNode<TLayout, THeader>\n                this.explorerState.replaceNode(oldNode, newNode)\n            })\n        })\n    }\n    private bindPromiseNavs(\n        promiseNavs: Record<string, Promise<Navigation<TLayout, THeader>>>,\n    ) {\n        Object.entries(promiseNavs).forEach(([href, v]) => {\n            v.then(\n                (nav) => {\n                    this.navResolved[href] = nav\n                    const oldNode = this.explorerState.getNodeResolved(href)\n\n                    const { rootNode, reactiveNavs, promiseNavs } =\n                        createRootNode({\n                            navigation: nav,\n                            router: this,\n                            hrefBase: href,\n                        })\n                    this.explorerState.replaceNode(oldNode, rootNode)\n                    this.bindReactiveNavs(reactiveNavs)\n                    this.bindPromiseNavs(promiseNavs)\n                },\n                () => {\n                    throw Error(\n                        `Router.bindPromiseNavs: unable to bind promise navigation on ${href}`,\n                    )\n                },\n            )\n        })\n    }\n}",
                "startLine": 111,
                "endLine": 543,
                "references": {
                    "Router": "@nav/api/MainModule.Router",
                    "BrowserInterface": "@nav/api/MainModule.BrowserInterface",
                    "Navigation": "@nav/api/MainModule.Navigation",
                    "TLayout": "1223",
                    "THeader": "1224",
                    "AnyNavNode": "@nav/api/MainModule.AnyNavNode",
                    "UnresolvedTarget": "@nav/api/MainModule.UnresolvedTarget",
                    "Target": "@nav/api/MainModule.Target",
                    "UrlTarget": "@nav/api/MainModule.UrlTarget"
                }
            },
            "semantic": {
                "role": "class",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "WebBrowser",
            "documentation": {
                "sections": [
                    {
                        "content": "Implements the  [BrowserInterface](@nav/api/MainModule.BrowserInterface)  for managing browser navigation.\nIntegrates with the browser's history API and synchronizes with a  [Router](@nav/api/MainModule.Router) .",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "WebBrowser",
            "attributes": [],
            "callables": [
                {
                    "name": "parseUrl",
                    "documentation": {
                        "sections": [
                            {
                                "content": "Retrieves the target from the current URL.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            },
                            {
                                "title": "Returns",
                                "content": "The current navigation path as a string.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "returns",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "WebBrowser.parseUrl",
                    "code": {
                        "filePath": "src/lib/browser.interface.ts",
                        "declaration": "parseUrl(): UrlTarget",
                        "implementation": "parseUrl(): UrlTarget {\n        return parseUrl(window.location.search)\n    }",
                        "startLine": 73,
                        "endLine": 76,
                        "references": {
                            "parseUrl": "@nav/api/MainModule.WebBrowser.parseUrl",
                            "UrlTarget": "@nav/api/MainModule.UrlTarget"
                        }
                    },
                    "semantic": {
                        "role": "method",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    }
                },
                {
                    "name": "pushState",
                    "documentation": {
                        "sections": [
                            {
                                "content": "Pushes a new state to the browser's history stack.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            },
                            {
                                "title": "Arguments",
                                "content": "\n*  **data**: The state data to associate with the history entry, including the navigation path.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "arguments",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "WebBrowser.pushState",
                    "code": {
                        "filePath": "src/lib/browser.interface.ts",
                        "declaration": "pushState(data: { target: UrlTarget }): void",
                        "implementation": "pushState(data: { target: UrlTarget }): void {\n        const isIgnored = this.ignoredPaths$.value.find((ignored) =>\n            data.target.path.startsWith(ignored),\n        )\n        if (isIgnored) {\n            return\n        }\n        history.pushState(\n            {\n                target: {\n                    path: data.target.path,\n                    sectionId: data.target.sectionId,\n                    parameters: data.target.parameters,\n                },\n            },\n            '',\n            `${this.basePath}?${formatUrl(data.target)}`,\n        )\n    }",
                        "startLine": 53,
                        "endLine": 72,
                        "references": {
                            "pushState": "@nav/api/MainModule.WebBrowser.pushState",
                            "UrlTarget": "@nav/api/MainModule.UrlTarget"
                        }
                    },
                    "semantic": {
                        "role": "method",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    }
                }
            ],
            "code": {
                "filePath": "src/lib/browser.interface.ts",
                "declaration": "export class WebBrowser implements BrowserInterface",
                "implementation": "export class WebBrowser implements BrowserInterface {\n    public readonly router: Router\n    public readonly basePath: string\n    public readonly ignoredPaths$: BehaviorSubject<string[]> =\n        new BehaviorSubject<string[]>([])\n\n    constructor(params: {\n        router: Router\n        basePath: string\n        ignoredPaths$?: BehaviorSubject<string[]>\n    }) {\n        Object.assign(this, params)\n        window.onpopstate = (event: PopStateEvent) => {\n            const state = event.state as unknown as\n                | { target: UrlTarget }\n                | undefined\n            if (state) {\n                this.router.fireNavigateTo(state.target)\n            } else {\n                this.router.fireNavigateTo({\n                    path: '/',\n                })\n            }\n        }\n    }\n    pushState(data: { target: UrlTarget }): void {\n        const isIgnored = this.ignoredPaths$.value.find((ignored) =>\n            data.target.path.startsWith(ignored),\n        )\n        if (isIgnored) {\n            return\n        }\n        history.pushState(\n            {\n                target: {\n                    path: data.target.path,\n                    sectionId: data.target.sectionId,\n                    parameters: data.target.parameters,\n                },\n            },\n            '',\n            `${this.basePath}?${formatUrl(data.target)}`,\n        )\n    }\n\n    parseUrl(): UrlTarget {\n        return parseUrl(window.location.search)\n    }\n}",
                "startLine": 28,
                "endLine": 77,
                "references": {
                    "WebBrowser": "@nav/api/MainModule.WebBrowser",
                    "Router": "@nav/api/MainModule.Router",
                    "UrlTarget": "@nav/api/MainModule.UrlTarget",
                    "BrowserInterface.parseUrl": "@nav/api/MainModule.BrowserInterface.parseUrl",
                    "BrowserInterface.pushState": "@nav/api/MainModule.BrowserInterface.pushState",
                    "BrowserInterface": "@nav/api/MainModule.BrowserInterface"
                }
            },
            "semantic": {
                "role": "class",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "BrowserInterface",
            "documentation": {
                "sections": [
                    {
                        "content": "Defines the interface for interacting with the browser's navigation system.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "BrowserInterface",
            "attributes": [],
            "callables": [
                {
                    "name": "parseUrl",
                    "documentation": {
                        "sections": [
                            {
                                "content": "Retrieves the target from the current URL.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            },
                            {
                                "title": "Returns",
                                "content": "The current navigation path as a string.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "returns",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "BrowserInterface.parseUrl",
                    "code": {
                        "filePath": "src/lib/browser.interface.ts",
                        "declaration": "parseUrl(): UrlTarget",
                        "implementation": "",
                        "startLine": 21,
                        "endLine": 22,
                        "references": {
                            "parseUrl": "@nav/api/MainModule.BrowserInterface.parseUrl",
                            "UrlTarget": "@nav/api/MainModule.UrlTarget"
                        }
                    },
                    "semantic": {
                        "role": "method",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    }
                },
                {
                    "name": "pushState",
                    "documentation": {
                        "sections": [
                            {
                                "content": "Pushes a new state to the browser's history stack.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            },
                            {
                                "title": "Arguments",
                                "content": "\n*  **data**: The state data to associate with the history entry, including the navigation path.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "arguments",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "BrowserInterface.pushState",
                    "code": {
                        "filePath": "src/lib/browser.interface.ts",
                        "declaration": "pushState(data: { target: UrlTarget }): void",
                        "implementation": "",
                        "startLine": 15,
                        "endLine": 16,
                        "references": {
                            "pushState": "@nav/api/MainModule.BrowserInterface.pushState",
                            "UrlTarget": "@nav/api/MainModule.UrlTarget"
                        }
                    },
                    "semantic": {
                        "role": "method",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    }
                }
            ],
            "code": {
                "filePath": "src/lib/browser.interface.ts",
                "declaration": "export interface BrowserInterface",
                "implementation": "export interface BrowserInterface {\n    /**\n     * Pushes a new state to the browser's history stack.\n     *\n     * @param data - The state data to associate with the history entry, including the navigation path.\n     * @param url - The associated URL.\n     */\n    pushState(data: { target: UrlTarget }): void\n    /**\n     * Retrieves the target from the current URL.\n     *\n     * @returns The current navigation path as a string.\n     */\n    parseUrl(): UrlTarget\n}",
                "startLine": 8,
                "endLine": 23,
                "references": {
                    "BrowserInterface": "@nav/api/MainModule.BrowserInterface",
                    "UrlTarget": "@nav/api/MainModule.UrlTarget",
                    "MockBrowser": "@nav/api/MainModule.MockBrowser",
                    "WebBrowser": "@nav/api/MainModule.WebBrowser"
                }
            },
            "semantic": {
                "role": "interface",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "MdParsingOptions",
            "documentation": {
                "sections": [
                    {
                        "content": "Options for parsing Markdown content.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "MdParsingOptions",
            "attributes": [
                {
                    "name": "emitHtmlUpdated",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "If true, call  [Router.emitHtmlUpdated](@nav/api/MainModule.Router.emitHtmlUpdated)  when the markdown is rendered.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "MdParsingOptions.emitHtmlUpdated",
                    "code": {
                        "filePath": "src/lib/markdown.ts",
                        "declaration": "emitHtmlUpdated?: boolean",
                        "implementation": "",
                        "startLine": 77,
                        "endLine": 78,
                        "references": {
                            "emitHtmlUpdated": "@nav/api/MainModule.MdParsingOptions.emitHtmlUpdated"
                        }
                    }
                },
                {
                    "name": "latex",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "Whether to parse Latex equations.\nIf  `true`  the MathJax module needs to be loaded by the consumer before parsing occurs.\n\nUsing the webpm client:\n````js\nimport { install } from '@w3nest/webpm-client'\n\nawait install({\n    modules: ['mathjax#^3.1.4'],\n})\n ```\n\nWithin the markdown page, equation blocks are written between `$$` and inline elements between\n`\\\\(` and `\\\\)`",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "MdParsingOptions.latex",
                    "code": {
                        "filePath": "src/lib/markdown.ts",
                        "declaration": "latex?: boolean",
                        "implementation": "",
                        "startLine": 72,
                        "endLine": 73,
                        "references": {
                            "latex": "@nav/api/MainModule.MdParsingOptions.latex"
                        }
                    }
                },
                {
                    "name": "placeholders",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "Placeholders to account for. A form of preprocessing that replace any occurrences of the keys\nin the source by their corresponding values.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "MdParsingOptions.placeholders",
                    "code": {
                        "filePath": "src/lib/markdown.ts",
                        "declaration": "placeholders?: Record<string, string>",
                        "implementation": "",
                        "startLine": 44,
                        "endLine": 45,
                        "references": {
                            "placeholders": "@nav/api/MainModule.MdParsingOptions.placeholders"
                        }
                    }
                },
                {
                    "name": "preprocessing",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "Preprocessing step. This callback is called to transform the source before parsing is executed.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "MdParsingOptions.preprocessing",
                    "code": {
                        "filePath": "src/lib/markdown.ts",
                        "declaration": "preprocessing?: (text: string) => string",
                        "implementation": "",
                        "startLine": 50,
                        "endLine": 51,
                        "references": {
                            "preprocessing": "@nav/api/MainModule.MdParsingOptions.preprocessing"
                        }
                    }
                },
                {
                    "name": "views",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "Custom views generators corresponding to HTMLElement referenced in the Markdown source.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "MdParsingOptions.views",
                    "code": {
                        "filePath": "src/lib/markdown.ts",
                        "declaration": "views?: Record<string, ViewGenerator>",
                        "implementation": "",
                        "startLine": 54,
                        "endLine": 55,
                        "references": {
                            "views": "@nav/api/MainModule.MdParsingOptions.views",
                            "ViewGenerator": "@nav/api/MainModule.ViewGenerator"
                        }
                    }
                }
            ],
            "callables": [],
            "code": {
                "filePath": "src/lib/markdown.ts",
                "declaration": "export interface MdParsingOptions",
                "implementation": "export interface MdParsingOptions {\n    /**\n     * Placeholders to account for. A form of preprocessing that replace any occurrences of the keys\n     * in the source by their corresponding values.\n     */\n    placeholders?: Record<string, string>\n    /**\n     * Preprocessing step. This callback is called to transform the source before parsing is executed.\n     * @param text original text\n     * @return transformed text\n     */\n    preprocessing?: (text: string) => string\n    /**\n     *  Custom views generators corresponding to HTMLElement referenced in the Markdown source.\n     */\n    views?: Record<string, ViewGenerator>\n\n    /**\n     * Whether to parse Latex equations.\n     * If `true` the MathJax module needs to be loaded by the consumer before parsing occurs.\n     *\n     * Using the webpm client:\n     * ````js\n     * import { install } from '@w3nest/webpm-client'\n     *\n     * await install({\n     *     modules: ['mathjax#^3.1.4'],\n     * })\n     * ```\n     *\n     * Within the markdown page, equation blocks are written between `$$` and inline elements between\n     * `\\\\(` and `\\\\)`\n     */\n    latex?: boolean\n\n    /**\n     * If true, call {@link Router.emitHtmlUpdated} when the markdown is rendered.\n     */\n    emitHtmlUpdated?: boolean\n}",
                "startLine": 39,
                "endLine": 79,
                "references": {
                    "MdParsingOptions": "@nav/api/MainModule.MdParsingOptions",
                    "ViewGenerator": "@nav/api/MainModule.ViewGenerator"
                }
            },
            "semantic": {
                "role": "interface",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "UnresolvedTarget",
            "documentation": {
                "sections": [
                    {
                        "content": "A target destination specification when the path is not resolved, either because it does not exist or because\nit is not resolved yet.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "UnresolvedTarget",
            "attributes": [
                {
                    "name": "path",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "Target destination path.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "UnresolvedTarget.path",
                    "code": {
                        "filePath": "src/lib/router.ts",
                        "declaration": "path: string",
                        "implementation": "",
                        "startLine": 56,
                        "endLine": 57,
                        "references": {
                            "path": "@nav/api/MainModule.UnresolvedTarget.path"
                        }
                    }
                },
                {
                    "name": "reason",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "Reason for the target destination to be unresolved.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "UnresolvedTarget.reason",
                    "code": {
                        "filePath": "src/lib/router.ts",
                        "declaration": "reason: 'Pending' | 'NotFound'",
                        "implementation": "",
                        "startLine": 61,
                        "endLine": 62,
                        "references": {
                            "reason": "@nav/api/MainModule.UnresolvedTarget.reason"
                        }
                    }
                }
            ],
            "callables": [],
            "code": {
                "filePath": "src/lib/router.ts",
                "declaration": "export interface UnresolvedTarget",
                "implementation": "export interface UnresolvedTarget {\n    /**\n     * Target destination path.\n     */\n    path: string\n\n    /**\n     * Reason for the target destination to be unresolved.\n     */\n    reason: 'Pending' | 'NotFound'\n}",
                "startLine": 52,
                "endLine": 63,
                "references": {
                    "UnresolvedTarget": "@nav/api/MainModule.UnresolvedTarget"
                }
            },
            "semantic": {
                "role": "interface",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "UrlTarget",
            "documentation": {
                "sections": [
                    {
                        "content": "Navigation URL model.\n\nSee  [parseUrl](@nav/api/MainModule.parseUrl)  for construction from a  `string` .",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "UrlTarget",
            "attributes": [
                {
                    "name": "parameters",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "Additional URL parameters",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "UrlTarget.parameters",
                    "code": {
                        "filePath": "src/lib/router.ts",
                        "declaration": "parameters?: Record<string, string>",
                        "implementation": "",
                        "startLine": 45,
                        "endLine": 46,
                        "references": {
                            "parameters": "@nav/api/MainModule.UrlTarget.parameters"
                        }
                    }
                },
                {
                    "name": "path",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "Target destination path.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "UrlTarget.path",
                    "code": {
                        "filePath": "src/lib/router.ts",
                        "declaration": "path: string",
                        "implementation": "",
                        "startLine": 37,
                        "endLine": 38,
                        "references": {
                            "path": "@nav/api/MainModule.UrlTarget.path"
                        }
                    }
                },
                {
                    "name": "sectionId",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "Section Id.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "UrlTarget.sectionId",
                    "code": {
                        "filePath": "src/lib/router.ts",
                        "declaration": "sectionId?: string",
                        "implementation": "",
                        "startLine": 41,
                        "endLine": 42,
                        "references": {
                            "sectionId": "@nav/api/MainModule.UrlTarget.sectionId"
                        }
                    }
                }
            ],
            "callables": [],
            "code": {
                "filePath": "src/lib/router.ts",
                "declaration": "export interface UrlTarget",
                "implementation": "export interface UrlTarget {\n    /**\n     * Target destination path.\n     */\n    path: string\n    /**\n     * Section Id.\n     */\n    sectionId?: string\n    /**\n     * Additional URL parameters\n     */\n    parameters?: Record<string, string>\n}",
                "startLine": 33,
                "endLine": 47,
                "references": {
                    "UrlTarget": "@nav/api/MainModule.UrlTarget"
                }
            },
            "semantic": {
                "role": "interface",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "AnyView",
            "documentation": {
                "sections": [
                    {
                        "content": "Represents a view that can be rendered within the application, supporting both VirtualDOM-based components\nfrom <a target=\"_blank\" href=\"/apps/@rx-vdom/doc/latest\">rx-vdom</a> and standard HTML elements.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "AnyView",
            "attributes": [],
            "callables": [],
            "code": {
                "filePath": "src/lib/navigation.node.ts",
                "declaration": "export type AnyView = AnyVirtualDOM | HTMLElement",
                "implementation": "",
                "startLine": 10,
                "endLine": 11,
                "references": {
                    "AnyView": "@nav/api/MainModule.AnyView"
                }
            },
            "semantic": {
                "role": "type-alias",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "DynamicRoutes",
            "documentation": {
                "sections": [
                    {
                        "content": "Defines dynamic routes, evaluated at runtime.\n\nUse  [LazyRoutesCb](@nav/api/MainModule.LazyRoutesCb)  when the evaluation provides a constant routing schema.\nIf the routing schema is expected to change dynamically based on some signal, use  [LazyRoutesCb$](@nav/api/MainModule.LazyRoutesCb$) .",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    },
                    {
                        "title": "Generics",
                        "content": "\n*  **TLayout**: The type representing the layout of the application.\n*  **THeader**: The type representing the header configuration.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "arguments",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "DynamicRoutes",
            "attributes": [],
            "callables": [],
            "code": {
                "filePath": "src/lib/navigation.node.ts",
                "declaration": "export type DynamicRoutes<TLayout, THeader> =\n    | LazyRoutesCb<TLayout, THeader>\n    | LazyRoutesCb$<TLayout, THeader>",
                "implementation": "",
                "startLine": 394,
                "endLine": 395,
                "references": {
                    "DynamicRoutes": "@nav/api/MainModule.DynamicRoutes",
                    "LazyRoutesCb": "@nav/api/MainModule.LazyRoutesCb",
                    "TLayout": "1140",
                    "THeader": "1141",
                    "LazyRoutesCb$": "@nav/api/MainModule.LazyRoutesCb$"
                }
            },
            "semantic": {
                "role": "type-alias",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "LayoutFactory",
            "documentation": {
                "sections": [
                    {
                        "content": "Represents a factory for creating layouts.\n\nThe factory is a mapping of layout kind identifiers to corresponding layout generator functions.\nThese identifiers are referenced in  NavigationCommon.layout.kind .",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "LayoutFactory",
            "attributes": [],
            "callables": [],
            "code": {
                "filePath": "src/lib/generic.view.ts",
                "declaration": "export type LayoutFactory<LayoutOptionsMap, THeader> = {\n    [Property in keyof LayoutOptionsMap]: LayoutGeneratorTrait<\n        LayoutOptionsMap[Property],\n        THeader\n    >\n}",
                "implementation": "",
                "startLine": 34,
                "endLine": 35,
                "references": {
                    "LayoutFactory": "@nav/api/MainModule.LayoutFactory",
                    "LayoutOptionsMap": "1162",
                    "LayoutGeneratorTrait": "@nav/api/MainModule.LayoutGeneratorTrait",
                    "THeader": "1163"
                }
            },
            "semantic": {
                "role": "type-alias",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "LayoutGeneratorTrait",
            "documentation": {
                "sections": [
                    {
                        "content": "Defines a trait for a layout generator function that can be registered in  [GenericView.layoutsFactory](@nav/api/MainModule.GenericView.layoutsFactory) .",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "LayoutGeneratorTrait",
            "attributes": [],
            "callables": [],
            "code": {
                "filePath": "src/lib/generic.view.ts",
                "declaration": "export type LayoutGeneratorTrait<TLayout, THeader> = ({\n    router,\n}: {\n    router: Router<TLayout, THeader>\n}) => AnyVirtualDOM",
                "implementation": "",
                "startLine": 12,
                "endLine": 13,
                "references": {
                    "LayoutGeneratorTrait": "@nav/api/MainModule.LayoutGeneratorTrait",
                    "Router": "@nav/api/MainModule.Router",
                    "TLayout": "1155",
                    "THeader": "1156"
                }
            },
            "semantic": {
                "role": "type-alias",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "LazyRoutes",
            "documentation": {
                "sections": [
                    {
                        "content": "Represents the specification of dynamic routes in the application.\n\nDynamic routes are defined as a mapping where each  `segmentId`  (representing a segment's contribution to the URL)\nis associated with a  [NavNodeData](@nav/api/MainModule.NavNodeData)  object.\n\nIt is used in the specification of  [DynamicRoutes](@nav/api/MainModule.DynamicRoutes) .",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    },
                    {
                        "title": "Generics",
                        "content": "\n*  **TLayout**: The type defining the layout configuration for the navigation.\n*  **THeader**: The type defining the header configuration for the navigation.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "arguments",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "LazyRoutes",
            "attributes": [],
            "callables": [],
            "code": {
                "filePath": "src/lib/navigation.node.ts",
                "declaration": "export type LazyRoutes<TLayout, THeader> = SegmentsRecord<\n    NavNodeData<TLayout, THeader, true>\n>",
                "implementation": "",
                "startLine": 331,
                "endLine": 332,
                "references": {
                    "LazyRoutes": "@nav/api/MainModule.LazyRoutes",
                    "SegmentsRecord": "@nav/api/MainModule.SegmentsRecord",
                    "NavNodeData": "@nav/api/MainModule.NavNodeData",
                    "TLayout": "1122",
                    "THeader": "1123"
                }
            },
            "semantic": {
                "role": "type-alias",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "LazyRoutesCb",
            "documentation": {
                "sections": [
                    {
                        "content": "Represents a lazy navigation resolver, used when the navigation is only known at runtime.\n\nIt is a function that takes the target path and router's instance as parameters, and returns\nthe instance of  [LazyRoutes](@nav/api/MainModule.LazyRoutes)  that explicits node attributes for the given path.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "LazyRoutesCb",
            "attributes": [],
            "callables": [],
            "code": {
                "filePath": "src/lib/navigation.node.ts",
                "declaration": "export type LazyRoutesCb<TLayout, THeader> = (p: {\n    // The targeted path in the navigation\n    path: string\n    // Router instance\n    router: Router\n}) => Resolvable<LazyRoutes<TLayout, THeader>> | undefined",
                "implementation": "",
                "startLine": 341,
                "endLine": 342,
                "references": {
                    "LazyRoutesCb": "@nav/api/MainModule.LazyRoutesCb",
                    "Router": "@nav/api/MainModule.Router",
                    "Resolvable": "@nav/api/MainModule.Resolvable",
                    "LazyRoutes": "@nav/api/MainModule.LazyRoutes",
                    "TLayout": "1131",
                    "THeader": "1132"
                }
            },
            "semantic": {
                "role": "type-alias",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "LazyRoutesCb$",
            "documentation": {
                "sections": [
                    {
                        "content": "Represents a reactive lazy navigation resolver, used when the routing schema is expected to change dynamically\nbased on some signal.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "LazyRoutesCb$",
            "attributes": [],
            "callables": [],
            "code": {
                "filePath": "src/lib/navigation.node.ts",
                "declaration": "export type LazyRoutesCb$<TLayout, THeader> = Observable<\n    LazyRoutesCb<TLayout, THeader>\n>",
                "implementation": "",
                "startLine": 381,
                "endLine": 382,
                "references": {
                    "LazyRoutesCb$": "@nav/api/MainModule.LazyRoutesCb$",
                    "LazyRoutesCb": "@nav/api/MainModule.LazyRoutesCb",
                    "TLayout": "1137",
                    "THeader": "1138"
                }
            },
            "semantic": {
                "role": "type-alias",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "Navigation",
            "documentation": {
                "sections": [
                    {
                        "content": "Represents a node within the navigation hierarchy.\n\nEach navigation node is defined by a set of core properties from  [NavNodeData](@nav/api/MainModule.NavNodeData) , which specify details\nsuch as the node's name, layout, and header configuration. The hierarchical structure of the navigation is\nestablished through the  `routes`  property, which may include either:\n-  [StaticRoutes](@nav/api/MainModule.StaticRoutes) : A predefined, fixed set of child routes.\n-  [DynamicRoutes](@nav/api/MainModule.DynamicRoutes) : Dynamically generated child routes, evaluated at runtime.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    },
                    {
                        "title": "Generics",
                        "content": "\n*  **TLayout**: The type representing the layout of the application.\n*  **THeader**: The type representing the header configuration.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "arguments",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "Navigation",
            "attributes": [],
            "callables": [],
            "code": {
                "filePath": "src/lib/navigation.node.ts",
                "declaration": "export type Navigation<TLayout, THeader> = NavNodeData<TLayout, THeader> & {\n    /**\n     * Children routes of the node.\n     */\n    routes?: StaticRoutes<TLayout, THeader> | DynamicRoutes<TLayout, THeader>\n}",
                "implementation": "",
                "startLine": 409,
                "endLine": 410,
                "references": {
                    "Navigation": "@nav/api/MainModule.Navigation",
                    "NavNodeData": "@nav/api/MainModule.NavNodeData",
                    "TLayout": "1145",
                    "THeader": "1146",
                    "StaticRoutes": "@nav/api/MainModule.StaticRoutes",
                    "DynamicRoutes": "@nav/api/MainModule.DynamicRoutes"
                }
            },
            "semantic": {
                "role": "type-alias",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "NavNodeData",
            "documentation": {
                "sections": [
                    {
                        "content": "Represents the minimal set of properties for defining a node in a  [Navigation](@nav/api/MainModule.Navigation)  object.\n\nIt can conditionally include information about whether the node is a leaf node, depending on the value of the\n `WithLeafInfo`  type parameter (required when specifying  [DynamicRoutes](@nav/api/MainModule.DynamicRoutes) ).",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    },
                    {
                        "title": "Generics",
                        "content": "\n*  **TLayout**: The type defining the layout configuration for the navigation.\n*  **THeader**: The type defining the header configuration for the navigation.\n*  **WithLeafInfo**: A boolean flag determining whether the node includes leaf-specific information.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "arguments",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "NavNodeData",
            "attributes": [],
            "callables": [],
            "code": {
                "filePath": "src/lib/navigation.node.ts",
                "declaration": "export type NavNodeData<\n    TLayout,\n    THeader,\n    WithLeafInfo extends boolean = false,\n> = {\n    /**\n     * The name of the node.\n     */\n    name: string\n    /**\n     * Optional user-defined metadata associated with the node.\n     */\n    metadata?: unknown\n    /**\n     * The header configuration for the node.\n     */\n    header?: THeader | (({ router }: { router: Router }) => THeader)\n    /**\n     * The layout configuration for the node.\n     */\n    layout: TLayout\n} & (WithLeafInfo extends true ? { leaf?: boolean } : Record<never, unknown>)",
                "implementation": "",
                "startLine": 22,
                "endLine": 23,
                "references": {
                    "NavNodeData": "@nav/api/MainModule.NavNodeData",
                    "THeader": "1053",
                    "Router": "@nav/api/MainModule.Router",
                    "TLayout": "1052",
                    "WithLeafInfo": "1054",
                    "NavNodeResolved": "@nav/api/MainModule.NavNodeResolved"
                }
            },
            "semantic": {
                "role": "type-alias",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "PathSegment",
            "documentation": {
                "sections": [
                    {
                        "content": "Performs static checks on a path segment.\n\nThe type  [PathSegment](@nav/api/MainModule.PathSegment)  ensures that the given string adheres to specific rules:\n- The segment must be a single static path segment (e.g.,  `/foo` ).\n- Segments containing backslashes ( `\\\\` ), query parameters ( `?` ), or fragments ( `#` ) are not allowed.\n- Nested paths (e.g.,  `/foo/bar` ) are disallowed.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    },
                    {
                        "title": "Generics",
                        "content": "\n*  **T**: The type of the string segment to validate.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "arguments",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "PathSegment",
            "attributes": [],
            "callables": [],
            "code": {
                "filePath": "src/lib/navigation.node.ts",
                "declaration": "export type PathSegment<T extends string> = T extends `/${string}/${string}`\n    ? never\n    : T extends `/${string}`\n      ? T extends\n            | `${string}\\\\${string}`\n            | `${string}?${string}`\n            | `${string}#${string}`\n          ? never\n          : T\n      : never",
                "implementation": "",
                "startLine": 440,
                "endLine": 441,
                "references": {
                    "PathSegment": "@nav/api/MainModule.PathSegment",
                    "T": "1148"
                }
            },
            "semantic": {
                "role": "type-alias",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "Resolvable",
            "documentation": {
                "sections": [
                    {
                        "content": "Represents a value that can be resolved to a specific type.\n\nA  `Resolvable`  can take the form of:\n- A direct value of type  `T` .\n- A  `Promise`  resolving to a value of type  `T` .\n- An  `Observable`  emitting values of type  `T` .\n\n<note level=\"warning\">\nWhen an  `Observable`  is provided, only its **first emission** is considered.\nSubsequent emissions are ignored.\n</note>",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    },
                    {
                        "title": "Generics",
                        "content": "\n*  **T**: The type of the value that can be resolved.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "arguments",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "Resolvable",
            "attributes": [],
            "callables": [],
            "code": {
                "filePath": "src/lib/navigation.node.ts",
                "declaration": "export type Resolvable<T> = T | Promise<T> | Observable<T>",
                "implementation": "",
                "startLine": 295,
                "endLine": 296,
                "references": {
                    "Resolvable": "@nav/api/MainModule.Resolvable",
                    "T": "1118"
                }
            },
            "semantic": {
                "role": "type-alias",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "SegmentsRecord",
            "documentation": {
                "sections": [
                    {
                        "content": "Represents a mapping of path segments to corresponding values.\n\nThe  `SegmentsRecord`  type defines a record where the keys are valid path segments,\nas determined by the  [PathSegment](@nav/api/MainModule.PathSegment)  type, and the values are of type  `T` .\n\nThis is commonly used to associate specific data or configurations with individual\npath segments in a structured and type-safe manner.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    },
                    {
                        "title": "Generics",
                        "content": "\n*  **T**: The type of the value associated with each path segment.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "arguments",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "SegmentsRecord",
            "attributes": [],
            "callables": [],
            "code": {
                "filePath": "src/lib/navigation.node.ts",
                "declaration": "export type SegmentsRecord<T> = Record<PathSegment<string>, T>",
                "implementation": "",
                "startLine": 318,
                "endLine": 319,
                "references": {
                    "SegmentsRecord": "@nav/api/MainModule.SegmentsRecord",
                    "PathSegment": "@nav/api/MainModule.PathSegment",
                    "T": "1120"
                }
            },
            "semantic": {
                "role": "type-alias",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "StaticRoutes",
            "documentation": {
                "sections": [
                    {
                        "content": "Represents the definition of static routes in the application.\n\nStatic routes are defined as a mapping where each  `segmentId`  (representing a segment's contribution to the URL)\nis associated with a  [Resolvable](@nav/api/MainModule.Resolvable)   [Navigation](@nav/api/MainModule.Navigation)  object.\n\n<note level=\"hint\" title=\"Promise\">\nPromises can be used, for instance, when requests need to be triggered to fetch attributes or metadata\nfor a navigation node. In such cases, the navigation tree will wait for the promise to resolve before updating its\nstate.\n\nIn the common scenario where only the layout's content requires an asynchronous task to resolve,\nit is often possible to specify this dependency within the layout itself. This approach allows the\nnavigation tree to avoid waiting for the task's resolution, as the asynchronous handling is confined\nto the layout specification.\n</note>\n\n<note level=\"hint\">\nThe  [segment](@nav/api/MainModule.segment)  function performs both static and dynamic checks to validate the segment ID.\n</note>",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    },
                    {
                        "title": "Generics",
                        "content": "\n*  **TLayout**: The type defining the layout configuration for the navigation.\n*  **THeader**: The type defining the header configuration for the navigation.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "arguments",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "StaticRoutes",
            "attributes": [],
            "callables": [],
            "code": {
                "filePath": "src/lib/navigation.node.ts",
                "declaration": "export type StaticRoutes<TLayout, THeader> = Record<\n    string,\n    Resolvable<Navigation<TLayout, THeader>>\n>",
                "implementation": "",
                "startLine": 372,
                "endLine": 373,
                "references": {
                    "StaticRoutes": "@nav/api/MainModule.StaticRoutes",
                    "Resolvable": "@nav/api/MainModule.Resolvable",
                    "Navigation": "@nav/api/MainModule.Navigation",
                    "TLayout": "1134",
                    "THeader": "1135"
                }
            },
            "semantic": {
                "role": "type-alias",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "Target",
            "documentation": {
                "sections": [
                    {
                        "content": "Target destination specification when navigating to a (resolved) specific path.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "Target",
            "attributes": [],
            "callables": [],
            "code": {
                "filePath": "src/lib/router.ts",
                "declaration": "export type Target<TLayout = unknown, THeader = unknown> = UrlTarget & {\n    /**\n     * Associated navigation's node.\n     */\n    node: Navigation<TLayout, THeader>\n}",
                "implementation": "",
                "startLine": 67,
                "endLine": 68,
                "references": {
                    "Target": "@nav/api/MainModule.Target",
                    "UrlTarget": "@nav/api/MainModule.UrlTarget",
                    "Navigation": "@nav/api/MainModule.Navigation",
                    "TLayout": "1217",
                    "THeader": "1218"
                }
            },
            "semantic": {
                "role": "type-alias",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "ViewGenerator",
            "documentation": {
                "sections": [
                    {
                        "content": "Type definition for custom view generators.\n\nThe function takes as arguments:\n*  **elem**: The HTMLElement in Markdown that triggered the generator.\n*  **options**: The options that were provided to the MD parser.\n\nIt returns the generated virtual DOM.\n\n See details in the documentation of  [parseMd](undefined)  to register views.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "ViewGenerator",
            "attributes": [],
            "callables": [],
            "code": {
                "filePath": "src/lib/markdown.ts",
                "declaration": "export type ViewGenerator = (\n    elem: HTMLElement,\n    options: { router?: Router } & MdParsingOptions,\n) => AnyView",
                "implementation": "",
                "startLine": 31,
                "endLine": 32,
                "references": {
                    "ViewGenerator": "@nav/api/MainModule.ViewGenerator",
                    "Router": "@nav/api/MainModule.Router",
                    "MdParsingOptions": "@nav/api/MainModule.MdParsingOptions",
                    "AnyView": "@nav/api/MainModule.AnyView"
                }
            },
            "semantic": {
                "role": "type-alias",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        }
    ],
    "callables": [
        {
            "name": "fetchMd",
            "documentation": {
                "sections": [
                    {
                        "content": "Fetch & parse a Markdown file from specified with a URL.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    },
                    {
                        "title": "Arguments",
                        "content": "\n*  **params**: see  [MdParsingOptions](@nav/api/MainModule.MdParsingOptions)  for additional options.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "arguments",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "fetchMd",
            "code": {
                "filePath": "src/lib/markdown.ts",
                "declaration": "export function fetchMd(\n    params: FetchMdInput,\n): ({ router }: { router: Router }) => Promise<VirtualDOM<'div'>>",
                "implementation": "export function fetchMd(\n    params: FetchMdInput,\n): ({ router }: { router: Router }) => Promise<VirtualDOM<'div'>> {\n    return async ({ router }: { router: Router }) => {\n        const resp = await fetch(params.url)\n        const src = await resp.text()\n        return parseMd({\n            src,\n            router,\n            ...params,\n        })\n    }\n}",
                "startLine": 125,
                "endLine": 138,
                "references": {
                    "fetchMd": "@nav/api/MainModule.fetchMd",
                    "FetchMdInput": "@nav/api/MainModule.FetchMdInput",
                    "Router": "@nav/api/MainModule.Router"
                }
            },
            "semantic": {
                "role": "function",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "installCodeApiModule",
            "documentation": {
                "sections": [
                    {
                        "content": "Install and returns the  [CodeApiModule](@nav/api/CodeApi)  module.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "installCodeApiModule",
            "code": {
                "filePath": "src/index.ts",
                "declaration": "export async function installCodeApiModule()",
                "implementation": "export async function installCodeApiModule() {\n    const module = (await setup.installAuxiliaryModule({\n        name: 'CodeApi',\n        cdnClient: webpmClient,\n    })) as typeof CodeApiModule\n    module.Dependencies.parseMd = parseMd\n    module.Dependencies.DefaultLayout = DefaultLayout\n    module.Dependencies.installNotebookModule = installNotebookModule\n    module.Dependencies.headingId = headingId\n    return module\n}",
                "startLine": 21,
                "endLine": 32,
                "references": {
                    "installCodeApiModule": "@nav/api/MainModule.installCodeApiModule",
                    "__module": "@nav/api/CodeApi"
                }
            },
            "semantic": {
                "role": "function",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "installNotebookModule",
            "documentation": {
                "sections": [
                    {
                        "content": "Install and returns the  [NotebookModule](@nav/api/Notebook)  module.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "installNotebookModule",
            "code": {
                "filePath": "src/index.ts",
                "declaration": "export async function installNotebookModule()",
                "implementation": "export async function installNotebookModule() {\n    const module = (await setup.installAuxiliaryModule({\n        name: 'Notebook',\n        cdnClient: webpmClient,\n    })) as typeof NotebookModule\n    module.Dependencies.parseMd = parseMd\n    module.Dependencies.MdWidgets = MdWidgets\n    return module\n}",
                "startLine": 36,
                "endLine": 45,
                "references": {
                    "installNotebookModule": "@nav/api/MainModule.installNotebookModule",
                    "__module": "@nav/api/Notebook"
                }
            },
            "semantic": {
                "role": "function",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "parseMd",
            "documentation": {
                "sections": [
                    {
                        "content": "Parse Markdown source to generate corresponding view.\n\nNote that custom views provided using the attribute  `views  comes in addition to those registered globally in\n{@link GlobalMarkdownViews}.\n\n**Notes on custom views**\n\nCustom views allow to replace in Markdown sources some elements by dynamically generated ones in javascript.\n\n\nFor instance, a custom view ` foo-view ` can be referenced in the Markdown:\n ```\n # An example of custom-view\n\n This is a custom view:\n <foo-view barAttr='bar' bazAttr=\"baz\">some content</foo-view>\n ```\n When parsed, it will be replaced by its corresponding generated view if ` foo-view ` is included in this\n ` views ` mapping provided to this function. The associated generator can access attributes (here ` barAttr ` &\n ` bazAttr `) as well as the original text content (` some content`).\n\n The generator functions are called in the order of their corresponding elements in the Markdown source.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    },
                    {
                        "title": "Arguments",
                        "content": "\n*  **args**: see  [MdParsingOptions](@nav/api/MainModule.MdParsingOptions)  for additional options.\n*  **router**: The router instance.\n*  **src**: Markdown source.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "arguments",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    },
                    {
                        "title": "Returns",
                        "content": "A virtual DOM encapsulating the parsed Markdown.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "returns",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "parseMd",
            "code": {
                "filePath": "src/lib/markdown.ts",
                "declaration": "export function parseMd({\n    src,\n    router,\n    views,\n    placeholders,\n    preprocessing,\n    emitHtmlUpdated,\n    latex,\n}: {\n    src: string\n    router?: Router\n    navigations?: Record<string, (e: HTMLAnchorElement) => void>\n} & MdParsingOptions): VirtualDOM<'div'>",
                "implementation": "export function parseMd({\n    src,\n    router,\n    views,\n    placeholders,\n    preprocessing,\n    emitHtmlUpdated,\n    latex,\n}: {\n    src: string\n    router?: Router\n    navigations?: Record<string, (e: HTMLAnchorElement) => void>\n} & MdParsingOptions): VirtualDOM<'div'> {\n    src = preprocessing?.(src) ?? src\n    if (placeholders && Object.keys(placeholders).length > 0) {\n        const regex = new RegExp(Object.keys(placeholders).join('|'), 'g')\n        src = src.replace(regex, (match) => placeholders[match])\n    }\n    views = { ...views, ...GlobalMarkdownViews.factory }\n    const { div, replacedViews } = fixedMarkedParseCustomViews({\n        input: src,\n        views: views,\n    })\n\n    // @ts-expect-error Need to find a better way\n    if (latex && window.MathJax) {\n        // eslint-disable-next-line\n        window['MathJax'].typeset([div])\n    }\n\n    const customs = div.querySelectorAll('.language-custom-view')\n    ;[...customs]\n        .filter((custom) => custom instanceof HTMLElement)\n        .forEach((custom) => {\n            // eslint-disable-next-line @typescript-eslint/no-implied-eval,@typescript-eslint/no-unsafe-call\n            const fct = new Function(custom.innerText)()({\n                webpm,\n            }) as unknown as Promise<AnyVirtualDOM>\n            const view = render({\n                tag: 'div',\n                children: [\n                    child$({\n                        source$: from(fct),\n                        vdomMap: (vDom) => vDom,\n                    }),\n                ],\n            })\n            custom.parentNode?.parentNode?.replaceChild(view, custom.parentNode)\n        })\n\n    const options = {\n        router,\n        preprocessing,\n        placeholders,\n        latex,\n        views,\n        emitHtmlUpdated,\n    }\n    const viewsTagUpperCase: Record<\n        Uppercase<string>,\n        ViewGenerator\n    > = Object.entries(views).reduce(\n        (acc, [k, v]) => ({ ...acc, [k.toUpperCase()]: v }),\n        {},\n    )\n    Object.entries(replacedViews).forEach(([k, content]: [string, string]) => {\n        const elem = div.querySelector(`#${k}`)\n        if (!elem || !(elem instanceof HTMLElement)) {\n            return\n        }\n        elem.textContent = content\n        if (!((elem.tagName as Uppercase<string>) in viewsTagUpperCase)) {\n            return\n        }\n        const factory = viewsTagUpperCase[elem.tagName as Uppercase<string>]\n        const replacedView = factory(elem, options)\n        elem.parentNode?.replaceChild(\n            replacedView instanceof HTMLElement\n                ? replacedView\n                : render(replacedView),\n            elem,\n        )\n    })\n\n    return {\n        tag: 'div',\n        children: [div],\n        connectedCallback: (elem) => {\n            // Navigation links\n            if (router) {\n                replaceLinks({ router, elem, fromMarkdown: true })\n            }\n            if (emitHtmlUpdated && router) {\n                router.emitHtmlUpdated()\n            }\n        },\n    }\n}",
                "startLine": 175,
                "endLine": 273,
                "references": {
                    "parseMd": "@nav/api/MainModule.parseMd",
                    "Router": "@nav/api/MainModule.Router",
                    "MdParsingOptions": "@nav/api/MainModule.MdParsingOptions"
                }
            },
            "semantic": {
                "role": "function",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "parseUrl",
            "documentation": {
                "sections": [
                    {
                        "content": "Parse a URL as string into a  [UrlTarget](@nav/api/MainModule.UrlTarget)  - only query parameters are relevant.\n\n*   [UrlTarget.path](@nav/api/MainModule.UrlTarget.path)  is extracted from the  `nav`  query parameter.\n*   [UrlTarget.parameters](@nav/api/MainModule.UrlTarget.parameters)  are other query parameters.\n*   [UrlTarget.sectionId](@nav/api/MainModule.UrlTarget.sectionId)  is specified by the part after the first  `.`  in the  `nav`  query parameter.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    },
                    {
                        "title": "Arguments",
                        "content": "\n*  **url**: String to parse.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "arguments",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    },
                    {
                        "title": "Returns",
                        "content": "The target",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "returns",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "parseUrl",
            "code": {
                "filePath": "src/lib/browser.interface.ts",
                "declaration": "export function parseUrl(url: string): UrlTarget",
                "implementation": "export function parseUrl(url: string): UrlTarget {\n    const urlParams = new URLSearchParams(url)\n    const nav = sanitizeNavPath(urlParams.get('nav') ?? '/')\n\n    const parameters = Object.fromEntries(urlParams.entries())\n    delete parameters.nav\n    if (!nav.includes('.')) {\n        return {\n            path: nav,\n            parameters,\n        }\n    }\n    return {\n        path: nav.split('.')[0],\n        parameters,\n        sectionId: nav.split('.').slice(1).join('.'),\n    }\n}",
                "startLine": 88,
                "endLine": 106,
                "references": {
                    "parseUrl": "@nav/api/MainModule.parseUrl",
                    "UrlTarget": "@nav/api/MainModule.UrlTarget"
                }
            },
            "semantic": {
                "role": "function",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "removeEscapedText",
            "documentation": {
                "sections": [
                    {
                        "content": "This function takes an input text, remove the escaped parts:\n*  a line start with triple back-quote: this line is escaped as well as all the following line until one starts\nwith triple back-quote.\n*  a line include a single back quote: the remaining of the line as well as all the following line until a corresponding\nsingle back-quote is found.\n\nWhen a part of the input is escaped it is replaced by a string  `__ESCAPED_${ID}`  where ID is a unique ID,\nthe function returned the escaped text as well as a dict that gathers the escaped elements.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "removeEscapedText",
            "code": {
                "filePath": "src/lib/markdown.ts",
                "declaration": "export function removeEscapedText(src: string): {\n    escapedContent: string\n    replaced: Record<string, string>\n}",
                "implementation": "export function removeEscapedText(src: string): {\n    escapedContent: string\n    replaced: Record<string, string>\n} {\n    let escapedContent = src // Initialize the escaped content with the source text\n    const replaced = {} // Initialize an object to store the replaced escaped elements\n\n    // Regular expression patterns to match escaped parts\n    const tripleBackquotePattern = /```([\\s\\S]*?)```/g\n\n    // Replace triple back-quote escaped parts\n    escapedContent = escapedContent.replace(tripleBackquotePattern, (match) => {\n        const id = `__ESCAPED_${String(Object.keys(replaced).length)}` // Generate a unique ID\n        replaced[id] = match // Store the escaped part in the replaced object\n        return id // Replace the escaped part with the unique ID\n    })\n\n    // Regular expression pattern to match single back-quoted escaped parts spanning multiple lines\n    const multilineBackquotePattern = /`([\\s\\S]*?)`/g\n\n    // Replace single back-quote escaped parts\n    escapedContent = escapedContent.replace(\n        multilineBackquotePattern,\n        (match) => {\n            const id = `__ESCAPED_${String(Object.keys(replaced).length)}` // Generate a unique ID\n            replaced[id] = match // Store the escaped part in the replaced object\n            return id // Replace the escaped part with the unique ID\n        },\n    )\n\n    return { escapedContent, replaced }\n}",
                "startLine": 377,
                "endLine": 409,
                "references": {
                    "removeEscapedText": "@nav/api/MainModule.removeEscapedText"
                }
            },
            "semantic": {
                "role": "function",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "sanitizeNavPath",
            "documentation": {
                "sections": [
                    {
                        "content": "Sanitize an input navigation path:\n*  Ensures single starting '/'.\n*  Corrects for empty path sequence, *e.g.*  `foo//bar/.baz`  ->  `/foo/bar.baz`",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    },
                    {
                        "title": "Arguments",
                        "content": "\n*  **path**: The input path.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "arguments",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    },
                    {
                        "title": "Returns",
                        "content": "The sanitized path.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "returns",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "sanitizeNavPath",
            "code": {
                "filePath": "src/lib/navigation.node.ts",
                "declaration": "export function sanitizeNavPath(path: string)",
                "implementation": "export function sanitizeNavPath(path: string) {\n    return (\n        '/' + path.replace(/^\\/+/, '').replace(/\\/+/g, '/').replace('/.', '.')\n    )\n}",
                "startLine": 424,
                "endLine": 429,
                "references": {
                    "sanitizeNavPath": "@nav/api/MainModule.sanitizeNavPath"
                }
            },
            "semantic": {
                "role": "function",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "segment",
            "documentation": {
                "sections": [
                    {
                        "content": "Validates a static path segment at compile time.\n\nThis function uses the  [PathSegment](@nav/api/MainModule.PathSegment)  type to perform static validation\nof the provided segment ID. It ensures that the segment complies with the\nrequired format and restrictions.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    },
                    {
                        "title": "Arguments",
                        "content": "\n*  **p**: The segment ID to validate (e.g.,  `/foo` ).",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "arguments",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    },
                    {
                        "title": "Returns",
                        "content": "The validated segment if it passes all static checks.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "returns",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "segment",
            "code": {
                "filePath": "src/lib/navigation.node.ts",
                "declaration": "export function segment<T extends string>(p: PathSegment<T>)",
                "implementation": "export function segment<T extends string>(p: PathSegment<T>) {\n    return p\n}",
                "startLine": 461,
                "endLine": 464,
                "references": {
                    "segment": "@nav/api/MainModule.segment",
                    "PathSegment": "@nav/api/MainModule.PathSegment",
                    "T": "1033"
                }
            },
            "semantic": {
                "role": "function",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        }
    ],
    "files": [
        {
            "name": "index.ts",
            "path": "src/index.ts",
            "documentation": {
                "sections": [
                    {
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        },
                        "content": "Main module of the library.",
                        "contentType": "markdown"
                    }
                ]
            }
        },
        {
            "name": "index.ts",
            "path": "src/lib/default-layout/index.ts",
            "documentation": {
                "sections": [
                    {
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        },
                        "content": "This module gathers views definition.",
                        "contentType": "markdown"
                    }
                ]
            }
        },
        {
            "name": "index.ts",
            "path": "src/lib/md-widgets/index.ts",
            "documentation": {
                "sections": [
                    {
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        },
                        "content": "This module defines a collection of widgets that can be instantiated directly from Markdown\nsource when using the  function. Widgets are referenced within ,\nwhich maps `tag-name -> implementation` to enable seamless integration into Markdown content.\n\nEach widget provides a static `fromHTMLElement` method that specifies the attributes required for its instantiation.\n\n## Overview\n\nBelow are examples of the available widgets. For detailed documentation on their attributes and behavior,\nrefer to their respective sections. Additionally, you can create custom widgets and register them globally\nfor your application. See the section **New Widgets** for guidance.\n\n\n---\n\n### \n\n<md-cell>\n\n<note level=\"info\">\nLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna\naliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\n</note>\n</md-cell>\n\n---\n\n### \n\n<md-cell>\n<code-snippet language=\"javascript\" highlightedLines=\"8\">\n\nfunction compute({improbabilityFactor, babelFishCount, vogonPoetryExposure, towelAbsorbency }){\n    console.log(\"Computation complete! The result is 42\");\n    const result =\n        Math.log(improbabilityFactor + 42) +\n        babelFishCount === 1 ? 1 : Math.sqrt(babelFishCount) +\n        vogonPoetryExposure > 1000 ? -42 : vogonPoetryExposure / 100 +\n        towelAbsorbency * (Math.random() + 0.42)\n    return 42;\n}\n</code-snippet>\n</md-cell>\n\n---\n\n### \n\n<md-cell>\n<code-badges version=\"{{mkdocs-version}}\" npm=\"mkdocs-ts\" github=\"w3nest/mkdocs-ts\" license=\"mit\">\n</code-badges>\n</md-cell>\n\n---\n\n## New Widgets\nTo extend the functionality of , you can define and register custom widgets globally.\n\n---\n\n### Step 1: Define Implementation\n\n<js-cell>\nconst { MkDocs, TP } = await webpm.install({\n    esm:[\n        'mkdocs-ts#{{mkdocs-version}} as MkDocs',\n        'tweakpane#^4.0.1 as TP',\n    ]\n})\n\nconst customViewExample = (element) => {\n    const pane = new TP.Pane()\n    const getAttr = (name, defaultVal) => parseFloat(element.getAttribute(name) ?? defaultVal )\n    const params = {\n        improbabilityFactor: getAttr('improbabilityFactor', 3),\n        babelFishCount: getAttr('babelFishCount', 1),\n        vogonPoetryExposure: getAttr('vogonPoetryExposure', 250),\n        towelAbsorbency: getAttr('towelAbsorbency', 2),\n    };\n    Object.keys(params).forEach((k) => pane.addBinding(params, k))\n    pane.addButton({ title: 'Compute', label: ''}).on('click', () => computeCb(params));\n    return pane.element\n}\n</js-cell>\n\n---\n\n### Step 2: Register Element\n\n<js-cell>\nMkDocs.GlobalMarkdownViews.factory = {\n    ...MkDocs.GlobalMarkdownViews.factory,\n    'custom-view-example' : (element) => customViewExample(element)\n}\n</js-cell>\n\nSee  for details.\n\n---\n\n### Step 3: Enjoy\n\n<md-cell>\nBelow is the custom view `controls` instantiated with `improbabilityFactor=5`:\n\n<custom-view-example improbabilityFactor=\"5.00\">\n</custom-view-example>\n</md-cell>",
                        "contentType": "markdown"
                    }
                ]
            }
        },
        {
            "name": "generic.view.ts",
            "path": "src/lib/generic.view.ts",
            "documentation": {
                "sections": [
                    {
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        },
                        "content": "",
                        "contentType": "markdown"
                    }
                ]
            }
        },
        {
            "name": "markdown.ts",
            "path": "src/lib/markdown.ts",
            "documentation": {
                "sections": [
                    {
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        },
                        "content": "This file gathers entry points related to Mardown parsing.",
                        "contentType": "markdown"
                    }
                ]
            }
        },
        {
            "name": "browser.interface.ts",
            "path": "src/lib/browser.interface.ts",
            "documentation": {
                "sections": [
                    {
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        },
                        "content": "",
                        "contentType": "markdown"
                    }
                ]
            }
        },
        {
            "name": "navigation.node.ts",
            "path": "src/lib/navigation.node.ts",
            "documentation": {
                "sections": [
                    {
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        },
                        "content": "",
                        "contentType": "markdown"
                    }
                ]
            }
        },
        {
            "name": "router.ts",
            "path": "src/lib/router.ts",
            "documentation": {
                "sections": [
                    {
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        },
                        "content": "",
                        "contentType": "markdown"
                    }
                ]
            }
        },
        {
            "name": "auto-generated.ts",
            "path": "src/auto-generated.ts",
            "documentation": {
                "sections": [
                    {
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        },
                        "content": "",
                        "contentType": "markdown"
                    }
                ]
            }
        }
    ],
    "children": [
        {
            "name": "DefaultLayout",
            "path": "mkdocs-ts/MainModule.DefaultLayout",
            "isLeaf": true
        },
        {
            "name": "MdWidgets",
            "path": "mkdocs-ts/MainModule.MdWidgets",
            "isLeaf": true
        }
    ],
    "semantic": {
        "role": "module",
        "labels": [],
        "attributes": {},
        "relations": {}
    }
}
