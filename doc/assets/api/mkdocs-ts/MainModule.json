{
    "name": "MainModule",
    "documentation": {
        "sections": [
            {
                "content": "# Overview\n\nThis is the **main module** of the library.\n\n## Core\n\nThe module defines the  [Router](@nav/api/MainModule.Router)  class, responsible for handling navigation between  [Navigation](@nav/api/MainModule.Navigation)  nodes.\n\n## Views\n\nIn terms of views, this module provides a  [CompositeLayout](@nav/api/MainModule.CompositeLayout) , which can wrap multiple layout types.\nThe library also includes a default layout, defined in the  [DefaultLayout](@nav/api/MainModule/DefaultLayout)  module.\n\n## Markdown\n\nThe module includes Markdown processing utilities through the  [parseMd](@nav/api/MainModule.parseMd)  and  [parseMdFromUrl](@nav/api/MainModule.parseMdFromUrl)  functions.\n\nVarious options are available, including support for defining custom views.\n\n## Logging\n\nThe module provides utilities for  [Context](@nav/api/MainModule.Context)  management, offering structured logging across the package.\nIt includes two built-in reporters, both implementing  [ReporterTrait](@nav/api/MainModule.ReporterTrait) :\n\n-  [ConsoleReporter](@nav/api/MainModule.ConsoleReporter)  (logs to the console).\n\n-  [InMemoryReporter](@nav/api/MainModule.InMemoryReporter)  (stores logs in memory).\n\n## Plugins\n\nTwo plugins are included:\n\n- **Code API Module** ( [CodeApiModule](@nav/api/CodeApi) )\n  - Installed using  [installCodeApiModule](@nav/api/MainModule.installCodeApiModule) .\n  - Enables automatic generation of pages from code API documentation.\n\n- **Notebook Module** ( [NotebookModule](@nav/api/Notebook) )\n  - Installed using  [installNotebookModule](@nav/api/MainModule.installNotebookModule) .\n  - Supports pages with live code execution.",
                "contentType": "markdown",
                "semantic": {
                    "role": "",
                    "labels": [],
                    "attributes": {},
                    "relations": {}
                }
            }
        ]
    },
    "path": "mkdocs-ts/MainModule",
    "navPath": "@nav/api/",
    "attributes": [],
    "types": [
        {
            "name": "CompositeLayout",
            "documentation": {
                "sections": [
                    {
                        "content": "This component dynamically selects and renders layouts based on navigation data.\n\n-  Each  [Navigation](@nav/api/MainModule.Navigation)  node specifies a  `kind`  attribute within its layout definition\n   ( [NavNodeData.layout](@nav/api/MainModule.NavNodeData.layout) ).\n\n-  The constructor expects a layout factory, mapping  `kind`  values to their respective layout implementations\n   (which follow  [LayoutGeneratorTrait](@nav/api/MainModule.LayoutGeneratorTrait) ).\n\n-  If no matching layout kind exists for a navigation node at runtime, the  [LayoutKindNotFoundView](@nav/api/MainModule.LayoutKindNotFoundView)  is\n   displayed. In TypeScript, such a mismatch results in a compilation error, ensuring correctness at build time.\n\n<note level=\"hint\">\nThe **layout factory is only invoked when switching layout kinds**, minimizing unnecessary re-renders.\nFor state persistence across layouts, maintain state outside the layout view.\n</note>\n\n---\n\n**Type System & Static Safety**\n\nThis class is designed to maximize TypeScript type safety across  [Navigation](@nav/api/MainModule.Navigation) ,  [Router](@nav/api/MainModule.Router) , and\n [CompositeLayout](@nav/api/MainModule.CompositeLayout)  structures.\n\nType definitions rely on combining individual layout ( `TLayout` ) and header ( `THeader` ) types\n(involved in  [Navigation](@nav/api/MainModule.Navigation) )  to define the global ones:\n-  The global  `TLayout`  type is a **union** of all possible layout types. Since each layout has a  `kind`  type\n   literal attribute, TypeScript correctly infers the specific layout type for each node.\n-  The global  `THeader` type is an **intersection** of all possible header type, ensuring every layout can render\n   headers for any navigation node. In practice, a single shared header type simplifies implementation.\n\nThe following steps assume all layouts use the default  [DefaultLayout.NavHeader](@nav/api/MainModule/DefaultLayout.NavHeader)  specification for headers.\n\n**1 - Define a  `LayoutOptionsMap`  type**\n\nExplicitly map individual layout kinds to their corresponding types:\n\n<code-snippet language='javascript'>\nimport { DefaultLayout } from 'mkdocs-ts'\n\ntype Slide = { ... }\n\ntype LayoutOptionsMap = {\n    default: DefaultLayout.NavLayout\n    presentation: Slide\n}\n</code-snippet>\n\n**2 - Define the Navigation Structure**\n\nUse  [LayoutUnion](@nav/api/MainModule.LayoutUnion)  to create a strongly-typed  [Navigation](@nav/api/MainModule.Navigation)  definition:\n\n<code-snippet language='javascript'>\nimport { LayoutUnion } from 'mkdocs-ts'\n\nexport const navigation: Navigation<\n    LayoutUnion<LayoutOptionsMap>,\n    DefaultLayout.NavHeader\n> = { ... }\n</code-snippet>\n\nThis ensures node's layout being either  `{kind: 'default'} & DefaultLayout.NavLayout`  or\n `{kind: 'presentation'} & Slide` , enabling automatic type discrimination from typescript based on the  `kind`  value.\n\n**3 - Configure Router & CompositeLayout**\n\nFrom there, automatic type inference within  [Router](@nav/api/MainModule.Router)  and  [CompositeLayout](@nav/api/MainModule.CompositeLayout)  will play nicely:\n\n<code-snippet language='javascript'>\nimport { MultiLayouts, Router } from 'mkdocs-ts'\n\nconst router = new Router({ navigation })\n\nconst routerView = new CompositeLayout({\n    router,\n    layoutsFactory: {\n        default: ({ router }) => new DefaultLayout.Layout({ router }),\n        presentation: ({ router }) => new PresentationLayout({ router })\n    },\n    onPending: defaultLayoutKind,\n    onNotFound: defaultLayoutKind,\n})\n</code-snippet>\n\nWhile the global  `router`  is inferred using the combined type for  `TLayout`  and  `THeader`  given  `navigation` ,\nthose involved as argument in the  `layoutsFactory`  are more specific:\n-  The  `default`  entry gets  `Router<DefaultLayout.NavLayout, DefaultLayout.NavHeader>` .\n-  The  `presentation`  entry gets  `Router<Slide, DefaultLayout.NavHeader>` .\n\n\n---",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    },
                    {
                        "title": "Generics",
                        "content": "\n*  **LayoutOptionsMap**: Maps layout kind literals to their corresponding layout types.\n*  **THeader**: The intersection of all possible header types.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "arguments",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "CompositeLayout",
            "navPath": "@nav/api/MainModule.CompositeLayout",
            "attributes": [
                {
                    "name": "children",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "Children of the element.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "CompositeLayout.children",
                    "navPath": "@nav/api/MainModule.CompositeLayout.children",
                    "code": {
                        "filePath": "src/lib/composite-layout.view.ts",
                        "declaration": "public readonly children: ChildrenLike",
                        "implementation": "",
                        "startLine": 204,
                        "endLine": 205,
                        "references": {
                            "children": "@nav/api/MainModule.CompositeLayout.children",
                            "ChildrenLike": "/apps/@rx-vdom/doc/latest?nav=/api.ChildrenLike"
                        }
                    }
                },
                {
                    "name": "class",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "The class associated with the element, equivalent to the  `className`  property of  `HTMLElement` .",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "CompositeLayout.class",
                    "navPath": "@nav/api/MainModule.CompositeLayout.class",
                    "code": {
                        "filePath": "src/lib/composite-layout.view.ts",
                        "declaration": "public readonly class = 'w-100 h-100'",
                        "implementation": "",
                        "startLine": 203,
                        "endLine": 204,
                        "references": {
                            "class": "@nav/api/MainModule.CompositeLayout.class"
                        }
                    }
                },
                {
                    "name": "tag",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "The tag of the element, equivalent to the  `tagName`  property of  `HTMLElement` .",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "CompositeLayout.tag",
                    "navPath": "@nav/api/MainModule.CompositeLayout.tag",
                    "code": {
                        "filePath": "src/lib/composite-layout.view.ts",
                        "declaration": "public readonly tag = 'div'",
                        "implementation": "",
                        "startLine": 202,
                        "endLine": 203,
                        "references": {
                            "tag": "@nav/api/MainModule.CompositeLayout.tag"
                        }
                    }
                }
            ],
            "callables": [
                {
                    "name": "CompositeLayout",
                    "documentation": {
                        "sections": [
                            {
                                "content": "Creates a new instance.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            },
                            {
                                "title": "Arguments",
                                "content": "\n*  **params**: The parameters.\n*  **layoutsFactory**: The layout factory. Keys correspond to  `kind`  attribute of the layouts.\n*  **onNotFound**: The ID of the layout to use when  [Router.target$](@nav/api/MainModule.Router.target$)  cannot resolve the\nnavigation path because it does not exist.\n*  **onPending**: The ID of the layout to use when  [Router.target$](@nav/api/MainModule.Router.target$)  cannot resolve the\nnavigation path because navigation is currently resolving.\n*  **router**: The application's router instance.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "arguments",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "CompositeLayout.CompositeLayout",
                    "navPath": "@nav/api/MainModule.CompositeLayout.constructor",
                    "code": {
                        "filePath": "src/lib/composite-layout.view.ts",
                        "declaration": "constructor(params: {\n    router: Router<LayoutUnion<LayoutOptionsMap>, THeader>\n    layoutsFactory: LayoutFactory<LayoutOptionsMap, THeader>\n    onNotFound: LayoutKindUnion<LayoutOptionsMap>\n    onPending: LayoutKindUnion<LayoutOptionsMap>\n})",
                        "implementation": "constructor(params: {\n    router: Router<LayoutUnion<LayoutOptionsMap>, THeader>\n    layoutsFactory: LayoutFactory<LayoutOptionsMap, THeader>\n    onNotFound: LayoutKindUnion<LayoutOptionsMap>\n    onPending: LayoutKindUnion<LayoutOptionsMap>\n}) {\n    Object.assign(this, params)\n    const layout$ = this.router.target$.pipe(\n        map((target) => {\n            if (isResolvedTarget(target)) {\n                return target.node.layout.kind\n            }\n            if (target.reason === 'Pending') {\n                return this.onPending\n            }\n            return this.onNotFound\n        }),\n        distinctUntilChanged(),\n    )\n    this.children = [\n        child$({\n            source$: layout$,\n            vdomMap: (layoutKind) => {\n                if (layoutKind in this.layoutsFactory) {\n                    type TLayoutOptions =\n                        LayoutOptionsMap[LayoutKindUnion<LayoutOptionsMap>]\n                    const view = this.layoutsFactory[\n                        layoutKind as LayoutKindUnion<LayoutOptionsMap>\n                    ]({\n                        router: this.router as unknown as Router<\n                            TLayoutOptions,\n                            THeader\n                        >,\n                    })\n                    return view instanceof HTMLElement\n                        ? { tag: 'div', children: [view] }\n                        : view\n                }\n                return new LayoutKindNotFoundView({\n                    unknownKey: layoutKind as string,\n                    availableKeys: Object.keys(this.layoutsFactory),\n                    path: this.router.parseUrl().path,\n                })\n            },\n        }),\n    ]\n}",
                        "startLine": 222,
                        "endLine": 269,
                        "references": {
                            "CompositeLayout": "@nav/api/MainModule.CompositeLayout",
                            "LayoutFactory": "@nav/api/MainModule.LayoutFactory",
                            "LayoutKindUnion": "@nav/api/MainModule.LayoutKindUnion",
                            "Router": "@nav/api/MainModule.Router",
                            "LayoutUnion": "@nav/api/MainModule.LayoutUnion"
                        }
                    },
                    "semantic": {
                        "role": "constructor",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    }
                }
            ],
            "code": {
                "filePath": "src/lib/composite-layout.view.ts",
                "declaration": "export class CompositeLayout<LayoutOptionsMap, THeader>\nimplements VirtualDOM<'div'>",
                "implementation": "export class CompositeLayout<LayoutOptionsMap, THeader>\n    implements VirtualDOM<'div'>\n{\n    public readonly tag = 'div'\n    public readonly class = 'w-100 h-100'\n    public readonly children: ChildrenLike\n\n    public readonly router: Router<LayoutUnion<LayoutOptionsMap>, THeader>\n    public readonly layoutsFactory: LayoutFactory<LayoutOptionsMap, THeader>\n    public readonly onNotFound: LayoutKindUnion<LayoutOptionsMap>\n    public readonly onPending: LayoutKindUnion<LayoutOptionsMap>\n\n    /**\n     * Creates a new instance.\n     *\n     * @param params The parameters.\n     * @param params.router The application's router instance.\n     * @param params.layoutsFactory The layout factory. Keys correspond to `kind` attribute of the layouts.\n     * @param params.onNotFound The ID of the layout to use when {@link Router.target$} cannot resolve the\n     * navigation path because it does not exist.\n     * @param params.onPending The ID of the layout to use when {@link Router.target$} cannot resolve the\n     * navigation path because navigation is currently resolving.\n     */\n    constructor(params: {\n        router: Router<LayoutUnion<LayoutOptionsMap>, THeader>\n        layoutsFactory: LayoutFactory<LayoutOptionsMap, THeader>\n        onNotFound: LayoutKindUnion<LayoutOptionsMap>\n        onPending: LayoutKindUnion<LayoutOptionsMap>\n    }) {\n        Object.assign(this, params)\n        const layout$ = this.router.target$.pipe(\n            map((target) => {\n                if (isResolvedTarget(target)) {\n                    return target.node.layout.kind\n                }\n                if (target.reason === 'Pending') {\n                    return this.onPending\n                }\n                return this.onNotFound\n            }),\n            distinctUntilChanged(),\n        )\n        this.children = [\n            child$({\n                source$: layout$,\n                vdomMap: (layoutKind) => {\n                    if (layoutKind in this.layoutsFactory) {\n                        type TLayoutOptions =\n                            LayoutOptionsMap[LayoutKindUnion<LayoutOptionsMap>]\n                        const view = this.layoutsFactory[\n                            layoutKind as LayoutKindUnion<LayoutOptionsMap>\n                        ]({\n                            router: this.router as unknown as Router<\n                                TLayoutOptions,\n                                THeader\n                            >,\n                        })\n                        return view instanceof HTMLElement\n                            ? { tag: 'div', children: [view] }\n                            : view\n                    }\n                    return new LayoutKindNotFoundView({\n                        unknownKey: layoutKind as string,\n                        availableKeys: Object.keys(this.layoutsFactory),\n                        path: this.router.parseUrl().path,\n                    })\n                },\n            }),\n        ]\n    }\n}",
                "startLine": 199,
                "endLine": 270,
                "references": {
                    "CompositeLayout": "@nav/api/MainModule.CompositeLayout",
                    "LayoutFactory": "@nav/api/MainModule.LayoutFactory",
                    "LayoutKindUnion": "@nav/api/MainModule.LayoutKindUnion",
                    "Router": "@nav/api/MainModule.Router",
                    "LayoutUnion": "@nav/api/MainModule.LayoutUnion",
                    "ChildrenLike": "/apps/@rx-vdom/doc/latest?nav=/api.ChildrenLike",
                    "VirtualDOM": "/apps/@rx-vdom/doc/latest?nav=/api.VirtualDOM"
                }
            },
            "semantic": {
                "role": "class",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "ConsoleReporter",
            "documentation": {
                "sections": [
                    {
                        "content": "Console-based log reporter.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "ConsoleReporter",
            "navPath": "@nav/api/MainModule.ConsoleReporter",
            "attributes": [],
            "callables": [
                {
                    "name": "log",
                    "documentation": {
                        "sections": [
                            {
                                "content": "Logs an entry to the designated output.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            },
                            {
                                "title": "Arguments",
                                "content": "\n*  **entry**: The log entry to be recorded.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "arguments",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "ConsoleReporter.log",
                    "navPath": "@nav/api/MainModule.ConsoleReporter.log",
                    "code": {
                        "filePath": "src/lib/context.ts",
                        "declaration": "log(entry: Entry)",
                        "implementation": "log(entry: Entry) {\n    const stack = entry.callstack.reduce((acc, e) => `${acc}.${e}`, '')\n    const prefix = entry.callstack.reduce((acc) => `${acc}\\t`, '')\n    const labels = [...new Set(entry.labels)].reduce(\n        (acc, e) => `${acc}#${e}`,\n        '',\n    )\n    const obj: { stack: string; data?: unknown } = { stack }\n    if (entry.data !== undefined) {\n        obj.data = entry.data\n    }\n    const text = `[@${entry.threadName}, ${labels}] ${prefix}${entry.text}`\n    if (entry.level == 'Info') {\n        console.log(text, obj)\n    }\n    if (entry.level == 'Warning') {\n        console.warn(text, obj)\n    }\n    if (entry.level == 'Error') {\n        console.error(text, obj)\n    }\n}",
                        "startLine": 73,
                        "endLine": 95,
                        "references": {
                            "log": "@nav/api/MainModule.ConsoleReporter.log",
                            "Entry": "@nav/api/MainModule.Entry"
                        }
                    },
                    "semantic": {
                        "role": "method",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    }
                }
            ],
            "code": {
                "filePath": "src/lib/context.ts",
                "declaration": "export class ConsoleReporter implements ReporterTrait",
                "implementation": "export class ConsoleReporter implements ReporterTrait {\n    log(entry: Entry) {\n        const stack = entry.callstack.reduce((acc, e) => `${acc}.${e}`, '')\n        const prefix = entry.callstack.reduce((acc) => `${acc}\\t`, '')\n        const labels = [...new Set(entry.labels)].reduce(\n            (acc, e) => `${acc}#${e}`,\n            '',\n        )\n        const obj: { stack: string; data?: unknown } = { stack }\n        if (entry.data !== undefined) {\n            obj.data = entry.data\n        }\n        const text = `[@${entry.threadName}, ${labels}] ${prefix}${entry.text}`\n        if (entry.level == 'Info') {\n            console.log(text, obj)\n        }\n        if (entry.level == 'Warning') {\n            console.warn(text, obj)\n        }\n        if (entry.level == 'Error') {\n            console.error(text, obj)\n        }\n    }\n}",
                "startLine": 72,
                "endLine": 96,
                "references": {
                    "ConsoleReporter": "@nav/api/MainModule.ConsoleReporter",
                    "Entry": "@nav/api/MainModule.Entry",
                    "ReporterTrait.log": "@nav/api/MainModule.ReporterTrait.log",
                    "ReporterTrait": "@nav/api/MainModule.ReporterTrait"
                }
            },
            "semantic": {
                "role": "class",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "Context",
            "documentation": {
                "sections": [
                    {
                        "content": "Context class that provides structured logging and execution tracking.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "Context",
            "navPath": "@nav/api/MainModule.Context",
            "attributes": [
                {
                    "name": "Enabled",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "To enable the decorator  [Contextual](@nav/api/MainModule.Contextual)  use  StaticConfig  with  `enableContextual: true` .",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "Context.Enabled",
                    "navPath": "@nav/api/MainModule.Context.Enabled",
                    "code": {
                        "filePath": "src/lib/context.ts",
                        "declaration": "static Enabled =\n        (window as unknown as WindowWithStaticConfig).mkdocsConfig\n            ?.enableContextual ?? false",
                        "implementation": "",
                        "startLine": 237,
                        "endLine": 238,
                        "references": {
                            "Enabled": "@nav/api/MainModule.Context.Enabled"
                        }
                    }
                }
            ],
            "callables": [
                {
                    "name": "error",
                    "documentation": {
                        "sections": [
                            {
                                "content": "Log with level  `Error` .",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "Context.error",
                    "navPath": "@nav/api/MainModule.Context.error",
                    "code": {
                        "filePath": "src/lib/context.ts",
                        "declaration": "error(text: string, data?: unknown)",
                        "implementation": "error(text: string, data?: unknown) {\n    this.reporters.forEach((reporter) => {\n        reporter.log(this.formatEntry('Error', text, data))\n    })\n}",
                        "startLine": 271,
                        "endLine": 276,
                        "references": {
                            "error": "@nav/api/MainModule.Context.error"
                        }
                    },
                    "semantic": {
                        "role": "method",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    }
                },
                {
                    "name": "execute",
                    "documentation": {
                        "sections": [
                            {
                                "content": "Execute a given function.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            },
                            {
                                "title": "Arguments",
                                "content": "\n*  **name**: Function's name.\n*  **meth**: Function.\n*  **labels**: Associated labels.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "arguments",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "Context.execute",
                    "navPath": "@nav/api/MainModule.Context.execute",
                    "code": {
                        "filePath": "src/lib/context.ts",
                        "declaration": "execute<TReturn>(\n    name: string,\n    meth: (context: ContextTrait) => TReturn,\n    labels?: Label[],\n): TReturn",
                        "implementation": "execute<TReturn>(\n    name: string,\n    meth: (context: ContextTrait) => TReturn,\n    labels?: Label[],\n): TReturn {\n    const ctx = this.start(name, labels)\n    const r = meth(ctx)\n    ctx.exit()\n    return r\n}",
                        "startLine": 290,
                        "endLine": 300,
                        "references": {
                            "execute": "@nav/api/MainModule.Context.execute",
                            "ContextTrait": "@nav/api/MainModule.ContextTrait",
                            "Label": "@nav/api/MainModule.Label"
                        }
                    },
                    "semantic": {
                        "role": "method",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    }
                },
                {
                    "name": "executeAsync",
                    "documentation": {
                        "sections": [
                            {
                                "content": "Execute a given async function.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            },
                            {
                                "title": "Arguments",
                                "content": "\n*  **name**: Function's name.\n*  **meth**: Async function.\n*  **labels**: Associated labels.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "arguments",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "Context.executeAsync",
                    "navPath": "@nav/api/MainModule.Context.executeAsync",
                    "code": {
                        "filePath": "src/lib/context.ts",
                        "declaration": "async executeAsync<TReturn>(\n    name: string,\n    meth: (context: ContextTrait) => Promise<TReturn>,\n    labels?: Label[],\n): Promise<TReturn>",
                        "implementation": "async executeAsync<TReturn>(\n    name: string,\n    meth: (context: ContextTrait) => Promise<TReturn>,\n    labels?: Label[],\n): Promise<TReturn> {\n    const ctx = this.start(name, labels)\n    const r = await meth(ctx)\n    ctx.exit()\n    return r\n}",
                        "startLine": 300,
                        "endLine": 310,
                        "references": {
                            "executeAsync": "@nav/api/MainModule.Context.executeAsync",
                            "ContextTrait": "@nav/api/MainModule.ContextTrait",
                            "Label": "@nav/api/MainModule.Label"
                        }
                    },
                    "semantic": {
                        "role": "method",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    }
                },
                {
                    "name": "exit",
                    "documentation": {
                        "sections": [
                            {
                                "content": "Trigger exit tasks.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "Context.exit",
                    "navPath": "@nav/api/MainModule.Context.exit",
                    "code": {
                        "filePath": "src/lib/context.ts",
                        "declaration": "exit()",
                        "implementation": "exit() {\n    if (this.onExit) {\n        this.onExit(this)\n    }\n}",
                        "startLine": 311,
                        "endLine": 316,
                        "references": {
                            "exit": "@nav/api/MainModule.Context.exit"
                        }
                    },
                    "semantic": {
                        "role": "method",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    }
                },
                {
                    "name": "info",
                    "documentation": {
                        "sections": [
                            {
                                "content": "Log with level  `Info` .",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "Context.info",
                    "navPath": "@nav/api/MainModule.Context.info",
                    "code": {
                        "filePath": "src/lib/context.ts",
                        "declaration": "info(text: string, data?: unknown)",
                        "implementation": "info(text: string, data?: unknown) {\n    this.reporters.forEach((reporter) => {\n        reporter.log(this.formatEntry('Info', text, data))\n    })\n}",
                        "startLine": 261,
                        "endLine": 266,
                        "references": {
                            "info": "@nav/api/MainModule.Context.info"
                        }
                    },
                    "semantic": {
                        "role": "method",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    }
                },
                {
                    "name": "start",
                    "documentation": {
                        "sections": [
                            {
                                "content": "Start a child context.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            },
                            {
                                "title": "Arguments",
                                "content": "\n*  **name**: Function's name.\n*  **labels**: Associated labels.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "arguments",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "Context.start",
                    "navPath": "@nav/api/MainModule.Context.start",
                    "code": {
                        "filePath": "src/lib/context.ts",
                        "declaration": "start(name: string, labels?: Label[])",
                        "implementation": "start(name: string, labels?: Label[]) {\n    const ctx = new Context({\n        reporters: this.reporters,\n        threadName: this.threadName,\n        parentId: this.id,\n        labels: [...this.labels, ...(labels ?? [])],\n        callstack: [...this.callstack, name],\n        onExit: (ctx) => {\n            ctx.info(`<${name}`)\n        },\n    })\n    ctx.info(`>${name}`)\n    return ctx\n}",
                        "startLine": 276,
                        "endLine": 290,
                        "references": {
                            "start": "@nav/api/MainModule.Context.start",
                            "Label": "@nav/api/MainModule.Label",
                            "Context": "@nav/api/MainModule.Context"
                        }
                    },
                    "semantic": {
                        "role": "method",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    }
                },
                {
                    "name": "warning",
                    "documentation": {
                        "sections": [
                            {
                                "content": "Log with level  `Warning` .",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "Context.warning",
                    "navPath": "@nav/api/MainModule.Context.warning",
                    "code": {
                        "filePath": "src/lib/context.ts",
                        "declaration": "warning(text: string, data?: unknown)",
                        "implementation": "warning(text: string, data?: unknown) {\n    this.reporters.forEach((reporter) => {\n        reporter.log(this.formatEntry('Warning', text, data))\n    })\n}",
                        "startLine": 266,
                        "endLine": 271,
                        "references": {
                            "warning": "@nav/api/MainModule.Context.warning"
                        }
                    },
                    "semantic": {
                        "role": "method",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    }
                }
            ],
            "code": {
                "filePath": "src/lib/context.ts",
                "declaration": "export class Context implements ContextTrait",
                "implementation": "export class Context implements ContextTrait {\n    /**\n     * To enable the decorator {@link Contextual} use {@link StaticConfig} with `enableContextual: true`.\n     */\n    static Enabled =\n        (window as unknown as WindowWithStaticConfig).mkdocsConfig\n            ?.enableContextual ?? false\n    public readonly reporters: ReporterTrait[]\n    public readonly labels: Label[]\n    public readonly threadName: string\n    public readonly callstack: string[]\n\n    public readonly id: string\n    public readonly parentId: string\n    public readonly onExit?: (ctx: ContextTrait) => void\n\n    constructor(params: {\n        reporters: ReporterTrait[]\n        labels: Label[]\n        threadName: string\n        callstack: string[]\n        parentId?: string\n        onExit?: (ctx: ContextTrait) => void\n    }) {\n        Object.assign(this, params)\n        this.id = String(Math.floor(Math.random() * 1e6))\n    }\n\n    info(text: string, data?: unknown) {\n        this.reporters.forEach((reporter) => {\n            reporter.log(this.formatEntry('Info', text, data))\n        })\n    }\n    warning(text: string, data?: unknown) {\n        this.reporters.forEach((reporter) => {\n            reporter.log(this.formatEntry('Warning', text, data))\n        })\n    }\n    error(text: string, data?: unknown) {\n        this.reporters.forEach((reporter) => {\n            reporter.log(this.formatEntry('Error', text, data))\n        })\n    }\n    start(name: string, labels?: Label[]) {\n        const ctx = new Context({\n            reporters: this.reporters,\n            threadName: this.threadName,\n            parentId: this.id,\n            labels: [...this.labels, ...(labels ?? [])],\n            callstack: [...this.callstack, name],\n            onExit: (ctx) => {\n                ctx.info(`<${name}`)\n            },\n        })\n        ctx.info(`>${name}`)\n        return ctx\n    }\n    execute<TReturn>(\n        name: string,\n        meth: (context: ContextTrait) => TReturn,\n        labels?: Label[],\n    ): TReturn {\n        const ctx = this.start(name, labels)\n        const r = meth(ctx)\n        ctx.exit()\n        return r\n    }\n    async executeAsync<TReturn>(\n        name: string,\n        meth: (context: ContextTrait) => Promise<TReturn>,\n        labels?: Label[],\n    ): Promise<TReturn> {\n        const ctx = this.start(name, labels)\n        const r = await meth(ctx)\n        ctx.exit()\n        return r\n    }\n\n    exit() {\n        if (this.onExit) {\n            this.onExit(this)\n        }\n    }\n    private formatEntry(level: Level, text: string, data?: unknown): Entry {\n        return {\n            threadName: this.threadName,\n            labels: this.labels,\n            callstack: this.callstack,\n            ctxId: this.id,\n            parentCtxId: this.parentId,\n            level,\n            text,\n            data,\n        }\n    }\n}",
                "startLine": 233,
                "endLine": 329,
                "references": {
                    "Context": "@nav/api/MainModule.Context",
                    "Label": "@nav/api/MainModule.Label",
                    "ContextTrait": "@nav/api/MainModule.ContextTrait",
                    "ReporterTrait": "@nav/api/MainModule.ReporterTrait",
                    "ContextTrait.error": "@nav/api/MainModule.ContextTrait.error",
                    "ContextTrait.execute": "@nav/api/MainModule.ContextTrait.execute",
                    "ContextTrait.executeAsync": "@nav/api/MainModule.ContextTrait.executeAsync",
                    "ContextTrait.exit": "@nav/api/MainModule.ContextTrait.exit",
                    "ContextTrait.info": "@nav/api/MainModule.ContextTrait.info",
                    "ContextTrait.start": "@nav/api/MainModule.ContextTrait.start",
                    "ContextTrait.warning": "@nav/api/MainModule.ContextTrait.warning"
                }
            },
            "semantic": {
                "role": "class",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "GlobalMarkdownViews",
            "documentation": {
                "sections": [
                    {
                        "content": "Provides a collection of global Markdown views that can be referenced when using  [parseMd](@nav/api/MainModule.parseMd) .\n\nCustom views are defined as functions with the following structure:\n- **Arguments**:\n  -  `elem` : The HTML element as declared in the Markdown file. You can access its raw text content using\n     `elem.textContent`  and its attributes using  `elem.getAttribute` .\n  -  `options` : An instance of  [MdParsingOptions](@nav/api/MainModule.MdParsingOptions) , providing additional context for parsing.\n- **Returns**: A  [ViewGenerator](@nav/api/MainModule.ViewGenerator)  that implements the corresponding behavior for the HTML element.\n\nThese views enable dynamic, reusable components to be seamlessly integrated into Markdown content.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "GlobalMarkdownViews",
            "navPath": "@nav/api/MainModule.GlobalMarkdownViews",
            "attributes": [
                {
                    "name": "factory",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "A static factory object containing pre-defined Markdown inline views.\n\nSee  [MdWidgets](@nav/api/MainModule/MdWidgets)  regarding implementations.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "GlobalMarkdownViews.factory",
                    "navPath": "@nav/api/MainModule.GlobalMarkdownViews.factory",
                    "code": {
                        "filePath": "src/lib/markdown.ts",
                        "declaration": "static factory: Record<string, ViewGenerator> = {\n        /**\n         * Transforms a `<code-snippet></code-snippet>` element into {@link CodeSnippetView}.\n         */\n        'code-snippet': (elem: HTMLElement) =>\n            CodeSnippetView.fromHTMLElement(elem),\n        /**\n         * Transforms a `<note></note>`  element into {@link NoteView}.\n         */\n        note: (...args) => NoteView.fromHTMLElement(...args),\n        /**\n         * Transforms a `<code-badges></code-badges>`  element into {@link CodeBadgesView}.\n         */\n        'code-badges': (elem: HTMLElement) =>\n            CodeBadgesView.fromHTMLElement(elem),\n    }",
                        "implementation": "",
                        "startLine": 160,
                        "endLine": 161,
                        "references": {
                            "factory": "@nav/api/MainModule.GlobalMarkdownViews.factory",
                            "ViewGenerator": "@nav/api/MainModule.ViewGenerator"
                        }
                    }
                }
            ],
            "callables": [],
            "code": {
                "filePath": "src/lib/markdown.ts",
                "declaration": "export class GlobalMarkdownViews",
                "implementation": "export class GlobalMarkdownViews {\n    /**\n     * A static factory object containing pre-defined Markdown inline views.\n     *\n     * See {@link MdWidgets} regarding implementations.\n     */\n    static factory: Record<string, ViewGenerator> = {\n        /**\n         * Transforms a `<code-snippet></code-snippet>` element into {@link CodeSnippetView}.\n         */\n        'code-snippet': (elem: HTMLElement) =>\n            CodeSnippetView.fromHTMLElement(elem),\n        /**\n         * Transforms a `<note></note>`  element into {@link NoteView}.\n         */\n        note: (...args) => NoteView.fromHTMLElement(...args),\n        /**\n         * Transforms a `<code-badges></code-badges>`  element into {@link CodeBadgesView}.\n         */\n        'code-badges': (elem: HTMLElement) =>\n            CodeBadgesView.fromHTMLElement(elem),\n    }\n}",
                "startLine": 154,
                "endLine": 177,
                "references": {
                    "GlobalMarkdownViews": "@nav/api/MainModule.GlobalMarkdownViews",
                    "ViewGenerator": "@nav/api/MainModule.ViewGenerator"
                }
            },
            "semantic": {
                "role": "class",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "InMemoryReporter",
            "documentation": {
                "sections": [
                    {
                        "content": "In-memory log storage for structured logging.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "InMemoryReporter",
            "navPath": "@nav/api/MainModule.InMemoryReporter",
            "attributes": [],
            "callables": [
                {
                    "name": "log",
                    "documentation": {
                        "sections": [
                            {
                                "content": "Logs an entry to the designated output.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            },
                            {
                                "title": "Arguments",
                                "content": "\n*  **entry**: The log entry to be recorded.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "arguments",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "InMemoryReporter.log",
                    "navPath": "@nav/api/MainModule.InMemoryReporter.log",
                    "code": {
                        "filePath": "src/lib/context.ts",
                        "declaration": "log(entry: Entry)",
                        "implementation": "log(entry: Entry) {\n    if (!(entry.ctxId in this.mapId)) {\n        const parent = this.mapId[entry.parentCtxId] ?? this.entries\n        const startEntry = {\n            name: entry.callstack.slice(-1)[0],\n            entries: [],\n        }\n        parent.push(startEntry)\n        this.mapId[entry.ctxId] = startEntry.entries\n    }\n    this.mapId[entry.ctxId].push(entry.text)\n}",
                        "startLine": 107,
                        "endLine": 119,
                        "references": {
                            "log": "@nav/api/MainModule.InMemoryReporter.log",
                            "Entry": "@nav/api/MainModule.Entry"
                        }
                    },
                    "semantic": {
                        "role": "method",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    }
                }
            ],
            "code": {
                "filePath": "src/lib/context.ts",
                "declaration": "export class InMemoryReporter implements ReporterTrait",
                "implementation": "export class InMemoryReporter implements ReporterTrait {\n    entries: InMemoryEntry[] = []\n    private mapId: Record<string, InMemoryEntry[]> = {}\n\n    log(entry: Entry) {\n        if (!(entry.ctxId in this.mapId)) {\n            const parent = this.mapId[entry.parentCtxId] ?? this.entries\n            const startEntry = {\n                name: entry.callstack.slice(-1)[0],\n                entries: [],\n            }\n            parent.push(startEntry)\n            this.mapId[entry.ctxId] = startEntry.entries\n        }\n        this.mapId[entry.ctxId].push(entry.text)\n    }\n}",
                "startLine": 103,
                "endLine": 120,
                "references": {
                    "InMemoryReporter": "@nav/api/MainModule.InMemoryReporter",
                    "Entry": "@nav/api/MainModule.Entry",
                    "ReporterTrait.log": "@nav/api/MainModule.ReporterTrait.log",
                    "ReporterTrait": "@nav/api/MainModule.ReporterTrait"
                }
            },
            "semantic": {
                "role": "class",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "LayoutKindNotFoundView",
            "documentation": {
                "sections": [
                    {
                        "content": "The view displayed when a layout's kind referenced in the  [Navigation](@nav/api/MainModule.Navigation)  is not found within\n [CompositeLayout](@nav/api/MainModule.CompositeLayout) 's factory.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "LayoutKindNotFoundView",
            "navPath": "@nav/api/MainModule.LayoutKindNotFoundView",
            "attributes": [
                {
                    "name": "children",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "Children of the element.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "LayoutKindNotFoundView.children",
                    "navPath": "@nav/api/MainModule.LayoutKindNotFoundView.children",
                    "code": {
                        "filePath": "src/lib/composite-layout.view.ts",
                        "declaration": "public readonly children: ChildrenLike",
                        "implementation": "",
                        "startLine": 278,
                        "endLine": 279,
                        "references": {
                            "children": "@nav/api/MainModule.LayoutKindNotFoundView.children",
                            "ChildrenLike": "/apps/@rx-vdom/doc/latest?nav=/api.ChildrenLike"
                        }
                    }
                },
                {
                    "name": "class",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "The class associated with the element, equivalent to the  `className`  property of  `HTMLElement` .",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "LayoutKindNotFoundView.class",
                    "navPath": "@nav/api/MainModule.LayoutKindNotFoundView.class",
                    "code": {
                        "filePath": "src/lib/composite-layout.view.ts",
                        "declaration": "public readonly class = LayoutKindNotFoundView.CssSelector",
                        "implementation": "",
                        "startLine": 279,
                        "endLine": 280,
                        "references": {
                            "class": "@nav/api/MainModule.LayoutKindNotFoundView.class"
                        }
                    }
                },
                {
                    "name": "tag",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "The tag of the element, equivalent to the  `tagName`  property of  `HTMLElement` .",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "LayoutKindNotFoundView.tag",
                    "navPath": "@nav/api/MainModule.LayoutKindNotFoundView.tag",
                    "code": {
                        "filePath": "src/lib/composite-layout.view.ts",
                        "declaration": "public readonly tag = 'div'",
                        "implementation": "",
                        "startLine": 277,
                        "endLine": 278,
                        "references": {
                            "tag": "@nav/api/MainModule.LayoutKindNotFoundView.tag"
                        }
                    }
                }
            ],
            "callables": [],
            "code": {
                "filePath": "src/lib/composite-layout.view.ts",
                "declaration": "export class LayoutKindNotFoundView implements VirtualDOM<'div'>",
                "implementation": "export class LayoutKindNotFoundView implements VirtualDOM<'div'> {\n    static readonly CssSelector = 'mkdocs-LayoutNotFoundView'\n    public readonly tag = 'div'\n    public readonly children: ChildrenLike\n    public readonly class = LayoutKindNotFoundView.CssSelector\n\n    constructor({\n        unknownKey,\n        availableKeys,\n        path,\n    }: {\n        unknownKey: string\n        availableKeys: string[]\n        path: string\n    }) {\n        const availableKeysStr = availableKeys.reduce(\n            (acc, key) => `${acc}\\n*  **${key}**`,\n            '',\n        )\n        this.children = [\n            parseMd({\n                src: `\n<note level=\"warning\" title=\"Unknown Layout\">\nThe provided layout key - **${unknownKey}** - for node \\`${path}\\` is not part of the registered ones:\n${availableKeysStr}\n</note>                \n                `,\n            }),\n        ]\n    }\n}",
                "startLine": 275,
                "endLine": 306,
                "references": {
                    "LayoutKindNotFoundView": "@nav/api/MainModule.LayoutKindNotFoundView",
                    "ChildrenLike": "/apps/@rx-vdom/doc/latest?nav=/api.ChildrenLike",
                    "VirtualDOM": "/apps/@rx-vdom/doc/latest?nav=/api.VirtualDOM"
                }
            },
            "semantic": {
                "role": "class",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "MockBrowser",
            "documentation": {
                "sections": [
                    {
                        "content": "Implements the  [BrowserInterface](@nav/api/MainModule.BrowserInterface)  for managing browser navigation within a mocked browser.\n\n<note level=\"warning\">\nNavigation events triggered by a 'scroll' to section ID are not persisted in history: only change in navigation path\nare.\n</note>",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "MockBrowser",
            "navPath": "@nav/api/MainModule.MockBrowser",
            "attributes": [],
            "callables": [
                {
                    "name": "next",
                    "documentation": {
                        "sections": [
                            {
                                "content": "Navigate forth in browser's history.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "MockBrowser.next",
                    "navPath": "@nav/api/MainModule.MockBrowser.next",
                    "code": {
                        "filePath": "src/lib/browser.interface.ts",
                        "declaration": "async next()",
                        "implementation": "async next() {\n    if (this.currentIndex < this.history.length - 1) {\n        this.currentIndex++\n        await this.router.navigateTo({\n            ...this.history[this.currentIndex],\n            issuer: 'browser',\n        })\n    }\n}",
                        "startLine": 220,
                        "endLine": 229,
                        "references": {
                            "next": "@nav/api/MainModule.MockBrowser.next"
                        }
                    },
                    "semantic": {
                        "role": "method",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    }
                },
                {
                    "name": "parseUrl",
                    "documentation": {
                        "sections": [
                            {
                                "content": "Retrieves the target from the current URL.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            },
                            {
                                "title": "Returns",
                                "content": "The current navigation path as a string.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "returns",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "MockBrowser.parseUrl",
                    "navPath": "@nav/api/MainModule.MockBrowser.parseUrl",
                    "code": {
                        "filePath": "src/lib/browser.interface.ts",
                        "declaration": "parseUrl(): UrlTarget",
                        "implementation": "parseUrl(): UrlTarget {\n    const target =\n        this.history.length > 0\n            ? this.history.slice(-1)[0]\n            : parseUrl(this.initialPath)\n    return {\n        ...target,\n        issuer: 'browser',\n    }\n}",
                        "startLine": 229,
                        "endLine": 239,
                        "references": {
                            "parseUrl": "@nav/api/MainModule.MockBrowser.parseUrl",
                            "UrlTarget": "@nav/api/MainModule.UrlTarget"
                        }
                    },
                    "semantic": {
                        "role": "method",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    }
                },
                {
                    "name": "prev",
                    "documentation": {
                        "sections": [
                            {
                                "content": "Navigate back in browser's history.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "MockBrowser.prev",
                    "navPath": "@nav/api/MainModule.MockBrowser.prev",
                    "code": {
                        "filePath": "src/lib/browser.interface.ts",
                        "declaration": "async prev()",
                        "implementation": "async prev() {\n    if (this.currentIndex > 0) {\n        this.currentIndex--\n        await this.router.navigateTo({\n            ...this.history[this.currentIndex],\n            issuer: 'browser',\n        })\n    }\n}",
                        "startLine": 208,
                        "endLine": 217,
                        "references": {
                            "prev": "@nav/api/MainModule.MockBrowser.prev"
                        }
                    },
                    "semantic": {
                        "role": "method",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    }
                },
                {
                    "name": "pushState",
                    "documentation": {
                        "sections": [
                            {
                                "content": "Pushes a new state to the browser's history stack.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            },
                            {
                                "title": "Arguments",
                                "content": "\n*  **data**: The state data to associate with the history entry, including the navigation path.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "arguments",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "MockBrowser.pushState",
                    "navPath": "@nav/api/MainModule.MockBrowser.pushState",
                    "code": {
                        "filePath": "src/lib/browser.interface.ts",
                        "declaration": "@Contextual({\n    key: ({ target }: { target: UrlTarget }) =>\n        `${target.path}.${target.sectionId ?? ''}`,\n    labels: ['Browser'],\n})\npushState(data: { target: UrlTarget }): void",
                        "implementation": "@Contextual({\n    key: ({ target }: { target: UrlTarget }) =>\n        `${target.path}.${target.sectionId ?? ''}`,\n    labels: ['Browser'],\n})\npushState(data: { target: UrlTarget }): void {\n    if (['browser', 'scroll'].includes(data.target.issuer ?? '')) {\n        this.updateState()\n        return\n    }\n    if (\n        JSON.stringify(this.history[this.currentIndex]) ===\n        JSON.stringify(data.target)\n    ) {\n        this.updateState()\n        return\n    }\n    if (this.currentIndex === this.history.length - 1) {\n        this.history.push(data.target)\n        this.currentIndex++\n    } else {\n        this.currentIndex++\n        this.history[this.currentIndex] = data.target\n        this.history = this.history.slice(0, this.currentIndex + 1)\n    }\n    this.updateState()\n}",
                        "startLine": 178,
                        "endLine": 205,
                        "references": {
                            "pushState": "@nav/api/MainModule.MockBrowser.pushState",
                            "UrlTarget": "@nav/api/MainModule.UrlTarget"
                        }
                    },
                    "semantic": {
                        "role": "method",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    }
                }
            ],
            "code": {
                "filePath": "src/lib/browser.interface.ts",
                "declaration": "export class MockBrowser implements BrowserInterface",
                "implementation": "export class MockBrowser implements BrowserInterface {\n    public readonly router: Router\n    public readonly initialPath: string = '/'\n    public history: UrlTarget[] = []\n    public currentIndex = -1\n    public readonly hasNext$ = new BehaviorSubject(false)\n    public readonly hasPrev$ = new BehaviorSubject(false)\n    constructor(params: { router: Router; initialPath?: string }) {\n        Object.assign(this, params)\n        this.history.push(this.parseUrl())\n        this.currentIndex = 0\n    }\n\n    @Contextual({\n        key: ({ target }: { target: UrlTarget }) =>\n            `${target.path}.${target.sectionId ?? ''}`,\n        labels: ['Browser'],\n    })\n    pushState(data: { target: UrlTarget }): void {\n        if (['browser', 'scroll'].includes(data.target.issuer ?? '')) {\n            this.updateState()\n            return\n        }\n        if (\n            JSON.stringify(this.history[this.currentIndex]) ===\n            JSON.stringify(data.target)\n        ) {\n            this.updateState()\n            return\n        }\n        if (this.currentIndex === this.history.length - 1) {\n            this.history.push(data.target)\n            this.currentIndex++\n        } else {\n            this.currentIndex++\n            this.history[this.currentIndex] = data.target\n            this.history = this.history.slice(0, this.currentIndex + 1)\n        }\n        this.updateState()\n    }\n    private updateState() {\n        this.hasPrev$.next(this.currentIndex !== 0)\n        this.hasNext$.next(this.currentIndex < this.history.length - 1)\n    }\n\n    /**\n     * Navigate back in browser's history.\n     */\n    async prev() {\n        if (this.currentIndex > 0) {\n            this.currentIndex--\n            await this.router.navigateTo({\n                ...this.history[this.currentIndex],\n                issuer: 'browser',\n            })\n        }\n    }\n    /**\n     * Navigate forth in browser's history.\n     */\n    async next() {\n        if (this.currentIndex < this.history.length - 1) {\n            this.currentIndex++\n            await this.router.navigateTo({\n                ...this.history[this.currentIndex],\n                issuer: 'browser',\n            })\n        }\n    }\n    parseUrl(): UrlTarget {\n        const target =\n            this.history.length > 0\n                ? this.history.slice(-1)[0]\n                : parseUrl(this.initialPath)\n        return {\n            ...target,\n            issuer: 'browser',\n        }\n    }\n}",
                "startLine": 160,
                "endLine": 240,
                "references": {
                    "MockBrowser": "@nav/api/MainModule.MockBrowser",
                    "Router": "@nav/api/MainModule.Router",
                    "UrlTarget": "@nav/api/MainModule.UrlTarget",
                    "BrowserInterface.parseUrl": "@nav/api/MainModule.BrowserInterface.parseUrl",
                    "BrowserInterface.pushState": "@nav/api/MainModule.BrowserInterface.pushState",
                    "BrowserInterface": "@nav/api/MainModule.BrowserInterface",
                    "BehaviorSubject": "https://www.learnrxjs.io/learn-rxjs/subjects/subject"
                }
            },
            "semantic": {
                "role": "class",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "NoContext",
            "documentation": {
                "sections": [
                    {
                        "content": "A no-operation implementation of ContextTrait.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "NoContext",
            "navPath": "@nav/api/MainModule.NoContext",
            "attributes": [],
            "callables": [
                {
                    "name": "error",
                    "documentation": {
                        "sections": [
                            {
                                "content": "Log with level  `Error` .",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "NoContext.error",
                    "navPath": "@nav/api/MainModule.NoContext.error",
                    "code": {
                        "filePath": "src/lib/context.ts",
                        "declaration": "error()",
                        "implementation": "error() {\n    /*No OP*/\n}",
                        "startLine": 205,
                        "endLine": 208,
                        "references": {
                            "error": "@nav/api/MainModule.NoContext.error"
                        }
                    },
                    "semantic": {
                        "role": "method",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    }
                },
                {
                    "name": "execute",
                    "documentation": {
                        "sections": [
                            {
                                "content": "Execute a given function.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            },
                            {
                                "title": "Arguments",
                                "content": "\n*  **meth**: Function.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "arguments",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "NoContext.execute",
                    "navPath": "@nav/api/MainModule.NoContext.execute",
                    "code": {
                        "filePath": "src/lib/context.ts",
                        "declaration": "execute<TReturn>(\n    _name: string,\n    meth: (context: ContextTrait) => TReturn,\n    _labels?: Label[],\n): TReturn",
                        "implementation": "execute<TReturn>(\n    _name: string,\n    meth: (context: ContextTrait) => TReturn,\n    _labels?: Label[],\n): TReturn {\n    return meth(this)\n}",
                        "startLine": 209,
                        "endLine": 216,
                        "references": {
                            "execute": "@nav/api/MainModule.NoContext.execute",
                            "ContextTrait": "@nav/api/MainModule.ContextTrait",
                            "Label": "@nav/api/MainModule.Label"
                        }
                    },
                    "semantic": {
                        "role": "method",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    }
                },
                {
                    "name": "executeAsync",
                    "documentation": {
                        "sections": [
                            {
                                "content": "Execute a given async function.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            },
                            {
                                "title": "Arguments",
                                "content": "\n*  **meth**: Async function.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "arguments",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "NoContext.executeAsync",
                    "navPath": "@nav/api/MainModule.NoContext.executeAsync",
                    "code": {
                        "filePath": "src/lib/context.ts",
                        "declaration": "async executeAsync<TReturn>(\n    _name: string,\n    meth: (context: ContextTrait) => Promise<TReturn>,\n    _labels?: Label[],\n): Promise<TReturn>",
                        "implementation": "async executeAsync<TReturn>(\n    _name: string,\n    meth: (context: ContextTrait) => Promise<TReturn>,\n    _labels?: Label[],\n): Promise<TReturn> {\n    return meth(this)\n}",
                        "startLine": 216,
                        "endLine": 223,
                        "references": {
                            "executeAsync": "@nav/api/MainModule.NoContext.executeAsync",
                            "ContextTrait": "@nav/api/MainModule.ContextTrait",
                            "Label": "@nav/api/MainModule.Label"
                        }
                    },
                    "semantic": {
                        "role": "method",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    }
                },
                {
                    "name": "exit",
                    "documentation": {
                        "sections": [
                            {
                                "content": "Trigger exit tasks.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "NoContext.exit",
                    "navPath": "@nav/api/MainModule.NoContext.exit",
                    "code": {
                        "filePath": "src/lib/context.ts",
                        "declaration": "exit(): void",
                        "implementation": "exit(): void {\n    /*No OP*/\n}",
                        "startLine": 226,
                        "endLine": 229,
                        "references": {
                            "exit": "@nav/api/MainModule.NoContext.exit"
                        }
                    },
                    "semantic": {
                        "role": "method",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    }
                },
                {
                    "name": "info",
                    "documentation": {
                        "sections": [
                            {
                                "content": "Log with level  `Info` .",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "NoContext.info",
                    "navPath": "@nav/api/MainModule.NoContext.info",
                    "code": {
                        "filePath": "src/lib/context.ts",
                        "declaration": "info()",
                        "implementation": "info() {\n    /*No OP*/\n}",
                        "startLine": 199,
                        "endLine": 202,
                        "references": {
                            "info": "@nav/api/MainModule.NoContext.info"
                        }
                    },
                    "semantic": {
                        "role": "method",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    }
                },
                {
                    "name": "start",
                    "documentation": {
                        "sections": [
                            {
                                "content": "Start a child context.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "NoContext.start",
                    "navPath": "@nav/api/MainModule.NoContext.start",
                    "code": {
                        "filePath": "src/lib/context.ts",
                        "declaration": "start(_name: string, _labels?: Label[]): ContextTrait",
                        "implementation": "start(_name: string, _labels?: Label[]): ContextTrait {\n    return this\n}",
                        "startLine": 223,
                        "endLine": 226,
                        "references": {
                            "start": "@nav/api/MainModule.NoContext.start",
                            "Label": "@nav/api/MainModule.Label",
                            "ContextTrait": "@nav/api/MainModule.ContextTrait"
                        }
                    },
                    "semantic": {
                        "role": "method",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    }
                },
                {
                    "name": "warning",
                    "documentation": {
                        "sections": [
                            {
                                "content": "Log with level  `Warning` .",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "NoContext.warning",
                    "navPath": "@nav/api/MainModule.NoContext.warning",
                    "code": {
                        "filePath": "src/lib/context.ts",
                        "declaration": "warning()",
                        "implementation": "warning() {\n    /*No OP*/\n}",
                        "startLine": 202,
                        "endLine": 205,
                        "references": {
                            "warning": "@nav/api/MainModule.NoContext.warning"
                        }
                    },
                    "semantic": {
                        "role": "method",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    }
                }
            ],
            "code": {
                "filePath": "src/lib/context.ts",
                "declaration": "export class NoContext implements ContextTrait",
                "implementation": "export class NoContext implements ContextTrait {\n    info() {\n        /*No OP*/\n    }\n    warning() {\n        /*No OP*/\n    }\n    error() {\n        /*No OP*/\n    }\n\n    execute<TReturn>(\n        _name: string,\n        meth: (context: ContextTrait) => TReturn,\n        _labels?: Label[],\n    ): TReturn {\n        return meth(this)\n    }\n    async executeAsync<TReturn>(\n        _name: string,\n        meth: (context: ContextTrait) => Promise<TReturn>,\n        _labels?: Label[],\n    ): Promise<TReturn> {\n        return meth(this)\n    }\n    start(_name: string, _labels?: Label[]): ContextTrait {\n        return this\n    }\n    exit(): void {\n        /*No OP*/\n    }\n}",
                "startLine": 198,
                "endLine": 230,
                "references": {
                    "NoContext": "@nav/api/MainModule.NoContext",
                    "ContextTrait.error": "@nav/api/MainModule.ContextTrait.error",
                    "ContextTrait": "@nav/api/MainModule.ContextTrait",
                    "Label": "@nav/api/MainModule.Label",
                    "ContextTrait.execute": "@nav/api/MainModule.ContextTrait.execute",
                    "ContextTrait.executeAsync": "@nav/api/MainModule.ContextTrait.executeAsync",
                    "ContextTrait.exit": "@nav/api/MainModule.ContextTrait.exit",
                    "ContextTrait.info": "@nav/api/MainModule.ContextTrait.info",
                    "ContextTrait.start": "@nav/api/MainModule.ContextTrait.start",
                    "ContextTrait.warning": "@nav/api/MainModule.ContextTrait.warning"
                }
            },
            "semantic": {
                "role": "class",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "Router",
            "documentation": {
                "sections": [
                    {
                        "content": "Represents the router of the application.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "Router",
            "navPath": "@nav/api/MainModule.Router",
            "attributes": [
                {
                    "name": "basePath",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "The base path on which the router is defined.\n\nIf the application is served from  `https://my-domain/my-app/version`  it is  `/my-app/version` .",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "Router.basePath",
                    "navPath": "@nav/api/MainModule.Router.basePath",
                    "code": {
                        "filePath": "src/lib/router.ts",
                        "declaration": "public readonly basePath: string",
                        "implementation": "",
                        "startLine": 145,
                        "endLine": 146,
                        "references": {
                            "basePath": "@nav/api/MainModule.Router.basePath"
                        }
                    }
                },
                {
                    "name": "browserClient",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "Browser client, see  [WebBrowser](@nav/api/MainModule.WebBrowser)  for regular scenario (library running within a tab of a web browser).",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "Router.browserClient",
                    "navPath": "@nav/api/MainModule.Router.browserClient",
                    "code": {
                        "filePath": "src/lib/router.ts",
                        "declaration": "public readonly browserClient: BrowserInterface",
                        "implementation": "",
                        "startLine": 219,
                        "endLine": 220,
                        "references": {
                            "browserClient": "@nav/api/MainModule.Router.browserClient",
                            "BrowserInterface": "@nav/api/MainModule.BrowserInterface"
                        }
                    }
                },
                {
                    "name": "explorerState",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "Encapsulates the state of the navigation view (node selected, expanded, *etc.*)",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "Router.explorerState",
                    "navPath": "@nav/api/MainModule.Router.explorerState",
                    "code": {
                        "filePath": "src/lib/router.ts",
                        "declaration": "public readonly explorerState: ImmutableTree.State<\n        AnyNavNode<TLayout, THeader>\n    >",
                        "implementation": "",
                        "startLine": 195,
                        "endLine": 196,
                        "references": {
                            "explorerState": "@nav/api/MainModule.Router.explorerState",
                            "AnyNavNode": "@nav/api/MainModule.AnyNavNode"
                        }
                    }
                },
                {
                    "name": "navigation",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "Definition of the navigation.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "Router.navigation",
                    "navPath": "@nav/api/MainModule.Router.navigation",
                    "code": {
                        "filePath": "src/lib/router.ts",
                        "declaration": "public readonly navigation: Navigation<TLayout, THeader>",
                        "implementation": "",
                        "startLine": 157,
                        "endLine": 158,
                        "references": {
                            "navigation": "@nav/api/MainModule.Router.navigation",
                            "Navigation": "@nav/api/MainModule.Navigation"
                        }
                    }
                },
                {
                    "name": "path$",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "Observable that emit the current navigation path.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "Router.path$",
                    "navPath": "@nav/api/MainModule.Router.path$",
                    "code": {
                        "filePath": "src/lib/router.ts",
                        "declaration": "public readonly path$: ReplaySubject<string> = new ReplaySubject<string>(1)",
                        "implementation": "",
                        "startLine": 190,
                        "endLine": 191,
                        "references": {
                            "path$": "@nav/api/MainModule.Router.path$",
                            "ReplaySubject": "https://www.learnrxjs.io/learn-rxjs/subjects/replaysubject"
                        }
                    }
                },
                {
                    "name": "redirects",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "Handles navigation redirections.\n\nThese functions are invoked whenever a specific path is requested for navigation.\nIt allows modifying the target path before the navigation occurs.\n\nFunctions are evaluated in reversed order, if one returns  `undefined` , navigation is canceled.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "Router.redirects",
                    "navPath": "@nav/api/MainModule.Router.redirects",
                    "code": {
                        "filePath": "src/lib/router.ts",
                        "declaration": "public readonly redirects: Redirect[] = [\n        (target) => Promise.resolve(target),\n    ]",
                        "implementation": "",
                        "startLine": 176,
                        "endLine": 177,
                        "references": {
                            "redirects": "@nav/api/MainModule.Router.redirects",
                            "Redirect": "@nav/api/MainModule.Redirect"
                        }
                    }
                },
                {
                    "name": "retryNavPeriod",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "When using a dynamic definition of the routes (see  [Navigation](@nav/api/MainModule.Navigation) ),\nit may be the case that the routes are not yet available when navigating to a page.\nAttempt to re-navigate to the page is executed every  `retryNavPeriod`  second.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "Router.retryNavPeriod",
                    "navPath": "@nav/api/MainModule.Router.retryNavPeriod",
                    "code": {
                        "filePath": "src/lib/router.ts",
                        "declaration": "public readonly retryNavPeriod: number = 1000",
                        "implementation": "",
                        "startLine": 152,
                        "endLine": 153,
                        "references": {
                            "retryNavPeriod": "@nav/api/MainModule.Router.retryNavPeriod"
                        }
                    }
                },
                {
                    "name": "scrollingDebounceTime",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "Debounced time applied when scrolling to specific target is triggered.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "Router.scrollingDebounceTime",
                    "navPath": "@nav/api/MainModule.Router.scrollingDebounceTime",
                    "code": {
                        "filePath": "src/lib/router.ts",
                        "declaration": "public readonly scrollingDebounceTime: number = 100",
                        "implementation": "",
                        "startLine": 162,
                        "endLine": 163,
                        "references": {
                            "scrollingDebounceTime": "@nav/api/MainModule.Router.scrollingDebounceTime"
                        }
                    }
                },
                {
                    "name": "target$",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "Observable that emit the current page target.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "Router.target$",
                    "navPath": "@nav/api/MainModule.Router.target$",
                    "code": {
                        "filePath": "src/lib/router.ts",
                        "declaration": "public readonly target$: ReplaySubject<\n        Target<TLayout, THeader> | UnresolvedTarget\n    > = new ReplaySubject<Target<TLayout, THeader> | UnresolvedTarget>(1)",
                        "implementation": "",
                        "startLine": 183,
                        "endLine": 184,
                        "references": {
                            "target$": "@nav/api/MainModule.Router.target$",
                            "Target": "@nav/api/MainModule.Target",
                            "UnresolvedTarget": "@nav/api/MainModule.UnresolvedTarget",
                            "ReplaySubject": "https://www.learnrxjs.io/learn-rxjs/subjects/replaysubject"
                        }
                    }
                },
                {
                    "name": "userStore",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "Storage attribute for user data.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "Router.userStore",
                    "navPath": "@nav/api/MainModule.Router.userStore",
                    "code": {
                        "filePath": "src/lib/router.ts",
                        "declaration": "public readonly userStore?: unknown",
                        "implementation": "",
                        "startLine": 211,
                        "endLine": 212,
                        "references": {
                            "userStore": "@nav/api/MainModule.Router.userStore"
                        }
                    }
                }
            ],
            "callables": [
                {
                    "name": "Router",
                    "documentation": {
                        "sections": [
                            {
                                "content": "Initialize a router instance.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            },
                            {
                                "title": "Arguments",
                                "content": "\n*  **params**: See corresponding documentation in the class's attributes.\n*  **basePath**: Deprecated should not be used.\n*  **browserClient**: See  [BrowserInterface](@nav/api/MainModule.BrowserInterface) .\n*  **navigation**: See  [Router.navigation](@nav/api/MainModule.Router.navigation) .\n*  **redirects**: See  [Router.redirects](@nav/api/MainModule.Router.redirects) .\n*  **retryNavPeriod**: See  [Router.retryNavPeriod](@nav/api/MainModule.Router.retryNavPeriod) .\n*  **scrollingDebounceTime**: See  [Router.scrollingDebounceTime](@nav/api/MainModule.Router.scrollingDebounceTime) .\n*  **userStore**: See  [Router.userStore](@nav/api/MainModule.Router.userStore) .\n*  **ctx**: Execution context used for logging and tracing.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "arguments",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "Router.Router",
                    "navPath": "@nav/api/MainModule.Router.constructor",
                    "code": {
                        "filePath": "src/lib/router.ts",
                        "declaration": "constructor(\n    params: {\n        navigation: Navigation<TLayout, THeader>\n        basePath?: string\n        retryNavPeriod?: number\n        redirects?: Redirect[]\n        browserClient?: (\n            p: {\n                router: Router\n                basePath: string\n            },\n            ctx?: ContextTrait,\n        ) => BrowserInterface\n        scrollingDebounceTime?: number\n        userStore?: unknown\n    },\n    ctx?: ContextTrait,\n)",
                        "implementation": "constructor(\n    params: {\n        navigation: Navigation<TLayout, THeader>\n        basePath?: string\n        retryNavPeriod?: number\n        redirects?: Redirect[]\n        browserClient?: (\n            p: {\n                router: Router\n                basePath: string\n            },\n            ctx?: ContextTrait,\n        ) => BrowserInterface\n        scrollingDebounceTime?: number\n        userStore?: unknown\n    },\n    ctx?: ContextTrait,\n) {\n    Object.assign(this, params)\n    this.context = ctx\n    const context = this.ctx().start('new Router', ['Router'])\n    this.basePath = this.basePath || document.location.pathname\n    this.browserClient = params.browserClient\n        ? params.browserClient({ router: this, basePath: this.basePath })\n        : new WebBrowser({ router: this, basePath: this.basePath }, context)\n\n    const { rootNode, reactiveNavs, promiseNavs } =\n        this.navParser.createRootNode(\n            {\n                navigation: this.navigation,\n                router: this,\n            },\n            context,\n        )\n    this.explorerState = new ImmutableTree.State({\n        rootNode,\n        expandedNodes: ['/'],\n    })\n    this.bindReactiveNavs(reactiveNavs, context)\n    this.bindPromiseNavs(promiseNavs, context)\n\n    this.target$\n        .pipe(\n            filter((page) => {\n                return isResolvedTarget(page)\n            }),\n        )\n        .subscribe((page) => {\n            if (page.sectionId === undefined) {\n                this.scrollTo()\n            }\n        })\n    fireAndForget(this.navigateTo(this.parseUrl(), context))\n\n    const removedNodes$ = this.explorerState.directUpdates$.pipe(\n        map((updates) =>\n            updates.map((update) => update.removedNodes).flat(),\n        ),\n        filter((nodes) => nodes.length > 0),\n    )\n    removedNodes$\n        .pipe(\n            withLatestFrom(this.target$),\n            filter(([nodes, target]) => {\n                return (\n                    nodes.find((node) =>\n                        target.path.startsWith(node.href),\n                    ) !== undefined\n                )\n            }),\n        )\n        .subscribe(([, target]) => {\n            context.info('Node parent of current path removed')\n            this.fireNavigateTo(target, undefined, context)\n        })\n    const scroll$ =\n        this.scrollingDebounceTime > 0\n            ? this.scrollTo$.pipe(debounceTime(this.scrollingDebounceTime))\n            : this.scrollTo$\n    scroll$.subscribe((target) => {\n        this._scrollTo(target)\n    })\n\n    removedNodes$.subscribe(() => {\n        this.navNodeCache = {}\n    })\n    this.target$.pipe(filter((t) => isResolvedTarget(t))).subscribe((t) => {\n        this.navNodeCache[t.path] = t.node\n        this.scrollTo(t.sectionId)\n    })\n    context.exit()\n}",
                        "startLine": 239,
                        "endLine": 331,
                        "references": {
                            "Router": "@nav/api/MainModule.Router",
                            "ContextTrait": "@nav/api/MainModule.ContextTrait",
                            "BrowserInterface": "@nav/api/MainModule.BrowserInterface",
                            "Navigation": "@nav/api/MainModule.Navigation",
                            "Redirect": "@nav/api/MainModule.Redirect"
                        }
                    },
                    "semantic": {
                        "role": "constructor",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    }
                },
                {
                    "name": "emitHtmlUpdated",
                    "documentation": {
                        "sections": [
                            {
                                "content": "Clients need to invoke this function when dynamic change on the current main HTML page have occurred after the\ninitial rendering. Other views dependening on it (*e.g.* the table of content) will refresh as well.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "Router.emitHtmlUpdated",
                    "navPath": "@nav/api/MainModule.Router.emitHtmlUpdated",
                    "code": {
                        "filePath": "src/lib/router.ts",
                        "declaration": "emitHtmlUpdated()",
                        "implementation": "emitHtmlUpdated() {\n    this.htmlUpdated$.next(true)\n}",
                        "startLine": 696,
                        "endLine": 699,
                        "references": {
                            "emitHtmlUpdated": "@nav/api/MainModule.Router.emitHtmlUpdated"
                        }
                    },
                    "semantic": {
                        "role": "method",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    }
                },
                {
                    "name": "fireNavigateTo",
                    "documentation": {
                        "sections": [
                            {
                                "content": "Fire navigation to given path with no  `await` .",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            },
                            {
                                "title": "Arguments",
                                "content": "\n*  **target**: The path to navigate to.\nIf a string is provided, a  [UrlTarget](@nav/api/MainModule.UrlTarget)  is constructed using  [parseUrl](@nav/api/MainModule.parseUrl) .\n*  **onError**: Callback called if errors happen.\n*  **ctx**: Execution context used for logging and tracing.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "arguments",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "Router.fireNavigateTo",
                    "navPath": "@nav/api/MainModule.Router.fireNavigateTo",
                    "code": {
                        "filePath": "src/lib/router.ts",
                        "declaration": "@Contextual({\n    key: (target: UrlTarget | string) =>\n        typeof target === 'string' ? target : target.path,\n})\nfireNavigateTo(\n    target: UrlTarget | string,\n    onError?: (err: unknown) => void,\n    ctx?: ContextTrait,\n)",
                        "implementation": "@Contextual({\n    key: (target: UrlTarget | string) =>\n        typeof target === 'string' ? target : target.path,\n})\nfireNavigateTo(\n    target: UrlTarget | string,\n    onError?: (err: unknown) => void,\n    ctx?: ContextTrait,\n) {\n    fireAndForget(this.navigateTo(target, ctx), onError)\n}",
                        "startLine": 357,
                        "endLine": 368,
                        "references": {
                            "fireNavigateTo": "@nav/api/MainModule.Router.fireNavigateTo",
                            "UrlTarget": "@nav/api/MainModule.UrlTarget",
                            "ContextTrait": "@nav/api/MainModule.ContextTrait"
                        }
                    },
                    "semantic": {
                        "role": "method",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    }
                },
                {
                    "name": "getNav",
                    "documentation": {
                        "sections": [
                            {
                                "content": "Asynchronously retrieves the navigation node for a given path.\nIf the node is not immediately available, it will retry for a short period before returning a result.\n\n- If the node is found, it returns the corresponding  `Navigation<TLayout, THeader>`  object.\n- If the node does not exist, it returns  `'not-found'` .\n- If the node is still unresolved, it waits and retries periodically.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            },
                            {
                                "title": "Arguments",
                                "content": "\n*  **target**: The target.\n*  **ctx**: Execution context used for logging and tracing.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "arguments",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            },
                            {
                                "title": "Returns",
                                "content": "A  `Promise`  resolving to the navigation node, or  `'not-found'`  if the node does not exist.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "returns",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "Router.getNav",
                    "navPath": "@nav/api/MainModule.Router.getNav",
                    "code": {
                        "filePath": "src/lib/router.ts",
                        "declaration": "@Contextual({\n    key: ({ path }: { path: string }) => path,\n    async: true,\n})\nasync getNav(\n    target: UrlTarget,\n    ctx?: ContextTrait,\n): Promise<Navigation<TLayout, THeader> | 'not-found'>",
                        "implementation": "@Contextual({\n    key: ({ path }: { path: string }) => path,\n    async: true,\n})\nasync getNav(\n    target: UrlTarget,\n    ctx?: ContextTrait,\n): Promise<Navigation<TLayout, THeader> | 'not-found'> {\n    ctx = this.ctx(ctx)\n    const { path, parameters } = target\n    if (\n        path in this.navNodeCache &&\n        Object.keys(parameters ?? {}).length === 0\n    ) {\n        ctx.info(\n            `No query parameters & node in cache => return it`,\n            this.navNodeCache[path],\n        )\n        return this.navNodeCache[path]\n    }\n    const nav = timer(0, this.retryNavPeriod).pipe(\n        switchMap((i) => {\n            ctx.info(`Attempt 'getNav' #${String(i)}`)\n            const nav = this._getNav({ path }, ctx)\n            if (nav instanceof Observable) {\n                return nav\n            }\n            return of(nav)\n        }),\n        tap((nav) => {\n            if (nav === 'unresolved') {\n                console.log('Try to wait...')\n                this.target$.next({\n                    path,\n                    reason: 'Pending',\n                })\n            }\n        }),\n        filter((nav) => nav !== 'unresolved'),\n        take(1),\n    )\n    return await firstValueFrom(nav)\n}",
                        "startLine": 516,
                        "endLine": 559,
                        "references": {
                            "getNav": "@nav/api/MainModule.Router.getNav",
                            "UrlTarget": "@nav/api/MainModule.UrlTarget",
                            "ContextTrait": "@nav/api/MainModule.ContextTrait",
                            "Navigation": "@nav/api/MainModule.Navigation"
                        }
                    },
                    "semantic": {
                        "role": "method",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    }
                },
                {
                    "name": "navigateTo",
                    "documentation": {
                        "sections": [
                            {
                                "content": "Navigate to a specific target.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            },
                            {
                                "title": "Arguments",
                                "content": "\n*  **target**: The URL target.\nIf a string is provided, a  [UrlTarget](@nav/api/MainModule.UrlTarget)  is constructed using  [parseUrl](@nav/api/MainModule.parseUrl) .\n*  **ctx**: Execution context used for logging and tracing.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "arguments",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "Router.navigateTo",
                    "navPath": "@nav/api/MainModule.Router.navigateTo",
                    "code": {
                        "filePath": "src/lib/router.ts",
                        "declaration": "@Contextual({\n    async: true,\n    key: (target: UrlTarget | string) =>\n        typeof target === 'string' ? target : target.path,\n})\nasync navigateTo(target: UrlTarget | string, ctx?: ContextTrait)",
                        "implementation": "@Contextual({\n    async: true,\n    key: (target: UrlTarget | string) =>\n        typeof target === 'string' ? target : target.path,\n})\nasync navigateTo(target: UrlTarget | string, ctx?: ContextTrait) {\n    ctx = this.ctx(ctx)\n    const originalTarget =\n        typeof target === 'string' ? parseUrl(target) : target\n\n    const redirectTarget = await this.redirects\n        .reverse()\n        .reduce(async (acc: Promise<UrlTarget | undefined>, redirect) => {\n            const from = await acc\n            return from\n                ? await redirect(from, ctx)\n                : Promise.resolve(undefined)\n        }, Promise.resolve(originalTarget))\n\n    if (!redirectTarget) {\n        ctx.info('Redirect returned `undefined`: cancel navigation')\n        return\n    }\n    const path = sanitizeNavPath(redirectTarget.path)\n    const sectionId = redirectTarget.sectionId\n\n    ctx.info('Schedule async nav node retrieval', target)\n    const resolved = await this.getNav(redirectTarget, ctx)\n    if (resolved === 'not-found') {\n        this.target$.next({\n            path,\n            reason: 'NotFound',\n        })\n        return\n    }\n    this.browserClient.pushState({ target: redirectTarget }, ctx)\n    this.path$.next(path)\n\n    this.target$.next({\n        node: resolved,\n        path,\n        sectionId: sectionId === '' ? undefined : sectionId,\n    })\n    await this.expandNavigationTree(path)\n}",
                        "startLine": 377,
                        "endLine": 422,
                        "references": {
                            "navigateTo": "@nav/api/MainModule.Router.navigateTo",
                            "UrlTarget": "@nav/api/MainModule.UrlTarget",
                            "ContextTrait": "@nav/api/MainModule.ContextTrait"
                        }
                    },
                    "semantic": {
                        "role": "method",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    }
                },
                {
                    "name": "parseUrl",
                    "documentation": {
                        "sections": [
                            {
                                "content": "Returns the current navigation path.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "Router.parseUrl",
                    "navPath": "@nav/api/MainModule.Router.parseUrl",
                    "code": {
                        "filePath": "src/lib/router.ts",
                        "declaration": "parseUrl(): UrlTarget",
                        "implementation": "parseUrl(): UrlTarget {\n    return this.browserClient.parseUrl()\n}",
                        "startLine": 341,
                        "endLine": 344,
                        "references": {
                            "parseUrl": "@nav/api/MainModule.Router.parseUrl",
                            "UrlTarget": "@nav/api/MainModule.UrlTarget"
                        }
                    },
                    "semantic": {
                        "role": "method",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    }
                },
                {
                    "name": "scrollTo",
                    "documentation": {
                        "sections": [
                            {
                                "content": "Scroll the main HTML content to focus on an HTML element.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            },
                            {
                                "title": "Arguments",
                                "content": "\n*  **target**: The target HTML element, or its id.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "arguments",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "Router.scrollTo",
                    "navPath": "@nav/api/MainModule.Router.scrollTo",
                    "code": {
                        "filePath": "src/lib/router.ts",
                        "declaration": "public scrollTo(target?: string | HTMLElement)",
                        "implementation": "public scrollTo(target?: string | HTMLElement) {\n    this.scrollTo$.next(target)\n}",
                        "startLine": 439,
                        "endLine": 442,
                        "references": {
                            "scrollTo": "@nav/api/MainModule.Router.scrollTo"
                        }
                    },
                    "semantic": {
                        "role": "method",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    }
                },
                {
                    "name": "setScrollableElement",
                    "documentation": {
                        "sections": [
                            {
                                "content": "Set the element in page that can be 'scrolled' to reach target destination's section ID (reference from URL).",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            },
                            {
                                "title": "Arguments",
                                "content": "\n*  **element**: Scrollable element.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "arguments",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "Router.setScrollableElement",
                    "navPath": "@nav/api/MainModule.Router.setScrollableElement",
                    "code": {
                        "filePath": "src/lib/router.ts",
                        "declaration": "setScrollableElement(element: HTMLElement)",
                        "implementation": "setScrollableElement(element: HTMLElement) {\n    this.scrollableElement = element\n    this.target$\n        .pipe(\n            take(1),\n            filter((target) => 'node' in target),\n        )\n        .subscribe((target) => {\n            this.scrollTo(target.sectionId)\n        })\n}",
                        "startLine": 423,
                        "endLine": 434,
                        "references": {
                            "setScrollableElement": "@nav/api/MainModule.Router.setScrollableElement"
                        }
                    },
                    "semantic": {
                        "role": "method",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    }
                }
            ],
            "code": {
                "filePath": "src/lib/router.ts",
                "declaration": "export class Router<TLayout = unknown, THeader = unknown>",
                "implementation": "export class Router<TLayout = unknown, THeader = unknown> {\n    /**\n     * The base path on which the router is defined.\n     *\n     * If the application is served from `https://my-domain/my-app/version` it is `/my-app/version`.\n     */\n    public readonly basePath: string\n\n    /**\n     * When using a dynamic definition of the routes (see {@link Navigation}),\n     * it may be the case that the routes are not yet available when navigating to a page.\n     * Attempt to re-navigate to the page is executed every `retryNavPeriod` second.\n     */\n    public readonly retryNavPeriod: number = 1000\n\n    /**\n     * Definition of the navigation.\n     */\n    public readonly navigation: Navigation<TLayout, THeader>\n\n    /**\n     * Debounced time applied when scrolling to specific target is triggered.\n     */\n    public readonly scrollingDebounceTime: number = 100\n\n    /**\n     * Handles navigation redirections.\n     *\n     * These functions are invoked whenever a specific path is requested for navigation.\n     * It allows modifying the target path before the navigation occurs.\n     *\n     * Functions are evaluated in reversed order, if one returns `undefined`, navigation is canceled.\n     *\n     * @param target - The requested target that the user intends to navigate to.\n     * @returns The modified target to navigate to, or the original path if no changes are needed.\n     *          If `undefined` is returned, the navigation will be canceled.\n     */\n    public readonly redirects: Redirect[] = [\n        (target) => Promise.resolve(target),\n    ]\n\n    /**\n     * Observable that emit the current page target.\n     */\n    public readonly target$: ReplaySubject<\n        Target<TLayout, THeader> | UnresolvedTarget\n    > = new ReplaySubject<Target<TLayout, THeader> | UnresolvedTarget>(1)\n\n    /**\n     * Observable that emit the current navigation path.\n     */\n    public readonly path$: ReplaySubject<string> = new ReplaySubject<string>(1)\n\n    /**\n     * Encapsulates the state of the navigation view (node selected, expanded, *etc.*)\n     */\n    public readonly explorerState: ImmutableTree.State<\n        AnyNavNode<TLayout, THeader>\n    >\n\n    public scrollableElement: HTMLElement | undefined\n\n    public readonly htmlUpdated$ = new Subject<unknown>()\n\n    public readonly status: Record<\n        'Warning' | 'Error',\n        Record<string, unknown[]>\n    > = { Warning: {}, Error: {} }\n\n    /**\n     * Storage attribute for user data.\n     */\n    public readonly userStore?: unknown\n\n    private navUpdates: Record<string, LazyRoutesCb<TLayout, THeader>> = {}\n    private navResolved: Record<string, Navigation<TLayout, THeader>> = {}\n\n    /**\n     * Browser client, see {@link WebBrowser} for regular scenario (library running within a tab of a web browser).\n     */\n    public readonly browserClient: BrowserInterface\n\n    public readonly context?: ContextTrait\n    private navParser = new NavParser()\n    private scrollTo$ = new Subject<string | HTMLElement | undefined>()\n\n    private navNodeCache: Record<string, Navigation<TLayout, THeader>> = {}\n    /**\n     * Initialize a router instance.\n     *\n     * @param params See corresponding documentation in the class's attributes.\n     * @param params.navigation See {@link Router.navigation}.\n     * @param params.basePath Deprecated should not be used.\n     * @param params.retryNavPeriod See {@link Router.retryNavPeriod}.\n     * @param params.redirects See {@link Router.redirects}.\n     * @param params.browserClient See {@link BrowserInterface}.\n     * @param params.scrollingDebounceTime See {@link Router.scrollingDebounceTime}.\n     * @param params.userStore See {@link Router.userStore}.\n     * @param ctx Execution context used for logging and tracing.\n     */\n    constructor(\n        params: {\n            navigation: Navigation<TLayout, THeader>\n            basePath?: string\n            retryNavPeriod?: number\n            redirects?: Redirect[]\n            browserClient?: (\n                p: {\n                    router: Router\n                    basePath: string\n                },\n                ctx?: ContextTrait,\n            ) => BrowserInterface\n            scrollingDebounceTime?: number\n            userStore?: unknown\n        },\n        ctx?: ContextTrait,\n    ) {\n        Object.assign(this, params)\n        this.context = ctx\n        const context = this.ctx().start('new Router', ['Router'])\n        this.basePath = this.basePath || document.location.pathname\n        this.browserClient = params.browserClient\n            ? params.browserClient({ router: this, basePath: this.basePath })\n            : new WebBrowser({ router: this, basePath: this.basePath }, context)\n\n        const { rootNode, reactiveNavs, promiseNavs } =\n            this.navParser.createRootNode(\n                {\n                    navigation: this.navigation,\n                    router: this,\n                },\n                context,\n            )\n        this.explorerState = new ImmutableTree.State({\n            rootNode,\n            expandedNodes: ['/'],\n        })\n        this.bindReactiveNavs(reactiveNavs, context)\n        this.bindPromiseNavs(promiseNavs, context)\n\n        this.target$\n            .pipe(\n                filter((page) => {\n                    return isResolvedTarget(page)\n                }),\n            )\n            .subscribe((page) => {\n                if (page.sectionId === undefined) {\n                    this.scrollTo()\n                }\n            })\n        fireAndForget(this.navigateTo(this.parseUrl(), context))\n\n        const removedNodes$ = this.explorerState.directUpdates$.pipe(\n            map((updates) =>\n                updates.map((update) => update.removedNodes).flat(),\n            ),\n            filter((nodes) => nodes.length > 0),\n        )\n        removedNodes$\n            .pipe(\n                withLatestFrom(this.target$),\n                filter(([nodes, target]) => {\n                    return (\n                        nodes.find((node) =>\n                            target.path.startsWith(node.href),\n                        ) !== undefined\n                    )\n                }),\n            )\n            .subscribe(([, target]) => {\n                context.info('Node parent of current path removed')\n                this.fireNavigateTo(target, undefined, context)\n            })\n        const scroll$ =\n            this.scrollingDebounceTime > 0\n                ? this.scrollTo$.pipe(debounceTime(this.scrollingDebounceTime))\n                : this.scrollTo$\n        scroll$.subscribe((target) => {\n            this._scrollTo(target)\n        })\n\n        removedNodes$.subscribe(() => {\n            this.navNodeCache = {}\n        })\n        this.target$.pipe(filter((t) => isResolvedTarget(t))).subscribe((t) => {\n            this.navNodeCache[t.path] = t.node\n            this.scrollTo(t.sectionId)\n        })\n        context.exit()\n    }\n\n    ctx(ctx?: ContextTrait) {\n        if (ctx) {\n            return ctx\n        }\n        return this.context ?? new NoContext()\n    }\n    /**\n     * Returns the current navigation path.\n     */\n    parseUrl(): UrlTarget {\n        return this.browserClient.parseUrl()\n    }\n\n    /**\n     * Fire navigation to given path with no `await`.\n     *\n     * @param target  The path to navigate to.\n     * If a string is provided, a {@link UrlTarget} is constructed using {@link parseUrl}.\n     * @param onError Callback called if errors happen.\n     * @param ctx Execution context used for logging and tracing.\n     */\n    @Contextual({\n        key: (target: UrlTarget | string) =>\n            typeof target === 'string' ? target : target.path,\n    })\n    fireNavigateTo(\n        target: UrlTarget | string,\n        onError?: (err: unknown) => void,\n        ctx?: ContextTrait,\n    ) {\n        fireAndForget(this.navigateTo(target, ctx), onError)\n    }\n\n    /**\n     * Navigate to a specific target.\n     *\n     * @param target The URL target.\n     * If a string is provided, a {@link UrlTarget} is constructed using {@link parseUrl}.\n     * @param ctx Execution context used for logging and tracing.\n     */\n    @Contextual({\n        async: true,\n        key: (target: UrlTarget | string) =>\n            typeof target === 'string' ? target : target.path,\n    })\n    async navigateTo(target: UrlTarget | string, ctx?: ContextTrait) {\n        ctx = this.ctx(ctx)\n        const originalTarget =\n            typeof target === 'string' ? parseUrl(target) : target\n\n        const redirectTarget = await this.redirects\n            .reverse()\n            .reduce(async (acc: Promise<UrlTarget | undefined>, redirect) => {\n                const from = await acc\n                return from\n                    ? await redirect(from, ctx)\n                    : Promise.resolve(undefined)\n            }, Promise.resolve(originalTarget))\n\n        if (!redirectTarget) {\n            ctx.info('Redirect returned `undefined`: cancel navigation')\n            return\n        }\n        const path = sanitizeNavPath(redirectTarget.path)\n        const sectionId = redirectTarget.sectionId\n\n        ctx.info('Schedule async nav node retrieval', target)\n        const resolved = await this.getNav(redirectTarget, ctx)\n        if (resolved === 'not-found') {\n            this.target$.next({\n                path,\n                reason: 'NotFound',\n            })\n            return\n        }\n        this.browserClient.pushState({ target: redirectTarget }, ctx)\n        this.path$.next(path)\n\n        this.target$.next({\n            node: resolved,\n            path,\n            sectionId: sectionId === '' ? undefined : sectionId,\n        })\n        await this.expandNavigationTree(path)\n    }\n\n    /**\n     * Set the element in page that can be 'scrolled' to reach target destination's section ID (reference from URL).\n     *\n     * @param element Scrollable element.\n     */\n    setScrollableElement(element: HTMLElement) {\n        this.scrollableElement = element\n        this.target$\n            .pipe(\n                take(1),\n                filter((target) => 'node' in target),\n            )\n            .subscribe((target) => {\n                this.scrollTo(target.sectionId)\n            })\n    }\n    /**\n     * Scroll the main HTML content to focus on an HTML element.\n     *\n     * @param target The target HTML element, or its id.\n     */\n    public scrollTo(target?: string | HTMLElement) {\n        this.scrollTo$.next(target)\n    }\n\n    private _scrollTo(target?: string | HTMLElement) {\n        const ctx = this.ctx()\n        if (\n            !this.scrollableElement ||\n            !('scrollTo' in this.scrollableElement)\n        ) {\n            return\n        }\n        const scrollableElement = this.scrollableElement\n        if (!target) {\n            ctx.info('No target specified, scroll to top.')\n            scrollableElement.scrollTo({\n                top: 0,\n                left: 0,\n            })\n            return\n        }\n        const br = scrollableElement.getBoundingClientRect()\n        const div =\n            target instanceof HTMLElement\n                ? target\n                : findElementById(scrollableElement, target)\n\n        if (!div) {\n            ctx.warning(`Can not scroll to element`, target)\n            return\n        }\n        this.browserClient.pushState(\n            {\n                target: {\n                    ...this.parseUrl(),\n                    sectionId: div.id,\n                    issuer: 'scroll',\n                },\n            },\n            ctx,\n        )\n        setTimeout(() => {\n            ctx.info('Target found, scroll to it.')\n            const offset = div.offsetTop\n            scrollableElement.scrollTo({\n                top: div.offsetTop - br.top - 1,\n                left: 0,\n                behavior: 'smooth',\n            })\n            setTimeout(() => {\n                if (div.offsetTop - offset !== 0) {\n                    scrollableElement.scrollTo({\n                        top: div.offsetTop - br.top - 1,\n                        left: 0,\n                        behavior: 'smooth',\n                    })\n                }\n            }, this.scrollingDebounceTime)\n        }, 0)\n    }\n\n    /**\n     * Asynchronously retrieves the navigation node for a given path.\n     * If the node is not immediately available, it will retry for a short period before returning a result.\n     *\n     * - If the node is found, it returns the corresponding `Navigation<TLayout, THeader>` object.\n     * - If the node does not exist, it returns `'not-found'`.\n     * - If the node is still unresolved, it waits and retries periodically.\n     *\n     * @param target The target.\n     * @param ctx Execution context used for logging and tracing.\n     * @returns A `Promise` resolving to the navigation node, or `'not-found'` if the node does not exist.\n     */\n    @Contextual({\n        key: ({ path }: { path: string }) => path,\n        async: true,\n    })\n    async getNav(\n        target: UrlTarget,\n        ctx?: ContextTrait,\n    ): Promise<Navigation<TLayout, THeader> | 'not-found'> {\n        ctx = this.ctx(ctx)\n        const { path, parameters } = target\n        if (\n            path in this.navNodeCache &&\n            Object.keys(parameters ?? {}).length === 0\n        ) {\n            ctx.info(\n                `No query parameters & node in cache => return it`,\n                this.navNodeCache[path],\n            )\n            return this.navNodeCache[path]\n        }\n        const nav = timer(0, this.retryNavPeriod).pipe(\n            switchMap((i) => {\n                ctx.info(`Attempt 'getNav' #${String(i)}`)\n                const nav = this._getNav({ path }, ctx)\n                if (nav instanceof Observable) {\n                    return nav\n                }\n                return of(nav)\n            }),\n            tap((nav) => {\n                if (nav === 'unresolved') {\n                    console.log('Try to wait...')\n                    this.target$.next({\n                        path,\n                        reason: 'Pending',\n                    })\n                }\n            }),\n            filter((nav) => nav !== 'unresolved'),\n            take(1),\n        )\n        return await firstValueFrom(nav)\n    }\n    /**\n     * Retrieves the navigation node corresponding to a given path as observable (emitting 1 item and closing),\n     * or `not-found` if it does not exist, or `unresolved` if the node is not resolved yet but maybe in a\n     * (hopefully short) future.\n     *\n     * @param path The target path.\n     * @param ctx Execution context used for logging and tracing.\n     */\n    @Contextual({\n        key: ({ path }: { path: string }) => path,\n    })\n    private _getNav(\n        {\n            path,\n        }: {\n            path: string\n        },\n        ctx?: ContextTrait,\n    ): Observable<Navigation<TLayout, THeader>> | 'not-found' | 'unresolved' {\n        ctx = this.ctx(ctx)\n        path = sanitizeNavPath(path)\n        const parts = path\n            .split('/')\n            .slice(1)\n            .filter((d) => d !== '')\n\n        if (parts.length === 0) {\n            return of(this.navigation)\n        }\n        const node = parts.reduce(\n            ({ tree, resolvedPath, keepGoing }, part) => {\n                ctx.info(`Resolve ${resolvedPath}/${part}`)\n                if (!keepGoing) {\n                    return { tree, resolvedPath, keepGoing }\n                }\n                if (tree.routes === undefined) {\n                    return 'not-found'\n                }\n                const routes = tree.routes\n                if (\n                    typeof routes === 'function' ||\n                    routes instanceof Observable\n                ) {\n                    // the navigation is a catch-all routes\n                    return {\n                        tree:\n                            resolvedPath in this.navUpdates\n                                ? this.navUpdates[resolvedPath]\n                                : routes,\n                        resolvedPath,\n                        keepGoing: false,\n                    }\n                }\n\n                if (`/${part}` in routes) {\n                    const route = routes[`/${part}`]\n\n                    if (!(route instanceof Promise)) {\n                        return {\n                            tree: route,\n                            resolvedPath: sanitizeNavPath(\n                                `${resolvedPath}/${part}`,\n                            ),\n                            keepGoing: true,\n                        }\n                    }\n\n                    const fullPath = sanitizeNavPath(`${resolvedPath}/${part}`)\n                    if (fullPath in this.navResolved) {\n                        return {\n                            tree: this.navResolved[fullPath],\n                            resolvedPath: sanitizeNavPath(\n                                `${resolvedPath}/${part}`,\n                            ),\n                            keepGoing: true,\n                        }\n                    }\n                    // a retry in some period of time will be executed\n                    return {\n                        tree: route,\n                        resolvedPath,\n                        keepGoing: false,\n                    }\n                }\n                return 'not-found'\n            },\n            { tree: this.navigation, resolvedPath: `/`, keepGoing: true },\n        )\n        if (node === 'not-found') {\n            ctx.info('Navigation node is not found')\n            return 'not-found'\n        }\n        // node.tree: Navigation |  Promise<Navigation> | LazyRoutesCb | LazyRoutesCb$\n        if (node.tree instanceof Observable || node.tree instanceof Promise) {\n            ctx.info('Navigation node is unresolved')\n            // case: Promise<Navigation> or LazyRoutesCb$ -> a retry in some period of time will be executed\n            return 'unresolved'\n        }\n        if (typeof node.tree === 'function') {\n            ctx.info('Navigation node is function for lazy definition')\n            // case: LazyRoutesCb, remove starting '/'\n            const relative =\n                node.resolvedPath === '/'\n                    ? path\n                    : sanitizeNavPath(path.split(node.resolvedPath)[1])\n            const parent = sanitizeNavPath(\n                relative.split('/').slice(0, -1).join('/'),\n            )\n            const parentNav = node.tree({ path: parent, router: this })\n            if (!parentNav) {\n                return 'not-found'\n            }\n            return resolve(parentNav).pipe(\n                mergeMap((resolved) => {\n                    const target = sanitizeNavPath(\n                        relative.split('/').slice(-1)[0],\n                    )\n                    return resolve(resolved[target])\n                }),\n            )\n        }\n        // node.tree: Navigation\n        ctx.info('Navigation node found', node.tree)\n        return of(node.tree)\n    }\n\n    private async expandNavigationTree(path: string) {\n        const ids = pathIds(path)\n        for (const id of ids.slice(0, -1)) {\n            const node = this.explorerState.getNodeResolved(id)\n            this.explorerState.getChildren(node)\n            await firstValueFrom(this.explorerState.getChildren$(node))\n        }\n        const node = this.explorerState.getNodeResolved(ids.slice(-1)[0])\n        this.explorerState.selectNodeAndExpand(node)\n    }\n\n    /**\n     * Clients need to invoke this function when dynamic change on the current main HTML page have occurred after the\n     * initial rendering. Other views dependening on it (*e.g.* the table of content) will refresh as well.\n     */\n    emitHtmlUpdated() {\n        this.htmlUpdated$.next(true)\n    }\n\n    @Contextual()\n    private bindReactiveNavs(\n        reactiveNavs: Record<string, LazyRoutesCb$<TLayout, THeader>>,\n        ctx?: ContextTrait,\n    ) {\n        ctx = this.ctx(ctx)\n        Object.entries(reactiveNavs).forEach(([href, v]) => {\n            v.subscribe((resolver) => {\n                this.navUpdates[href] = resolver\n                const oldNode = this.explorerState.getNodeResolved(href)\n                ctx.info(`Replace Node w/ Observable '${href}'`, oldNode)\n                const children = this.navParser.createLazyChildren$(\n                    {\n                        resolver: resolver,\n                        hrefBase: href,\n                        path: '',\n                        withExplicit: [],\n                        router: this,\n                        depth: 0,\n                    },\n                    ctx,\n                )\n                const newNode = new oldNode.factory({\n                    ...oldNode,\n                    children,\n                }) as AnyNavNode<TLayout, THeader>\n                this.explorerState.replaceNode(oldNode, newNode)\n            })\n        })\n    }\n    @Contextual()\n    private bindPromiseNavs(\n        promiseNavs: Record<string, Promise<Navigation<TLayout, THeader>>>,\n        ctx?: ContextTrait,\n    ) {\n        ctx = this.ctx(ctx)\n        Object.entries(promiseNavs).forEach(([href, v]) => {\n            v.then(\n                (nav) => {\n                    this.navResolved[href] = nav\n                    const oldNode = this.explorerState.getNodeResolved(href)\n                    ctx.info(`Replace Node w/ Promise '${href}'`, oldNode)\n                    const { rootNode, reactiveNavs, promiseNavs } =\n                        this.navParser.createRootNode(\n                            {\n                                navigation: nav,\n                                router: this,\n                                hrefBase: href,\n                            },\n                            ctx,\n                        )\n                    this.explorerState.replaceNode(oldNode, rootNode)\n                    this.bindReactiveNavs(reactiveNavs, ctx)\n                    this.bindPromiseNavs(promiseNavs, ctx)\n                },\n                () => {\n                    throw Error(\n                        `Router.bindPromiseNavs: unable to bind promise navigation on ${href}`,\n                    )\n                },\n            )\n        })\n    }\n}",
                "startLine": 139,
                "endLine": 764,
                "references": {
                    "Router": "@nav/api/MainModule.Router",
                    "ContextTrait": "@nav/api/MainModule.ContextTrait",
                    "BrowserInterface": "@nav/api/MainModule.BrowserInterface",
                    "Navigation": "@nav/api/MainModule.Navigation",
                    "Redirect": "@nav/api/MainModule.Redirect",
                    "AnyNavNode": "@nav/api/MainModule.AnyNavNode",
                    "Target": "@nav/api/MainModule.Target",
                    "UnresolvedTarget": "@nav/api/MainModule.UnresolvedTarget",
                    "UrlTarget": "@nav/api/MainModule.UrlTarget",
                    "Subject": "https://www.learnrxjs.io/learn-rxjs/subjects/subject",
                    "ReplaySubject": "https://www.learnrxjs.io/learn-rxjs/subjects/replaysubject"
                }
            },
            "semantic": {
                "role": "class",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "WebBrowser",
            "documentation": {
                "sections": [
                    {
                        "content": "Implements the  [BrowserInterface](@nav/api/MainModule.BrowserInterface)  for managing browser navigation.\nIntegrates with the browser's history API and synchronizes with a  [Router](@nav/api/MainModule.Router) .",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "WebBrowser",
            "navPath": "@nav/api/MainModule.WebBrowser",
            "attributes": [],
            "callables": [
                {
                    "name": "parseUrl",
                    "documentation": {
                        "sections": [
                            {
                                "content": "Retrieves the target from the current URL.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            },
                            {
                                "title": "Returns",
                                "content": "The current navigation path as a string.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "returns",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "WebBrowser.parseUrl",
                    "navPath": "@nav/api/MainModule.WebBrowser.parseUrl",
                    "code": {
                        "filePath": "src/lib/browser.interface.ts",
                        "declaration": "parseUrl(): UrlTarget",
                        "implementation": "parseUrl(): UrlTarget {\n    return { ...parseUrl(window.location.search), issuer: 'browser' }\n}",
                        "startLine": 103,
                        "endLine": 106,
                        "references": {
                            "parseUrl": "@nav/api/MainModule.WebBrowser.parseUrl",
                            "UrlTarget": "@nav/api/MainModule.UrlTarget"
                        }
                    },
                    "semantic": {
                        "role": "method",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    }
                },
                {
                    "name": "pushState",
                    "documentation": {
                        "sections": [
                            {
                                "content": "Pushes a new state to the browser's history stack.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            },
                            {
                                "title": "Arguments",
                                "content": "\n*  **data**: The state data to associate with the history entry, including the navigation path.\n*  **ctx**: Execution context used for logging and tracing.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "arguments",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "WebBrowser.pushState",
                    "navPath": "@nav/api/MainModule.WebBrowser.pushState",
                    "code": {
                        "filePath": "src/lib/browser.interface.ts",
                        "declaration": "@Contextual({\n    key: ({ target }: { target: UrlTarget }) =>\n        `${String(target.issuer)} : ${target.path}.${target.sectionId ?? ''}`,\n    labels: ['Browser'],\n})\npushState(data: { target: UrlTarget }, ctx?: ContextTrait): void",
                        "implementation": "@Contextual({\n    key: ({ target }: { target: UrlTarget }) =>\n        `${String(target.issuer)} : ${target.path}.${target.sectionId ?? ''}`,\n    labels: ['Browser'],\n})\npushState(data: { target: UrlTarget }, ctx?: ContextTrait): void {\n    ctx = this.ctx(ctx)\n    if (['browser'].includes(data.target.issuer ?? '')) {\n        ctx.info('Push state disabled: browser', {\n            target: data.target,\n        })\n        return\n    }\n    const newState = {\n        path: data.target.path,\n        sectionId: data.target.sectionId,\n        parameters: data.target.parameters,\n    }\n    if (JSON.stringify(this.lastState) === JSON.stringify(newState)) {\n        ctx.info('Push state disabled: no state change', {\n            target: data.target,\n        })\n        return\n    }\n    const url = `${this.basePath}?${formatUrl(data.target)}`\n    ctx.info('Push state', { target: newState, url })\n    this.lastState = newState\n    history.pushState(\n        {\n            target: this.lastState,\n        },\n        '',\n        url,\n    )\n}",
                        "startLine": 72,
                        "endLine": 107,
                        "references": {
                            "pushState": "@nav/api/MainModule.WebBrowser.pushState",
                            "UrlTarget": "@nav/api/MainModule.UrlTarget",
                            "ContextTrait": "@nav/api/MainModule.ContextTrait"
                        }
                    },
                    "semantic": {
                        "role": "method",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    }
                }
            ],
            "code": {
                "filePath": "src/lib/browser.interface.ts",
                "declaration": "export class WebBrowser implements BrowserInterface",
                "implementation": "export class WebBrowser implements BrowserInterface {\n    public readonly router: Router\n    public readonly basePath: string\n    public readonly context: ContextTrait\n\n    private lastState?: UrlTarget\n\n    constructor(\n        params: { router: Router; basePath: string },\n        ctx?: ContextTrait,\n    ) {\n        this.context = ctx ?? new NoContext()\n        const context = this.ctx().start('new WebBrowser', ['Browser'])\n        Object.assign(this, params)\n        window.onpopstate = (event: PopStateEvent) => {\n            const state = event.state as unknown as\n                | { target: UrlTarget }\n                | undefined\n            if (state) {\n                context.info(`Pop state`, state.target)\n                this.lastState = state.target\n                this.router.fireNavigateTo({\n                    ...state.target,\n                    issuer: 'browser',\n                })\n            } else {\n                this.router.fireNavigateTo({\n                    path: '/',\n                })\n            }\n        }\n        context.exit()\n    }\n\n    ctx(ctx?: ContextTrait) {\n        return ctx ?? this.context\n    }\n\n    @Contextual({\n        key: ({ target }: { target: UrlTarget }) =>\n            `${String(target.issuer)} : ${target.path}.${target.sectionId ?? ''}`,\n        labels: ['Browser'],\n    })\n    pushState(data: { target: UrlTarget }, ctx?: ContextTrait): void {\n        ctx = this.ctx(ctx)\n        if (['browser'].includes(data.target.issuer ?? '')) {\n            ctx.info('Push state disabled: browser', {\n                target: data.target,\n            })\n            return\n        }\n        const newState = {\n            path: data.target.path,\n            sectionId: data.target.sectionId,\n            parameters: data.target.parameters,\n        }\n        if (JSON.stringify(this.lastState) === JSON.stringify(newState)) {\n            ctx.info('Push state disabled: no state change', {\n                target: data.target,\n            })\n            return\n        }\n        const url = `${this.basePath}?${formatUrl(data.target)}`\n        ctx.info('Push state', { target: newState, url })\n        this.lastState = newState\n        history.pushState(\n            {\n                target: this.lastState,\n            },\n            '',\n            url,\n        )\n    }\n\n    parseUrl(): UrlTarget {\n        return { ...parseUrl(window.location.search), issuer: 'browser' }\n    }\n}",
                "startLine": 29,
                "endLine": 107,
                "references": {
                    "WebBrowser": "@nav/api/MainModule.WebBrowser",
                    "Router": "@nav/api/MainModule.Router",
                    "ContextTrait": "@nav/api/MainModule.ContextTrait",
                    "UrlTarget": "@nav/api/MainModule.UrlTarget",
                    "BrowserInterface.parseUrl": "@nav/api/MainModule.BrowserInterface.parseUrl",
                    "BrowserInterface.pushState": "@nav/api/MainModule.BrowserInterface.pushState",
                    "BrowserInterface": "@nav/api/MainModule.BrowserInterface"
                }
            },
            "semantic": {
                "role": "class",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "BrowserInterface",
            "documentation": {
                "sections": [
                    {
                        "content": "Defines the interface for interacting with the browser's navigation system.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "BrowserInterface",
            "navPath": "@nav/api/MainModule.BrowserInterface",
            "attributes": [],
            "callables": [
                {
                    "name": "parseUrl",
                    "documentation": {
                        "sections": [
                            {
                                "content": "Retrieves the target from the current URL.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            },
                            {
                                "title": "Returns",
                                "content": "The current navigation path as a string.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "returns",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "BrowserInterface.parseUrl",
                    "navPath": "@nav/api/MainModule.BrowserInterface.parseUrl",
                    "code": {
                        "filePath": "src/lib/browser.interface.ts",
                        "declaration": "parseUrl(): UrlTarget",
                        "implementation": "",
                        "startLine": 22,
                        "endLine": 23,
                        "references": {
                            "parseUrl": "@nav/api/MainModule.BrowserInterface.parseUrl",
                            "UrlTarget": "@nav/api/MainModule.UrlTarget"
                        }
                    },
                    "semantic": {
                        "role": "method",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    }
                },
                {
                    "name": "pushState",
                    "documentation": {
                        "sections": [
                            {
                                "content": "Pushes a new state to the browser's history stack.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            },
                            {
                                "title": "Arguments",
                                "content": "\n*  **data**: The state data to associate with the history entry, including the navigation path.\n*  **ctx**: Execution context used for logging and tracing.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "arguments",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "BrowserInterface.pushState",
                    "navPath": "@nav/api/MainModule.BrowserInterface.pushState",
                    "code": {
                        "filePath": "src/lib/browser.interface.ts",
                        "declaration": "pushState(data: { target: UrlTarget }, ctx?: ContextTrait): void",
                        "implementation": "",
                        "startLine": 16,
                        "endLine": 17,
                        "references": {
                            "pushState": "@nav/api/MainModule.BrowserInterface.pushState",
                            "UrlTarget": "@nav/api/MainModule.UrlTarget",
                            "ContextTrait": "@nav/api/MainModule.ContextTrait"
                        }
                    },
                    "semantic": {
                        "role": "method",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    }
                }
            ],
            "code": {
                "filePath": "src/lib/browser.interface.ts",
                "declaration": "export interface BrowserInterface",
                "implementation": "export interface BrowserInterface {\n    /**\n     * Pushes a new state to the browser's history stack.\n     *\n     * @param data - The state data to associate with the history entry, including the navigation path.\n     * @param ctx Execution context used for logging and tracing.\n     */\n    pushState(data: { target: UrlTarget }, ctx?: ContextTrait): void\n    /**\n     * Retrieves the target from the current URL.\n     *\n     * @returns The current navigation path as a string.\n     */\n    parseUrl(): UrlTarget\n}",
                "startLine": 9,
                "endLine": 24,
                "references": {
                    "BrowserInterface": "@nav/api/MainModule.BrowserInterface",
                    "UrlTarget": "@nav/api/MainModule.UrlTarget",
                    "ContextTrait": "@nav/api/MainModule.ContextTrait",
                    "MockBrowser": "@nav/api/MainModule.MockBrowser",
                    "WebBrowser": "@nav/api/MainModule.WebBrowser"
                }
            },
            "semantic": {
                "role": "interface",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "ContextTrait",
            "documentation": {
                "sections": [
                    {
                        "content": "Defines the structure of a logging context.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "ContextTrait",
            "navPath": "@nav/api/MainModule.ContextTrait",
            "attributes": [],
            "callables": [
                {
                    "name": "error",
                    "documentation": {
                        "sections": [
                            {
                                "content": "Log with level  `Error` .",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "ContextTrait.error",
                    "navPath": "@nav/api/MainModule.ContextTrait.error",
                    "code": {
                        "filePath": "src/lib/context.ts",
                        "declaration": "error(text: string, data?: unknown): void",
                        "implementation": "",
                        "startLine": 135,
                        "endLine": 136,
                        "references": {
                            "error": "@nav/api/MainModule.ContextTrait.error"
                        }
                    },
                    "semantic": {
                        "role": "method",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    }
                },
                {
                    "name": "execute",
                    "documentation": {
                        "sections": [
                            {
                                "content": "Execute a given function.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            },
                            {
                                "title": "Arguments",
                                "content": "\n*  **name**: Function's name.\n*  **meth**: Function.\n*  **labels**: Associated labels.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "arguments",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "ContextTrait.execute",
                    "navPath": "@nav/api/MainModule.ContextTrait.execute",
                    "code": {
                        "filePath": "src/lib/context.ts",
                        "declaration": "execute<TReturn>(\n        name: string,\n        meth: (context: ContextTrait) => TReturn,\n        labels?: Label[],\n    ): TReturn",
                        "implementation": "",
                        "startLine": 143,
                        "endLine": 144,
                        "references": {
                            "execute": "@nav/api/MainModule.ContextTrait.execute",
                            "ContextTrait": "@nav/api/MainModule.ContextTrait",
                            "Label": "@nav/api/MainModule.Label"
                        }
                    },
                    "semantic": {
                        "role": "method",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    }
                },
                {
                    "name": "executeAsync",
                    "documentation": {
                        "sections": [
                            {
                                "content": "Execute a given async function.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            },
                            {
                                "title": "Arguments",
                                "content": "\n*  **name**: Function's name.\n*  **meth**: Async function.\n*  **labels**: Associated labels.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "arguments",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "ContextTrait.executeAsync",
                    "navPath": "@nav/api/MainModule.ContextTrait.executeAsync",
                    "code": {
                        "filePath": "src/lib/context.ts",
                        "declaration": "executeAsync<TReturn>(\n        name: string,\n        meth: (context: ContextTrait) => Promise<TReturn>,\n        labels?: Label[],\n    ): Promise<TReturn>",
                        "implementation": "",
                        "startLine": 155,
                        "endLine": 156,
                        "references": {
                            "executeAsync": "@nav/api/MainModule.ContextTrait.executeAsync",
                            "ContextTrait": "@nav/api/MainModule.ContextTrait",
                            "Label": "@nav/api/MainModule.Label"
                        }
                    },
                    "semantic": {
                        "role": "method",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    }
                },
                {
                    "name": "exit",
                    "documentation": {
                        "sections": [
                            {
                                "content": "Trigger exit tasks.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "ContextTrait.exit",
                    "navPath": "@nav/api/MainModule.ContextTrait.exit",
                    "code": {
                        "filePath": "src/lib/context.ts",
                        "declaration": "exit(): void",
                        "implementation": "",
                        "startLine": 171,
                        "endLine": 172,
                        "references": {
                            "exit": "@nav/api/MainModule.ContextTrait.exit"
                        }
                    },
                    "semantic": {
                        "role": "method",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    }
                },
                {
                    "name": "info",
                    "documentation": {
                        "sections": [
                            {
                                "content": "Log with level  `Info` .",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "ContextTrait.info",
                    "navPath": "@nav/api/MainModule.ContextTrait.info",
                    "code": {
                        "filePath": "src/lib/context.ts",
                        "declaration": "info(text: string, data?: unknown): void",
                        "implementation": "",
                        "startLine": 127,
                        "endLine": 128,
                        "references": {
                            "info": "@nav/api/MainModule.ContextTrait.info"
                        }
                    },
                    "semantic": {
                        "role": "method",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    }
                },
                {
                    "name": "start",
                    "documentation": {
                        "sections": [
                            {
                                "content": "Start a child context.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            },
                            {
                                "title": "Arguments",
                                "content": "\n*  **name**: Function's name.\n*  **labels**: Associated labels.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "arguments",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "ContextTrait.start",
                    "navPath": "@nav/api/MainModule.ContextTrait.start",
                    "code": {
                        "filePath": "src/lib/context.ts",
                        "declaration": "start(name: string, labels?: Label[]): ContextTrait",
                        "implementation": "",
                        "startLine": 166,
                        "endLine": 167,
                        "references": {
                            "start": "@nav/api/MainModule.ContextTrait.start",
                            "Label": "@nav/api/MainModule.Label",
                            "ContextTrait": "@nav/api/MainModule.ContextTrait"
                        }
                    },
                    "semantic": {
                        "role": "method",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    }
                },
                {
                    "name": "warning",
                    "documentation": {
                        "sections": [
                            {
                                "content": "Log with level  `Warning` .",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "ContextTrait.warning",
                    "navPath": "@nav/api/MainModule.ContextTrait.warning",
                    "code": {
                        "filePath": "src/lib/context.ts",
                        "declaration": "warning(text: string, data?: unknown): void",
                        "implementation": "",
                        "startLine": 131,
                        "endLine": 132,
                        "references": {
                            "warning": "@nav/api/MainModule.ContextTrait.warning"
                        }
                    },
                    "semantic": {
                        "role": "method",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    }
                }
            ],
            "code": {
                "filePath": "src/lib/context.ts",
                "declaration": "export interface ContextTrait",
                "implementation": "export interface ContextTrait {\n    /**\n     * Log with level `Info`.\n     */\n    info(text: string, data?: unknown): void\n    /**\n     * Log with level `Warning`.\n     */\n    warning(text: string, data?: unknown): void\n    /**\n     * Log with level `Error`.\n     */\n    error(text: string, data?: unknown): void\n    /**\n     * Execute a given function.\n     *\n     * @param name Function's name.\n     * @param meth Function.\n     * @param labels Associated labels.\n     */\n    execute<TReturn>(\n        name: string,\n        meth: (context: ContextTrait) => TReturn,\n        labels?: Label[],\n    ): TReturn\n    /**\n     * Execute a given async function.\n     *\n     * @param name Function's name.\n     * @param meth Async function.\n     * @param labels Associated labels.\n     */\n    executeAsync<TReturn>(\n        name: string,\n        meth: (context: ContextTrait) => Promise<TReturn>,\n        labels?: Label[],\n    ): Promise<TReturn>\n\n    /**\n     * Start a child context.\n     * @param name Function's name.\n     * @param labels Associated labels.\n     */\n    start(name: string, labels?: Label[]): ContextTrait\n\n    /**\n     * Trigger exit tasks.\n     */\n    exit(): void\n}",
                "startLine": 123,
                "endLine": 173,
                "references": {
                    "ContextTrait": "@nav/api/MainModule.ContextTrait",
                    "Label": "@nav/api/MainModule.Label",
                    "Context": "@nav/api/MainModule.Context",
                    "NoContext": "@nav/api/MainModule.NoContext"
                }
            },
            "semantic": {
                "role": "interface",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "Entry",
            "documentation": {
                "sections": [
                    {
                        "content": "Represents a log entry containing contextual information.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "Entry",
            "navPath": "@nav/api/MainModule.Entry",
            "attributes": [
                {
                    "name": "callstack",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "CallStack.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "Entry.callstack",
                    "navPath": "@nav/api/MainModule.Entry.callstack",
                    "code": {
                        "filePath": "src/lib/context.ts",
                        "declaration": "callstack: string[]",
                        "implementation": "",
                        "startLine": 56,
                        "endLine": 57,
                        "references": {
                            "callstack": "@nav/api/MainModule.Entry.callstack"
                        }
                    }
                },
                {
                    "name": "ctxId",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "Associated context's ID.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "Entry.ctxId",
                    "navPath": "@nav/api/MainModule.Entry.ctxId",
                    "code": {
                        "filePath": "src/lib/context.ts",
                        "declaration": "ctxId: string",
                        "implementation": "",
                        "startLine": 32,
                        "endLine": 33,
                        "references": {
                            "ctxId": "@nav/api/MainModule.Entry.ctxId"
                        }
                    }
                },
                {
                    "name": "data",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "Associated data (optional).",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "Entry.data",
                    "navPath": "@nav/api/MainModule.Entry.data",
                    "code": {
                        "filePath": "src/lib/context.ts",
                        "declaration": "data?: unknown",
                        "implementation": "",
                        "startLine": 52,
                        "endLine": 53,
                        "references": {
                            "data": "@nav/api/MainModule.Entry.data"
                        }
                    }
                },
                {
                    "name": "labels",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "Labels.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "Entry.labels",
                    "navPath": "@nav/api/MainModule.Entry.labels",
                    "code": {
                        "filePath": "src/lib/context.ts",
                        "declaration": "labels: Label[]",
                        "implementation": "",
                        "startLine": 40,
                        "endLine": 41,
                        "references": {
                            "labels": "@nav/api/MainModule.Entry.labels",
                            "Label": "@nav/api/MainModule.Label"
                        }
                    }
                },
                {
                    "name": "level",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "Severity.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "Entry.level",
                    "navPath": "@nav/api/MainModule.Entry.level",
                    "code": {
                        "filePath": "src/lib/context.ts",
                        "declaration": "level: Level",
                        "implementation": "",
                        "startLine": 44,
                        "endLine": 45,
                        "references": {
                            "level": "@nav/api/MainModule.Entry.level",
                            "Level": "@nav/api/MainModule.Level"
                        }
                    }
                },
                {
                    "name": "parentCtxId",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "Associated parent context's ID.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "Entry.parentCtxId",
                    "navPath": "@nav/api/MainModule.Entry.parentCtxId",
                    "code": {
                        "filePath": "src/lib/context.ts",
                        "declaration": "parentCtxId: string",
                        "implementation": "",
                        "startLine": 36,
                        "endLine": 37,
                        "references": {
                            "parentCtxId": "@nav/api/MainModule.Entry.parentCtxId"
                        }
                    }
                },
                {
                    "name": "text",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "Text.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "Entry.text",
                    "navPath": "@nav/api/MainModule.Entry.text",
                    "code": {
                        "filePath": "src/lib/context.ts",
                        "declaration": "text: string",
                        "implementation": "",
                        "startLine": 48,
                        "endLine": 49,
                        "references": {
                            "text": "@nav/api/MainModule.Entry.text"
                        }
                    }
                },
                {
                    "name": "threadName",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "Name of the thread, for display purpose.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "Entry.threadName",
                    "navPath": "@nav/api/MainModule.Entry.threadName",
                    "code": {
                        "filePath": "src/lib/context.ts",
                        "declaration": "threadName: string",
                        "implementation": "",
                        "startLine": 28,
                        "endLine": 29,
                        "references": {
                            "threadName": "@nav/api/MainModule.Entry.threadName"
                        }
                    }
                }
            ],
            "callables": [],
            "code": {
                "filePath": "src/lib/context.ts",
                "declaration": "export interface Entry",
                "implementation": "export interface Entry {\n    /**\n     * Name of the thread, for display purpose.\n     */\n    threadName: string\n    /**\n     * Associated context's ID.\n     */\n    ctxId: string\n    /**\n     * Associated parent context's ID.\n     */\n    parentCtxId: string\n    /**\n     * Labels.\n     */\n    labels: Label[]\n    /**\n     * Severity.\n     */\n    level: Level\n    /**\n     * Text.\n     */\n    text: string\n    /**\n     * Associated data (optional).\n     */\n    data?: unknown\n    /**\n     * CallStack.\n     */\n    callstack: string[]\n}",
                "startLine": 24,
                "endLine": 58,
                "references": {
                    "Entry": "@nav/api/MainModule.Entry",
                    "Label": "@nav/api/MainModule.Label",
                    "Level": "@nav/api/MainModule.Level"
                }
            },
            "semantic": {
                "role": "interface",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "MdParsingOptions",
            "documentation": {
                "sections": [
                    {
                        "content": "Configuration options for parsing Markdown content, using *e.g.*  [parseMd](@nav/api/MainModule.parseMd) .",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "MdParsingOptions",
            "navPath": "@nav/api/MainModule.MdParsingOptions",
            "attributes": [
                {
                    "name": "latex",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "Enables LaTeX equation parsing. Requires  `MathJax`  to be loaded before parsing.\n\n**Example**\n\n<js-cell>\nawait webpm.install({esm: [\n    'mkdocs-ts#{{mkdocs-version}} as MkDocs',\n    'mathjax#^3.1.4'\n]})\nconst parsed = MkDocs.parseMd({\n    src: `\nThis is a latex equation:\n$$\nE = mc^2\n$$\n` ,\n    latex: true\n})\ndisplay(parsed)\n</js-cell>\n\n<note level='warning' text='Delimiters'>\n `MathJax`  is configured by default using\n- Block equations:  `$$ ... $$` \n- Inline equations:  `\\( ... \\)` \n\n Since Markdown escape backslashes, inline equations should be written as  `\\\\(`  and  `\\\\)` .\n If Markdown is inside JavaScript (which also escapes backslashes), it becomes  `\\\\\\\\(`  and  `\\\\\\\\)` .\n\n To use  `$`  for inline equations instead, configure MathJax **before** loading it:\n\n<code-snippet language='javascript'>\nwindow.MathJax = {\n    tex: { inlineMath: [ ['$', '$'] ],\n    },\n}\n</code-snippet>\n\nMore details\n<a target='_blank' href='https://docs.mathjax.org/en/latest/input/tex/delimiters.html'>here </a>.\n\n</note>",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "MdParsingOptions.latex",
                    "navPath": "@nav/api/MainModule.MdParsingOptions.latex",
                    "code": {
                        "filePath": "src/lib/markdown.ts",
                        "declaration": "latex?: boolean",
                        "implementation": "",
                        "startLine": 132,
                        "endLine": 133,
                        "references": {
                            "latex": "@nav/api/MainModule.MdParsingOptions.latex"
                        }
                    }
                },
                {
                    "name": "onRendered",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "Callback triggered when the view has been added to the DOM.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "MdParsingOptions.onRendered",
                    "navPath": "@nav/api/MainModule.MdParsingOptions.onRendered",
                    "code": {
                        "filePath": "src/lib/markdown.ts",
                        "declaration": "onRendered?: (elem: HTMLElement) => void",
                        "implementation": "",
                        "startLine": 139,
                        "endLine": 140,
                        "references": {
                            "onRendered": "@nav/api/MainModule.MdParsingOptions.onRendered"
                        }
                    }
                },
                {
                    "name": "placeholders",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "Defines placeholders for preprocessing. Any occurrence of a key in the source\nwill be replaced with its corresponding value.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "MdParsingOptions.placeholders",
                    "navPath": "@nav/api/MainModule.MdParsingOptions.placeholders",
                    "code": {
                        "filePath": "src/lib/markdown.ts",
                        "declaration": "placeholders?: Record<string, string>",
                        "implementation": "",
                        "startLine": 40,
                        "endLine": 41,
                        "references": {
                            "placeholders": "@nav/api/MainModule.MdParsingOptions.placeholders"
                        }
                    }
                },
                {
                    "name": "preprocessing",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "Preprocessing callback to transform the source before parsing.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "MdParsingOptions.preprocessing",
                    "navPath": "@nav/api/MainModule.MdParsingOptions.preprocessing",
                    "code": {
                        "filePath": "src/lib/markdown.ts",
                        "declaration": "preprocessing?: (text: string) => string",
                        "implementation": "",
                        "startLine": 46,
                        "endLine": 47,
                        "references": {
                            "preprocessing": "@nav/api/MainModule.MdParsingOptions.preprocessing"
                        }
                    }
                },
                {
                    "name": "views",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "Custom view generators for specific HTML elements referenced in the Markdown source.\nThese allow dynamically replacing custom DOM elements with JavaScript-generated content.\n\n**Example**:\n\n<js-cell>\nconst { rxjs } = await webpm.install({esm:[\n    'mkdocs-ts#{{mkdocs-version}} as MkDocs',\n    'rxjs#^7.5.6 as rxjs']\n})\nconst clockView = (elem) => {\n    // elem is the corresponding DOM element included in the MD source.\n    // use  `elem.getAttribute`  or  `elem.textContent`  to retrieve inputs.\n    const period = parseInt(elem.getAttribute('period') ?? '1000')\n    return {\n        tag: 'div',\n        innerText: {\n            source$: rxjs.timer(period, 0),\n            vdomMap: () => new Date().toLocaleTimeString()\n        }\n    }\n}\nconst parsed = MkDocs.parseMd({\n    src: `\n**The custom view**:\n<clock period='1000'></clock>\n` ,\n    views: {\n        'clock': clockView\n    }\n})\ndisplay(parsed)\n</js-cell>\n\n<note level=\"hint\">\n Custom views specified here are in addition to globally registered ones in  [GlobalMarkdownViews](@nav/api/MainModule.GlobalMarkdownViews) .\n</note>",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "MdParsingOptions.views",
                    "navPath": "@nav/api/MainModule.MdParsingOptions.views",
                    "code": {
                        "filePath": "src/lib/markdown.ts",
                        "declaration": "views?: Record<string, ViewGenerator>",
                        "implementation": "",
                        "startLine": 86,
                        "endLine": 87,
                        "references": {
                            "views": "@nav/api/MainModule.MdParsingOptions.views",
                            "ViewGenerator": "@nav/api/MainModule.ViewGenerator"
                        }
                    }
                }
            ],
            "callables": [],
            "code": {
                "filePath": "src/lib/markdown.ts",
                "declaration": "export interface MdParsingOptions",
                "implementation": "export interface MdParsingOptions {\n    /**\n     * Defines placeholders for preprocessing. Any occurrence of a key in the source\n     * will be replaced with its corresponding value.\n     */\n    placeholders?: Record<string, string>\n    /**\n     * Preprocessing callback to transform the source before parsing.\n     * @param text The original Markdown content.\n     * @returns The transformed content.\n     */\n    preprocessing?: (text: string) => string\n    /**\n     * Custom view generators for specific HTML elements referenced in the Markdown source.\n     * These allow dynamically replacing custom DOM elements with JavaScript-generated content.\n     *\n     * **Example**:\n     *\n     * <js-cell>\n     * const { rxjs } = await webpm.install({esm:[\n     *     'mkdocs-ts#{{mkdocs-version}} as MkDocs',\n     *     'rxjs#^7.5.6 as rxjs']\n     * })\n     * const clockView = (elem) => {\n     *     // elem is the corresponding DOM element included in the MD source.\n     *     // use `elem.getAttribute` or `elem.textContent` to retrieve inputs.\n     *     const period = parseInt(elem.getAttribute('period') ?? '1000')\n     *     return {\n     *         tag: 'div',\n     *         innerText: {\n     *             source$: rxjs.timer(period, 0),\n     *             vdomMap: () => new Date().toLocaleTimeString()\n     *         }\n     *     }\n     * }\n     * const parsed = MkDocs.parseMd({\n     *     src:`\n     * **The custom view**:\n     * <clock period='1000'></clock>\n     * `,\n     *     views: {\n     *         'clock': clockView\n     *     }\n     * })\n     * display(parsed)\n     * </js-cell>\n     *\n     * <note level=\"hint\">\n     *  Custom views specified here are in addition to globally registered ones in {@link GlobalMarkdownViews}.\n     * </note>\n     */\n    views?: Record<string, ViewGenerator>\n\n    /**\n     * Enables LaTeX equation parsing. Requires `MathJax` to be loaded before parsing.\n     *\n     * **Example**\n     *\n     * <js-cell>\n     * await webpm.install({esm: [\n     *     'mkdocs-ts#{{mkdocs-version}} as MkDocs',\n     *     'mathjax#^3.1.4'\n     * ]})\n     * const parsed = MkDocs.parseMd({\n     *     src:`\n     * This is a latex equation:\n     * $$\n     * E = mc^2\n     * $$\n     * `,\n     *     latex: true\n     * })\n     * display(parsed)\n     * </js-cell>\n     *\n     * <note level='warning' text='Delimiters'>\n     * `MathJax` is configured by default using\n     * - Block equations: `$$ ... $$`\n     * - Inline equations: `\\( ... \\)`\n     *\n     *  Since Markdown escape backslashes, inline equations should be written as `\\\\(` and `\\\\)`.\n     *  If Markdown is inside JavaScript (which also escapes backslashes), it becomes `\\\\\\\\(` and `\\\\\\\\)`.\n     *\n     *  To use `$` for inline equations instead, configure MathJax **before** loading it:\n     *\n     * <code-snippet language='javascript'>\n     * window.MathJax = {\n     *     tex: { inlineMath: [ ['$', '$'] ],\n     *     },\n     * }\n     * </code-snippet>\n     *\n     * More details\n     * <a target='_blank' href='https://docs.mathjax.org/en/latest/input/tex/delimiters.html'>here </a>.\n     *\n     * </note>\n     */\n    latex?: boolean\n\n    /**\n     * Callback triggered when the view has been added to the DOM.\n     *\n     * @param elem The rendered element.\n     */\n    onRendered?: (elem: HTMLElement) => void\n}",
                "startLine": 35,
                "endLine": 141,
                "references": {
                    "MdParsingOptions": "@nav/api/MainModule.MdParsingOptions",
                    "ViewGenerator": "@nav/api/MainModule.ViewGenerator"
                }
            },
            "semantic": {
                "role": "interface",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "ReporterTrait",
            "documentation": {
                "sections": [
                    {
                        "content": "Defines a logging reporter interface.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "ReporterTrait",
            "navPath": "@nav/api/MainModule.ReporterTrait",
            "attributes": [],
            "callables": [
                {
                    "name": "log",
                    "documentation": {
                        "sections": [
                            {
                                "content": "Logs an entry to the designated output.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            },
                            {
                                "title": "Arguments",
                                "content": "\n*  **entry**: The log entry to be recorded.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "arguments",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "ReporterTrait.log",
                    "navPath": "@nav/api/MainModule.ReporterTrait.log",
                    "code": {
                        "filePath": "src/lib/context.ts",
                        "declaration": "log(entry: Entry): void",
                        "implementation": "",
                        "startLine": 66,
                        "endLine": 67,
                        "references": {
                            "log": "@nav/api/MainModule.ReporterTrait.log",
                            "Entry": "@nav/api/MainModule.Entry"
                        }
                    },
                    "semantic": {
                        "role": "method",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    }
                }
            ],
            "code": {
                "filePath": "src/lib/context.ts",
                "declaration": "export interface ReporterTrait",
                "implementation": "export interface ReporterTrait {\n    /**\n     * Logs an entry to the designated output.\n     * @param entry The log entry to be recorded.\n     */\n    log(entry: Entry): void\n}",
                "startLine": 61,
                "endLine": 68,
                "references": {
                    "ReporterTrait": "@nav/api/MainModule.ReporterTrait",
                    "Entry": "@nav/api/MainModule.Entry",
                    "ConsoleReporter": "@nav/api/MainModule.ConsoleReporter",
                    "InMemoryReporter": "@nav/api/MainModule.InMemoryReporter"
                }
            },
            "semantic": {
                "role": "interface",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "UnresolvedTarget",
            "documentation": {
                "sections": [
                    {
                        "content": "A target destination specification when the path is not resolved, either because it does not exist or because\nit is not resolved yet.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "UnresolvedTarget",
            "navPath": "@nav/api/MainModule.UnresolvedTarget",
            "attributes": [
                {
                    "name": "path",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "Target destination path.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "UnresolvedTarget.path",
                    "navPath": "@nav/api/MainModule.UnresolvedTarget.path",
                    "code": {
                        "filePath": "src/lib/router.ts",
                        "declaration": "path: string",
                        "implementation": "",
                        "startLine": 68,
                        "endLine": 69,
                        "references": {
                            "path": "@nav/api/MainModule.UnresolvedTarget.path"
                        }
                    }
                },
                {
                    "name": "reason",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "Reason for the target destination to be unresolved.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "UnresolvedTarget.reason",
                    "navPath": "@nav/api/MainModule.UnresolvedTarget.reason",
                    "code": {
                        "filePath": "src/lib/router.ts",
                        "declaration": "reason: 'Pending' | 'NotFound'",
                        "implementation": "",
                        "startLine": 73,
                        "endLine": 74,
                        "references": {
                            "reason": "@nav/api/MainModule.UnresolvedTarget.reason"
                        }
                    }
                }
            ],
            "callables": [],
            "code": {
                "filePath": "src/lib/router.ts",
                "declaration": "export interface UnresolvedTarget",
                "implementation": "export interface UnresolvedTarget {\n    /**\n     * Target destination path.\n     */\n    path: string\n\n    /**\n     * Reason for the target destination to be unresolved.\n     */\n    reason: 'Pending' | 'NotFound'\n}",
                "startLine": 64,
                "endLine": 75,
                "references": {
                    "UnresolvedTarget": "@nav/api/MainModule.UnresolvedTarget"
                }
            },
            "semantic": {
                "role": "interface",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "UrlTarget",
            "documentation": {
                "sections": [
                    {
                        "content": "Navigation URL model.\n\nSee  [parseUrl](@nav/api/MainModule.parseUrl)  for construction from a  `string` .",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "UrlTarget",
            "navPath": "@nav/api/MainModule.UrlTarget",
            "attributes": [
                {
                    "name": "issuer",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "Issuer of the URL target.\n\n*   `browser`  : when using  `next`  or  `prev`  in browser's navigation bar.\n*   `navigation`  : when using the navigation panel.\n*   `link`  : when clicking on a link.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "UrlTarget.issuer",
                    "navPath": "@nav/api/MainModule.UrlTarget.issuer",
                    "code": {
                        "filePath": "src/lib/router.ts",
                        "declaration": "issuer?: 'browser' | 'navigation' | 'link' | 'scroll'",
                        "implementation": "",
                        "startLine": 57,
                        "endLine": 58,
                        "references": {
                            "issuer": "@nav/api/MainModule.UrlTarget.issuer"
                        }
                    }
                },
                {
                    "name": "parameters",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "Additional URL parameters",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "UrlTarget.parameters",
                    "navPath": "@nav/api/MainModule.UrlTarget.parameters",
                    "code": {
                        "filePath": "src/lib/router.ts",
                        "declaration": "parameters?: Record<string, string>",
                        "implementation": "",
                        "startLine": 48,
                        "endLine": 49,
                        "references": {
                            "parameters": "@nav/api/MainModule.UrlTarget.parameters"
                        }
                    }
                },
                {
                    "name": "path",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "Target destination path.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "UrlTarget.path",
                    "navPath": "@nav/api/MainModule.UrlTarget.path",
                    "code": {
                        "filePath": "src/lib/router.ts",
                        "declaration": "path: string",
                        "implementation": "",
                        "startLine": 40,
                        "endLine": 41,
                        "references": {
                            "path": "@nav/api/MainModule.UrlTarget.path"
                        }
                    }
                },
                {
                    "name": "sectionId",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "Section Id.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "UrlTarget.sectionId",
                    "navPath": "@nav/api/MainModule.UrlTarget.sectionId",
                    "code": {
                        "filePath": "src/lib/router.ts",
                        "declaration": "sectionId?: string",
                        "implementation": "",
                        "startLine": 44,
                        "endLine": 45,
                        "references": {
                            "sectionId": "@nav/api/MainModule.UrlTarget.sectionId"
                        }
                    }
                }
            ],
            "callables": [],
            "code": {
                "filePath": "src/lib/router.ts",
                "declaration": "export interface UrlTarget",
                "implementation": "export interface UrlTarget {\n    /**\n     * Target destination path.\n     */\n    path: string\n    /**\n     * Section Id.\n     */\n    sectionId?: string\n    /**\n     * Additional URL parameters\n     */\n    parameters?: Record<string, string>\n\n    /**\n     * Issuer of the URL target.\n     *\n     * *  `browser` : when using `next` or `prev` in browser's navigation bar.\n     * *  `navigation` : when using the navigation panel.\n     * *  `link` : when clicking on a link.\n     */\n    issuer?: 'browser' | 'navigation' | 'link' | 'scroll'\n}",
                "startLine": 36,
                "endLine": 59,
                "references": {
                    "UrlTarget": "@nav/api/MainModule.UrlTarget"
                }
            },
            "semantic": {
                "role": "interface",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "AnyView",
            "documentation": {
                "sections": [
                    {
                        "content": "Represents a view that can be rendered within the application, supporting both VirtualDOM-based components\nfrom <a target=\"_blank\" href=\"/apps/@rx-vdom/doc/latest\">rx-vdom</a> and standard HTML elements.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "AnyView",
            "navPath": "@nav/api/MainModule.AnyView",
            "attributes": [],
            "callables": [],
            "code": {
                "filePath": "src/lib/navigation.node.ts",
                "declaration": "export type AnyView = AnyVirtualDOM | HTMLElement",
                "implementation": "",
                "startLine": 12,
                "endLine": 13,
                "references": {
                    "AnyView": "@nav/api/MainModule.AnyView",
                    "AnyVirtualDOM": "/apps/@rx-vdom/doc/latest?nav=/api.AnyVirtualDOM"
                }
            },
            "semantic": {
                "role": "type-alias",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "DynamicRoutes",
            "documentation": {
                "sections": [
                    {
                        "content": "Represents dynamic routes that are evaluated at runtime.\n\n- Use  [LazyRoutesCb](@nav/api/MainModule.LazyRoutesCb)  for cases where the routing structure remains constant after its first evaluation.\n- Use  [LazyRoutesCb$](@nav/api/MainModule.LazyRoutesCb$)  when the routing schema is expected to change dynamically based on signals.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    },
                    {
                        "title": "Generics",
                        "content": "\n*  **TLayout**: The type representing the layout of the application.\n*  **THeader**: The type representing the header configuration.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "arguments",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "DynamicRoutes",
            "navPath": "@nav/api/MainModule.DynamicRoutes",
            "attributes": [],
            "callables": [],
            "code": {
                "filePath": "src/lib/navigation.node.ts",
                "declaration": "export type DynamicRoutes<TLayout, THeader> =\n    | LazyRoutesCb<TLayout, THeader>\n    | LazyRoutesCb$<TLayout, THeader>",
                "implementation": "",
                "startLine": 474,
                "endLine": 475,
                "references": {
                    "DynamicRoutes": "@nav/api/MainModule.DynamicRoutes",
                    "LazyRoutesCb": "@nav/api/MainModule.LazyRoutesCb",
                    "LazyRoutesCb$": "@nav/api/MainModule.LazyRoutesCb$"
                }
            },
            "semantic": {
                "role": "type-alias",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "Label",
            "documentation": {
                "sections": [
                    {
                        "content": "Labels that categorize log entries.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "Label",
            "navPath": "@nav/api/MainModule.Label",
            "attributes": [],
            "callables": [],
            "code": {
                "filePath": "src/lib/context.ts",
                "declaration": "export type Label =\n    | 'Router'\n    | 'CompanionRouter'\n    | 'Nav'\n    | 'View'\n    | 'PageView'\n    | 'Notebook'\n    | 'CodeApi'\n    | 'Exec'\n    | 'Browser'",
                "implementation": "",
                "startLine": 6,
                "endLine": 7,
                "references": {
                    "Label": "@nav/api/MainModule.Label"
                }
            },
            "semantic": {
                "role": "type-alias",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "LayoutFactory",
            "documentation": {
                "sections": [
                    {
                        "content": "A factory mapping layout  `kind`  values to their corresponding layout generator functions.\n\nThis allows dynamic selection and instantiation of layouts based on navigation data.\n\n- Each key represents a valid  `kind`  value from the  [Navigation](@nav/api/MainModule.Navigation)  node's layout definition.\n- The associated value is a layout generator function conforming to  [LayoutGeneratorTrait](@nav/api/MainModule.LayoutGeneratorTrait) .",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    },
                    {
                        "title": "Generics",
                        "content": "\n*  **LayoutOptionsMap**: A mapping of layout  `kind`  values to their respective layout types.\n*  **THeader**: The shared header type across all layouts.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "arguments",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "LayoutFactory",
            "navPath": "@nav/api/MainModule.LayoutFactory",
            "attributes": [],
            "callables": [],
            "code": {
                "filePath": "src/lib/composite-layout.view.ts",
                "declaration": "export type LayoutFactory<LayoutOptionsMap, THeader> = {\n    [Property in keyof LayoutOptionsMap]: LayoutGeneratorTrait<\n        LayoutOptionsMap[Property],\n        THeader\n    >\n}",
                "implementation": "",
                "startLine": 47,
                "endLine": 48,
                "references": {
                    "LayoutFactory": "@nav/api/MainModule.LayoutFactory",
                    "LayoutGeneratorTrait": "@nav/api/MainModule.LayoutGeneratorTrait"
                }
            },
            "semantic": {
                "role": "type-alias",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "LayoutGeneratorTrait",
            "documentation": {
                "sections": [
                    {
                        "content": "Defines a trait for a layout generator function that can be registered in  [CompositeLayout.layoutsFactory](@nav/api/MainModule.CompositeLayout.layoutsFactory) .",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "LayoutGeneratorTrait",
            "navPath": "@nav/api/MainModule.LayoutGeneratorTrait",
            "attributes": [],
            "callables": [],
            "code": {
                "filePath": "src/lib/composite-layout.view.ts",
                "declaration": "export type LayoutGeneratorTrait<TLayout, THeader> = ({\n    router,\n}: {\n    router: Router<TLayout, THeader>\n}) => AnyView",
                "implementation": "",
                "startLine": 19,
                "endLine": 20,
                "references": {
                    "LayoutGeneratorTrait": "@nav/api/MainModule.LayoutGeneratorTrait",
                    "Router": "@nav/api/MainModule.Router",
                    "AnyView": "@nav/api/MainModule.AnyView"
                }
            },
            "semantic": {
                "role": "type-alias",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "LayoutMap",
            "documentation": {
                "sections": [
                    {
                        "content": "Type helper used by  [LayoutUnion](@nav/api/MainModule.LayoutUnion) .",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    },
                    {
                        "title": "Generics",
                        "content": "\n*  **LayoutOptionsMap**: A mapping of layout kinds to their respective layout structures.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "arguments",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "LayoutMap",
            "navPath": "@nav/api/MainModule.LayoutMap",
            "attributes": [],
            "callables": [],
            "code": {
                "filePath": "src/lib/composite-layout.view.ts",
                "declaration": "export type LayoutMap<LayoutOptionsMap> = {\n    [Property in keyof LayoutOptionsMap]: LayoutOptionsMap[Property] & {\n        kind: Property\n    }\n}",
                "implementation": "",
                "startLine": 30,
                "endLine": 31,
                "references": {
                    "LayoutMap": "@nav/api/MainModule.LayoutMap"
                }
            },
            "semantic": {
                "role": "type-alias",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "LayoutUnion",
            "documentation": {
                "sections": [
                    {
                        "content": "Resolves a **union type** of all possible layouts from a given  `LayoutOptionsMap` .\nIt is a type helper often used to specify  `LayoutOptionsMap`  of  [CompositeLayout](@nav/api/MainModule.CompositeLayout) .\n\nGiven a  `LayoutOptionsMap` , which defines different layout configurations keyed by their kind,\n `LayoutUnion<LayoutOptionsMap>`  extracts and unifies all layout types into a single **union type**.\n\n**Example**\n\n\nThis is useful for:\n- Ensuring type safety when handling layouts dynamically.\n- Allowing TypeScript to infer the correct layout type based on navigation data.\n- Supporting multiple layout kinds while maintaining flexibility.\n\n---\n\nAssume we define multiple layout types in  `LayoutOptionsMap` :\n\n<code-snippet language='javascript'>\ntype LayoutOptionsMap = {\n    default: DefaultLayout.NavLayout\n    presentation: Slide\n}\n</code-snippet>\n\nThen\n\n<code-snippet language='javascript'>\ntype AvailableLayouts = LayoutUnion<LayoutOptionsMap>\n</code-snippet>\n\nResults in:\n\n<code-snippet language='javascript'>\ntype AvailableLayouts =\n  | ({ layoutType: 'default' } & DefaultLayout.NavLayout)\n  | ({ layoutType: 'presentation'} & Slide )\n</code-snippet>\n\n---",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    },
                    {
                        "title": "Generics",
                        "content": "\n*  **LayoutOptionsMap**: A mapping of layout kinds to their respective layout structures.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "arguments",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "LayoutUnion",
            "navPath": "@nav/api/MainModule.LayoutUnion",
            "attributes": [],
            "callables": [],
            "code": {
                "filePath": "src/lib/composite-layout.view.ts",
                "declaration": "export type LayoutUnion<LayoutOptionsMap> =\n    LayoutMap<LayoutOptionsMap>[keyof LayoutMap<LayoutOptionsMap>]",
                "implementation": "",
                "startLine": 98,
                "endLine": 99,
                "references": {
                    "LayoutUnion": "@nav/api/MainModule.LayoutUnion",
                    "LayoutMap": "@nav/api/MainModule.LayoutMap"
                }
            },
            "semantic": {
                "role": "type-alias",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "LazyRoutes",
            "documentation": {
                "sections": [
                    {
                        "content": "Represents the specification of dynamic routes in the application.\n\nDynamic routes are defined as a mapping where each  `segmentId`  (representing a segment's contribution to the URL)\nis associated with a  [NavNodeData](@nav/api/MainModule.NavNodeData)  object.\n\nIt is used in the specification of  [DynamicRoutes](@nav/api/MainModule.DynamicRoutes) .",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    },
                    {
                        "title": "Generics",
                        "content": "\n*  **TLayout**: The type defining the layout configuration for the navigation.\n*  **THeader**: The type defining the header configuration for the navigation.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "arguments",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "LazyRoutes",
            "navPath": "@nav/api/MainModule.LazyRoutes",
            "attributes": [],
            "callables": [],
            "code": {
                "filePath": "src/lib/navigation.node.ts",
                "declaration": "export type LazyRoutes<TLayout, THeader> = SegmentsRecord<\n    NavNodeData<TLayout, THeader, true>\n>",
                "implementation": "",
                "startLine": 401,
                "endLine": 402,
                "references": {
                    "LazyRoutes": "@nav/api/MainModule.LazyRoutes",
                    "SegmentsRecord": "@nav/api/MainModule.SegmentsRecord",
                    "NavNodeData": "@nav/api/MainModule.NavNodeData"
                }
            },
            "semantic": {
                "role": "type-alias",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "LazyRoutesCb",
            "documentation": {
                "sections": [
                    {
                        "content": "Represents a lazy navigation resolver, used when the navigation is only known at runtime.\n\nIt is a function that takes the target path and router's instance as parameters, and returns\nthe instance of a (wrapped)  [LazyRoutes](@nav/api/MainModule.LazyRoutes)  that explicits node attributes for the given path.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "LazyRoutesCb",
            "navPath": "@nav/api/MainModule.LazyRoutesCb",
            "attributes": [],
            "callables": [],
            "code": {
                "filePath": "src/lib/navigation.node.ts",
                "declaration": "export type LazyRoutesCb<TLayout, THeader> = (p: {\n    // The targeted path in the navigation\n    path: string\n    // Router instance\n    router: Router\n}) => LazyRoutesReturn<TLayout, THeader>",
                "implementation": "",
                "startLine": 417,
                "endLine": 418,
                "references": {
                    "LazyRoutesCb": "@nav/api/MainModule.LazyRoutesCb",
                    "Router": "@nav/api/MainModule.Router",
                    "LazyRoutesReturn": "@nav/api/MainModule.LazyRoutesReturn"
                }
            },
            "semantic": {
                "role": "type-alias",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "LazyRoutesCb$",
            "documentation": {
                "sections": [
                    {
                        "content": "Represents a reactive lazy navigation resolver, used when the routing schema is expected to change dynamically\nbased on some signal.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "LazyRoutesCb$",
            "navPath": "@nav/api/MainModule.LazyRoutesCb$",
            "attributes": [],
            "callables": [],
            "code": {
                "filePath": "src/lib/navigation.node.ts",
                "declaration": "export type LazyRoutesCb$<TLayout, THeader> = Observable<\n    LazyRoutesCb<TLayout, THeader>\n>",
                "implementation": "",
                "startLine": 462,
                "endLine": 463,
                "references": {
                    "LazyRoutesCb$": "@nav/api/MainModule.LazyRoutesCb$",
                    "LazyRoutesCb": "@nav/api/MainModule.LazyRoutesCb",
                    "Observable": "https://rxjs.dev/guide/observable"
                }
            },
            "semantic": {
                "role": "type-alias",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "LazyRoutesReturn",
            "documentation": {
                "sections": [
                    {
                        "content": "Return type when defining dynamic routing (see  [LazyRoutesCb](@nav/api/MainModule.LazyRoutesCb) ).",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "LazyRoutesReturn",
            "navPath": "@nav/api/MainModule.LazyRoutesReturn",
            "attributes": [],
            "callables": [],
            "code": {
                "filePath": "src/lib/navigation.node.ts",
                "declaration": "export type LazyRoutesReturn<TLayout, THeader> =\n    | Resolvable<LazyRoutes<TLayout, THeader>>\n    | undefined",
                "implementation": "",
                "startLine": 408,
                "endLine": 409,
                "references": {
                    "LazyRoutesReturn": "@nav/api/MainModule.LazyRoutesReturn",
                    "Resolvable": "@nav/api/MainModule.Resolvable",
                    "LazyRoutes": "@nav/api/MainModule.LazyRoutes"
                }
            },
            "semantic": {
                "role": "type-alias",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "Level",
            "documentation": {
                "sections": [
                    {
                        "content": "Log levels indicating severity of an entry.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "Level",
            "navPath": "@nav/api/MainModule.Level",
            "attributes": [],
            "callables": [],
            "code": {
                "filePath": "src/lib/context.ts",
                "declaration": "export type Level = 'Info' | 'Warning' | 'Error'",
                "implementation": "",
                "startLine": 19,
                "endLine": 20,
                "references": {
                    "Level": "@nav/api/MainModule.Level"
                }
            },
            "semantic": {
                "role": "type-alias",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "Navigation",
            "documentation": {
                "sections": [
                    {
                        "content": "Represents a node within the navigation hierarchy.\n\nEach navigation node is defined by a set of core properties from  [NavNodeData](@nav/api/MainModule.NavNodeData) , which specify details\nsuch as the node's name, layout, and header configuration. The hierarchical structure of the navigation is\nestablished through the  `routes`  property, which may include either:\n-  [StaticRoutes](@nav/api/MainModule.StaticRoutes) : A predefined, fixed set of child routes.\n-  [DynamicRoutes](@nav/api/MainModule.DynamicRoutes) : Dynamically generated child routes, evaluated at runtime.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    },
                    {
                        "title": "Generics",
                        "content": "\n*  **TLayout**: The type representing the layout of the application.\n*  **THeader**: The type representing the header configuration.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "arguments",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "Navigation",
            "navPath": "@nav/api/MainModule.Navigation",
            "attributes": [],
            "callables": [],
            "code": {
                "filePath": "src/lib/navigation.node.ts",
                "declaration": "export type Navigation<TLayout, THeader> = NavNodeData<TLayout, THeader> & {\n    /**\n     * Children routes of the node.\n     */\n    routes?: StaticRoutes<TLayout, THeader> | DynamicRoutes<TLayout, THeader>\n}",
                "implementation": "",
                "startLine": 489,
                "endLine": 490,
                "references": {
                    "Navigation": "@nav/api/MainModule.Navigation",
                    "NavNodeData": "@nav/api/MainModule.NavNodeData",
                    "StaticRoutes": "@nav/api/MainModule.StaticRoutes",
                    "DynamicRoutes": "@nav/api/MainModule.DynamicRoutes"
                }
            },
            "semantic": {
                "role": "type-alias",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "NavNodeData",
            "documentation": {
                "sections": [
                    {
                        "content": "Represents the minimal set of properties for defining a node in a  [Navigation](@nav/api/MainModule.Navigation)  object.\n\nIt can conditionally include information about whether the node is a leaf node, depending on the value of the\n `WithLeafInfo`  type parameter (required when specifying  [DynamicRoutes](@nav/api/MainModule.DynamicRoutes) ).",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    },
                    {
                        "title": "Generics",
                        "content": "\n*  **TLayout**: The type defining the layout configuration for the navigation.\n*  **THeader**: The type defining the header configuration for the navigation.\n*  **WithLeafInfo**: A boolean flag determining whether the node includes leaf-specific information.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "arguments",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "NavNodeData",
            "navPath": "@nav/api/MainModule.NavNodeData",
            "attributes": [],
            "callables": [],
            "code": {
                "filePath": "src/lib/navigation.node.ts",
                "declaration": "export type NavNodeData<\n    TLayout,\n    THeader,\n    WithLeafInfo extends boolean = false,\n> = {\n    /**\n     * The name of the node.\n     */\n    name: string\n    /**\n     * Optional user-defined metadata associated with the node.\n     */\n    metadata?: unknown\n    /**\n     * The header configuration for the node.\n     */\n    header?: THeader\n    /**\n     * The layout configuration for the node.\n     */\n    layout: TLayout\n} & (WithLeafInfo extends true ? { leaf?: boolean } : Record<never, unknown>)",
                "implementation": "",
                "startLine": 24,
                "endLine": 25,
                "references": {
                    "NavNodeData": "@nav/api/MainModule.NavNodeData",
                    "NavNodeResolved": "@nav/api/MainModule.NavNodeResolved"
                }
            },
            "semantic": {
                "role": "type-alias",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "PathSegment",
            "documentation": {
                "sections": [
                    {
                        "content": "Performs static checks on a path segment.\n\nThe type  [PathSegment](@nav/api/MainModule.PathSegment)  ensures that the given string adheres to specific rules:\n- The segment must be a single static path segment (e.g.,  `/foo` ).\n- Segments containing backslashes ( `\\\\` ), query parameters ( `?` ), or fragments ( `#` ) are not allowed.\n- Nested paths (e.g.,  `/foo/bar` ) are disallowed.\n\nTo use it as validator of your segments:\n\n<code-snippet language='javascript'>\nimport segment from 'mkdocs-ts'\n\nconst routes = {\n    [segment('/foo')]: { ... },\n    // Compilation errors:\n    [segment('bar')]: { ... },\n    [segment('/bar/baz')]: { ... },\n}\n</code-snippet>",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    },
                    {
                        "title": "Generics",
                        "content": "\n*  **T**: The type of the string segment to validate.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "arguments",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "PathSegment",
            "navPath": "@nav/api/MainModule.PathSegment",
            "attributes": [],
            "callables": [],
            "code": {
                "filePath": "src/lib/navigation.node.ts",
                "declaration": "export type PathSegment<T extends string> = T extends `/${string}/${string}`\n    ? never\n    : T extends `/${string}`\n      ? T extends\n            | `${string}\\\\${string}`\n            | `${string}?${string}`\n            | `${string}#${string}`\n          ? never\n          : T\n      : never",
                "implementation": "",
                "startLine": 538,
                "endLine": 539,
                "references": {
                    "PathSegment": "@nav/api/MainModule.PathSegment"
                }
            },
            "semantic": {
                "role": "type-alias",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "Redirect",
            "documentation": {
                "sections": [
                    {
                        "content": "Represents a redirection function as used in  [Router.redirects](@nav/api/MainModule.Router.redirects) .",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "Redirect",
            "navPath": "@nav/api/MainModule.Redirect",
            "attributes": [],
            "callables": [],
            "code": {
                "filePath": "src/lib/router.ts",
                "declaration": "export type Redirect = (\n    target: UrlTarget,\n    ctx: ContextTrait,\n) => Promise<UrlTarget | undefined>",
                "implementation": "",
                "startLine": 131,
                "endLine": 132,
                "references": {
                    "Redirect": "@nav/api/MainModule.Redirect",
                    "UrlTarget": "@nav/api/MainModule.UrlTarget",
                    "ContextTrait": "@nav/api/MainModule.ContextTrait"
                }
            },
            "semantic": {
                "role": "type-alias",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "Resolvable",
            "documentation": {
                "sections": [
                    {
                        "content": "Represents a value that can be resolved to a specific type.\n\nA  `Resolvable`  can take the form of:\n- A direct value of type  `T` .\n- A  `Promise`  resolving to a value of type  `T` .\n- An  `Observable`  emitting values of type  `T` .\n\n<note level=\"warning\">\nWhen an  `Observable`  is provided, only its **first emission** is considered.\nSubsequent emissions are ignored.\n</note>",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    },
                    {
                        "title": "Generics",
                        "content": "\n*  **T**: The type of the value that can be resolved.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "arguments",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "Resolvable",
            "navPath": "@nav/api/MainModule.Resolvable",
            "attributes": [],
            "callables": [],
            "code": {
                "filePath": "src/lib/navigation.node.ts",
                "declaration": "export type Resolvable<T> = T | Promise<T> | Observable<T>",
                "implementation": "",
                "startLine": 369,
                "endLine": 370,
                "references": {
                    "Resolvable": "@nav/api/MainModule.Resolvable",
                    "Observable": "https://rxjs.dev/guide/observable"
                }
            },
            "semantic": {
                "role": "type-alias",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "SegmentsRecord",
            "documentation": {
                "sections": [
                    {
                        "content": "This is commonly used to associate specific data or configurations with individual\npath segments.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    },
                    {
                        "title": "Generics",
                        "content": "\n*  **T**: The type of the value associated with each path segment.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "arguments",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "SegmentsRecord",
            "navPath": "@nav/api/MainModule.SegmentsRecord",
            "attributes": [],
            "callables": [],
            "code": {
                "filePath": "src/lib/navigation.node.ts",
                "declaration": "export type SegmentsRecord<T> = Record<string, T>",
                "implementation": "",
                "startLine": 388,
                "endLine": 389,
                "references": {
                    "SegmentsRecord": "@nav/api/MainModule.SegmentsRecord"
                }
            },
            "semantic": {
                "role": "type-alias",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "StaticRoutes",
            "documentation": {
                "sections": [
                    {
                        "content": "Represents the definition of static routes in the application.\n\nStatic routes are defined as a mapping where each  `segmentId`  (representing a segment's contribution to the URL)\nis associated with a  [Resolvable](@nav/api/MainModule.Resolvable)   [Navigation](@nav/api/MainModule.Navigation)  object.\n\nThe  [PathSegment](@nav/api/MainModule.PathSegment)  type define the valid string for a  `segmentId`  definition (in a nutshell: starts with  `/` ,\nand not using spaces or special characters not allowed in URLs).\n\n<note level=\"hint\">\nThe  [segment](@nav/api/MainModule.segment)  function performs both static and dynamic checks to validate the segment ID.\n</note>\n\n\n<note level=\"hint\" title=\"Promise\">\nPromises can be used, for instance, when requests need to be triggered to fetch attributes or metadata\nfor a navigation node. In such cases, the navigation tree will wait for the promise to resolve before updating its\nstate.\n\nIn the common scenario where only the layout's content requires an asynchronous task to resolve,\nit is often possible to specify this dependency within the layout itself. This approach allows the\nnavigation tree to avoid waiting for the task's resolution, as the asynchronous handling is confined\nto the layout specification.\n</note>",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    },
                    {
                        "title": "Generics",
                        "content": "\n*  **TLayout**: The type defining the layout configuration for the navigation.\n*  **THeader**: The type defining the header configuration for the navigation.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "arguments",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "StaticRoutes",
            "navPath": "@nav/api/MainModule.StaticRoutes",
            "attributes": [],
            "callables": [],
            "code": {
                "filePath": "src/lib/navigation.node.ts",
                "declaration": "export type StaticRoutes<TLayout, THeader> = Record<\n    string,\n    Resolvable<Navigation<TLayout, THeader>>\n>",
                "implementation": "",
                "startLine": 453,
                "endLine": 454,
                "references": {
                    "StaticRoutes": "@nav/api/MainModule.StaticRoutes",
                    "Resolvable": "@nav/api/MainModule.Resolvable",
                    "Navigation": "@nav/api/MainModule.Navigation"
                }
            },
            "semantic": {
                "role": "type-alias",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "Target",
            "documentation": {
                "sections": [
                    {
                        "content": "Target destination specification when navigating to a (resolved) specific path.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "Target",
            "navPath": "@nav/api/MainModule.Target",
            "attributes": [],
            "callables": [],
            "code": {
                "filePath": "src/lib/router.ts",
                "declaration": "export type Target<TLayout = unknown, THeader = unknown> = UrlTarget & {\n    /**\n     * Associated navigation's node.\n     */\n    node: Navigation<TLayout, THeader>\n}",
                "implementation": "",
                "startLine": 79,
                "endLine": 80,
                "references": {
                    "Target": "@nav/api/MainModule.Target",
                    "UrlTarget": "@nav/api/MainModule.UrlTarget",
                    "Navigation": "@nav/api/MainModule.Navigation"
                }
            },
            "semantic": {
                "role": "type-alias",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "ViewGenerator",
            "documentation": {
                "sections": [
                    {
                        "content": "Type definition for custom view generators.\n\nThe function takes as arguments:\n*  **elem**: The HTMLElement in Markdown that triggered the generator.\n*  **options**: The options that were provided to the MD parser.\n\nIt returns the generated virtual DOM.\n\n See details in the documentation of  [parseMd](@nav/api/MainModule.parseMd)  to register views.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "ViewGenerator",
            "navPath": "@nav/api/MainModule.ViewGenerator",
            "attributes": [],
            "callables": [],
            "code": {
                "filePath": "src/lib/markdown.ts",
                "declaration": "export type ViewGenerator = (\n    elem: HTMLElement,\n    options: { router?: Router } & MdParsingOptions,\n) => AnyView",
                "implementation": "",
                "startLine": 27,
                "endLine": 28,
                "references": {
                    "ViewGenerator": "@nav/api/MainModule.ViewGenerator",
                    "Router": "@nav/api/MainModule.Router",
                    "MdParsingOptions": "@nav/api/MainModule.MdParsingOptions",
                    "AnyView": "@nav/api/MainModule.AnyView"
                }
            },
            "semantic": {
                "role": "type-alias",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        }
    ],
    "callables": [
        {
            "name": "Contextual",
            "documentation": {
                "sections": [
                    {
                        "content": "Decorator for methods that execute within a given context.\nThis decorator ensures that the method receives a valid context\nand executes within it, handling both synchronous and asynchronous methods.\n\n<note level='warning' title='Important'>\nTo disable the decorator globally, set  [Context.Enabled](@nav/api/MainModule.Context.Enabled)  to  `false`  using  StaticConfig .\n</note>",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    },
                    {
                        "title": "Returns",
                        "content": "A method decorator that wraps the original method with contextual execution.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "returns",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "Contextual",
            "navPath": "@nav/api/MainModule.Contextual",
            "code": {
                "filePath": "src/lib/context.ts",
                "declaration": "export function Contextual({\n    key,\n    labels,\n    async,\n}: {\n    key?: (...args: unknown[]) => string\n    labels?: Label[]\n    async?: boolean\n} = {})",
                "implementation": "export function Contextual({\n    key,\n    labels,\n    async,\n}: {\n    key?: (...args: unknown[]) => string\n    labels?: Label[]\n    async?: boolean\n} = {}) {\n    /**\n     * I'm not able to properly write type specification for this decorator.\n     */\n    /* eslint-disable @typescript-eslint/no-unsafe-assignment */\n    /* eslint-disable @typescript-eslint/no-unsafe-return */\n    /* eslint-disable @typescript-eslint/no-unsafe-argument */\n    return function actualDecorator(\n        originalMethod: (...args: unknown[]) => unknown,\n        context: ClassMethodDecoratorContext,\n    ) {\n        const methodName = String(context.name)\n        if (!Context.Enabled) {\n            return originalMethod\n        }\n        function replacementMethod(this, ...args) {\n            if (!Context.Enabled) {\n                return originalMethod.apply(this, [...args, undefined])\n            }\n            const ctx = args[args.length - 1]\n            if (!isContextTrait(ctx)) {\n                return originalMethod.apply(this, [...args, undefined])\n            }\n            let name = methodName\n            if (key) {\n                name += `(${key(...args)})`\n            }\n            const params: [\n                string,\n                (ctx: ContextTrait) => Promise<unknown>,\n                Label[] | undefined,\n            ] = [\n                name,\n                (ctx: ContextTrait) => {\n                    return originalMethod.apply(this, [\n                        ...args.slice(0, -1),\n                        ctx,\n                    ])\n                },\n                labels,\n            ]\n            return async\n                ? ctx.executeAsync<unknown>(...params)\n                : ctx.execute<unknown>(...params)\n        }\n        return replacementMethod\n    }\n}",
                "startLine": 344,
                "endLine": 400,
                "references": {
                    "Contextual": "@nav/api/MainModule.Contextual",
                    "Label": "@nav/api/MainModule.Label"
                }
            },
            "semantic": {
                "role": "function",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "installCodeApiModule",
            "documentation": {
                "sections": [
                    {
                        "content": "Install and returns the  [CodeApiModule](@nav/api/CodeApi)  module.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "installCodeApiModule",
            "navPath": "@nav/api/MainModule.installCodeApiModule",
            "code": {
                "filePath": "src/lib/plugins.ts",
                "declaration": "export async function installCodeApiModule()",
                "implementation": "export async function installCodeApiModule() {\n    const module = (await setup.installAuxiliaryModule({\n        name: 'CodeApi',\n        cdnClient: webpmClient,\n    })) as typeof CodeApiModule\n    module.Dependencies.parseMd = parseMd\n    module.Dependencies.DefaultLayout = DefaultLayout\n    module.Dependencies.installNotebookModule = installNotebookModule\n    module.Dependencies.headingId = headingId\n    return module\n}",
                "startLine": 12,
                "endLine": 23,
                "references": {
                    "installCodeApiModule": "@nav/api/MainModule.installCodeApiModule",
                    "__module": "@nav/api/CodeApi"
                }
            },
            "semantic": {
                "role": "function",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "installNotebookModule",
            "documentation": {
                "sections": [
                    {
                        "content": "Install and returns the  [NotebookModule](@nav/api/Notebook)  module.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "installNotebookModule",
            "navPath": "@nav/api/MainModule.installNotebookModule",
            "code": {
                "filePath": "src/lib/plugins.ts",
                "declaration": "export async function installNotebookModule()",
                "implementation": "export async function installNotebookModule() {\n    const module = (await setup.installAuxiliaryModule({\n        name: 'Notebook',\n        cdnClient: webpmClient,\n    })) as typeof NotebookModule\n    module.Dependencies.parseMd = parseMd\n    module.Dependencies.MdWidgets = MdWidgets\n    return module\n}",
                "startLine": 27,
                "endLine": 36,
                "references": {
                    "installNotebookModule": "@nav/api/MainModule.installNotebookModule",
                    "__module": "@nav/api/Notebook"
                }
            },
            "semantic": {
                "role": "function",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "isContextTrait",
            "documentation": {
                "sections": [
                    {
                        "content": "Type guard to check if an object implements  [ContextTrait](@nav/api/MainModule.ContextTrait) .",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    },
                    {
                        "title": "Arguments",
                        "content": "\n*  **obj**: The object to check.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "arguments",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    },
                    {
                        "title": "Returns",
                        "content": "True if obj conforms to  [ContextTrait](@nav/api/MainModule.ContextTrait) , otherwise false.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "returns",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "isContextTrait",
            "navPath": "@nav/api/MainModule.isContextTrait",
            "code": {
                "filePath": "src/lib/context.ts",
                "declaration": "export function isContextTrait(obj: unknown): obj is ContextTrait",
                "implementation": "export function isContextTrait(obj: unknown): obj is ContextTrait {\n    return (\n        obj !== null &&\n        typeof obj === 'object' &&\n        'info' in obj &&\n        typeof obj.info === 'function' &&\n        'execute' in obj &&\n        typeof obj.execute === 'function' &&\n        'start' in obj &&\n        typeof obj.start === 'function' &&\n        'exit' in obj &&\n        typeof obj.exit === 'function'\n    )\n}",
                "startLine": 180,
                "endLine": 194,
                "references": {
                    "isContextTrait": "@nav/api/MainModule.isContextTrait",
                    "ContextTrait": "@nav/api/MainModule.ContextTrait"
                }
            },
            "semantic": {
                "role": "function",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "parseMd",
            "documentation": {
                "sections": [
                    {
                        "content": "Parse Markdown source to generate corresponding view. See  [MdParsingOptions](@nav/api/MainModule.MdParsingOptions)  for examples.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    },
                    {
                        "title": "Arguments",
                        "content": "\n*  **args**: The  [MdParsingOptions](@nav/api/MainModule.MdParsingOptions)  completed by:\n*  **router**: Optional router instance, to enable navigation related feature.\n*  **src**: Markdown source.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "arguments",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    },
                    {
                        "title": "Returns",
                        "content": "A virtual DOM encapsulating the parsed Markdown.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "returns",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "parseMd",
            "navPath": "@nav/api/MainModule.parseMd",
            "code": {
                "filePath": "src/lib/markdown.ts",
                "declaration": "export function parseMd({\n    src,\n    router,\n    views,\n    placeholders,\n    preprocessing,\n    latex,\n    onRendered,\n}: {\n    src: string\n    router?: Router\n} & MdParsingOptions): VirtualDOM<'div'>",
                "implementation": "export function parseMd({\n    src,\n    router,\n    views,\n    placeholders,\n    preprocessing,\n    latex,\n    onRendered,\n}: {\n    src: string\n    router?: Router\n} & MdParsingOptions): VirtualDOM<'div'> {\n    src = preprocessing?.(src) ?? src\n    if (placeholders && Object.keys(placeholders).length > 0) {\n        const regex = new RegExp(Object.keys(placeholders).join('|'), 'g')\n        src = src.replace(regex, (match) => placeholders[match])\n    }\n    views = { ...views, ...GlobalMarkdownViews.factory }\n    const { div, replacedViews } = fixedMarkedParseCustomViews({\n        input: src,\n        views: views,\n    })\n\n    // @ts-expect-error Need to find a better way\n    if (latex && window.MathJax) {\n        // eslint-disable-next-line\n        window['MathJax'].typeset([div])\n    }\n\n    const customs = div.querySelectorAll('.language-custom-view')\n    ;[...customs]\n        .filter((custom) => custom instanceof HTMLElement)\n        .forEach((custom) => {\n            // eslint-disable-next-line @typescript-eslint/no-implied-eval,@typescript-eslint/no-unsafe-call\n            const fct = new Function(custom.innerText)()({\n                webpm,\n            }) as unknown as Promise<AnyVirtualDOM>\n            const view = render({\n                tag: 'div',\n                children: [\n                    child$({\n                        source$: from(fct),\n                        vdomMap: (vDom) => vDom,\n                    }),\n                ],\n            })\n            custom.parentNode?.parentNode?.replaceChild(view, custom.parentNode)\n        })\n\n    const options = {\n        router,\n        preprocessing,\n        placeholders,\n        latex,\n        views,\n        onRendered,\n    }\n    const viewsTagUpperCase: Record<\n        Uppercase<string>,\n        ViewGenerator\n    > = Object.entries(views).reduce(\n        (acc, [k, v]) => ({ ...acc, [k.toUpperCase()]: v }),\n        {},\n    )\n    Object.entries(replacedViews).forEach(([k, content]: [string, string]) => {\n        const elem = div.querySelector(`#${k}`)\n        if (!elem || !(elem instanceof HTMLElement)) {\n            return\n        }\n        elem.textContent = content\n        if (!((elem.tagName as Uppercase<string>) in viewsTagUpperCase)) {\n            return\n        }\n        const factory = viewsTagUpperCase[elem.tagName as Uppercase<string>]\n        const replacedView = factory(elem, options)\n        elem.parentNode?.replaceChild(\n            replacedView instanceof HTMLElement\n                ? replacedView\n                : render(replacedView),\n            elem,\n        )\n    })\n\n    return {\n        tag: 'div',\n        children: [div],\n        connectedCallback: (elem) => {\n            // Navigation links\n            if (router) {\n                replaceLinks({ router, elem, fromMarkdown: true })\n            }\n            if (onRendered) {\n                onRendered(elem)\n            }\n        },\n    }\n}",
                "startLine": 231,
                "endLine": 328,
                "references": {
                    "parseMd": "@nav/api/MainModule.parseMd",
                    "Router": "@nav/api/MainModule.Router",
                    "MdParsingOptions": "@nav/api/MainModule.MdParsingOptions",
                    "VirtualDOM": "/apps/@rx-vdom/doc/latest?nav=/api.VirtualDOM"
                }
            },
            "semantic": {
                "role": "function",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "parseMdFromUrl",
            "documentation": {
                "sections": [
                    {
                        "content": "Just like  [parseMd](@nav/api/MainModule.parseMd) , but the source is first fetched using an HTTP get request using the provided URL.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    },
                    {
                        "title": "Arguments",
                        "content": "\n*  **params**: The  [MdParsingOptions](@nav/api/MainModule.MdParsingOptions)  completed by:\n*  **router**: Optional router instance,  to enable navigation related feature.\n*  **url**: The URL from which the source content is fetched.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "arguments",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "parseMdFromUrl",
            "navPath": "@nav/api/MainModule.parseMdFromUrl",
            "code": {
                "filePath": "src/lib/markdown.ts",
                "declaration": "export async function parseMdFromUrl(\n    params: {\n        url: string\n        router?: Router\n    } & MdParsingOptions,\n)",
                "implementation": "export async function parseMdFromUrl(\n    params: {\n        url: string\n        router?: Router\n    } & MdParsingOptions,\n) {\n    const resp = await fetch(params.url)\n    return parseMd({\n        src: await resp.text(),\n        router: params.router,\n        ...params,\n    })\n}",
                "startLine": 210,
                "endLine": 223,
                "references": {
                    "parseMdFromUrl": "@nav/api/MainModule.parseMdFromUrl",
                    "Router": "@nav/api/MainModule.Router",
                    "MdParsingOptions": "@nav/api/MainModule.MdParsingOptions",
                    "VirtualDOM": "/apps/@rx-vdom/doc/latest?nav=/api.VirtualDOM"
                }
            },
            "semantic": {
                "role": "function",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "parseUrl",
            "documentation": {
                "sections": [
                    {
                        "content": "Parse a URL as string into a  [UrlTarget](@nav/api/MainModule.UrlTarget)  - only query parameters are relevant.\n\n*   [UrlTarget.path](@nav/api/MainModule.UrlTarget.path)  is extracted from the  `nav`  query parameter.\n*   [UrlTarget.parameters](@nav/api/MainModule.UrlTarget.parameters)  are other query parameters.\n*   [UrlTarget.sectionId](@nav/api/MainModule.UrlTarget.sectionId)  is specified by the part after the first  `.`  in the  `nav`  query parameter.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    },
                    {
                        "title": "Arguments",
                        "content": "\n*  **url**: String to parse.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "arguments",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    },
                    {
                        "title": "Returns",
                        "content": "The target",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "returns",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "parseUrl",
            "navPath": "@nav/api/MainModule.parseUrl",
            "code": {
                "filePath": "src/lib/browser.interface.ts",
                "declaration": "export function parseUrl(url: string): UrlTarget",
                "implementation": "export function parseUrl(url: string): UrlTarget {\n    const urlParams = new URLSearchParams(url)\n    const nav = sanitizeNavPath(urlParams.get('nav') ?? '/')\n\n    const parameters = Object.fromEntries(urlParams.entries())\n    delete parameters.nav\n    if (!nav.includes('.')) {\n        return {\n            path: nav,\n            parameters,\n        }\n    }\n    return {\n        path: nav.split('.')[0],\n        parameters,\n        sectionId: nav.split('.').slice(1).join('.'),\n    }\n}",
                "startLine": 118,
                "endLine": 136,
                "references": {
                    "parseUrl": "@nav/api/MainModule.parseUrl",
                    "UrlTarget": "@nav/api/MainModule.UrlTarget"
                }
            },
            "semantic": {
                "role": "function",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "removeEscapedText",
            "documentation": {
                "sections": [
                    {
                        "content": "This function takes an input text, remove the escaped parts:\n*  a line start with triple back-quote: this line is escaped as well as all the following line until one starts\nwith triple back-quote.\n*  a line include a single back quote: the remaining of the line as well as all the following line until a corresponding\nsingle back-quote is found.\n\nWhen a part of the input is escaped it is replaced by a string  `__ESCAPED_${ID}`  where ID is a unique ID,\nthe function returned the escaped text as well as a dict that gathers the escaped elements.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "removeEscapedText",
            "navPath": "@nav/api/MainModule.removeEscapedText",
            "code": {
                "filePath": "src/lib/markdown.ts",
                "declaration": "export function removeEscapedText(src: string): {\n    escapedContent: string\n    replaced: Record<string, string>\n}",
                "implementation": "export function removeEscapedText(src: string): {\n    escapedContent: string\n    replaced: Record<string, string>\n} {\n    let escapedContent = src // Initialize the escaped content with the source text\n    const replaced = {} // Initialize an object to store the replaced escaped elements\n\n    // Regular expression patterns to match escaped parts\n    const tripleBackquotePattern = /```([\\s\\S]*?)```/g\n\n    // Replace triple back-quote escaped parts\n    escapedContent = escapedContent.replace(tripleBackquotePattern, (match) => {\n        const id = `__ESCAPED_${String(Object.keys(replaced).length)}` // Generate a unique ID\n        replaced[id] = match // Store the escaped part in the replaced object\n        return id // Replace the escaped part with the unique ID\n    })\n\n    // Regular expression pattern to match single back-quoted escaped parts spanning multiple lines\n    const multilineBackquotePattern = /`([\\s\\S]*?)`/g\n\n    // Replace single back-quote escaped parts\n    escapedContent = escapedContent.replace(\n        multilineBackquotePattern,\n        (match) => {\n            const id = `__ESCAPED_${String(Object.keys(replaced).length)}` // Generate a unique ID\n            replaced[id] = match // Store the escaped part in the replaced object\n            return id // Replace the escaped part with the unique ID\n        },\n    )\n\n    return { escapedContent, replaced }\n}",
                "startLine": 432,
                "endLine": 464,
                "references": {
                    "removeEscapedText": "@nav/api/MainModule.removeEscapedText"
                }
            },
            "semantic": {
                "role": "function",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "replaceLinks",
            "documentation": {
                "sections": [
                    {
                        "content": "This function scans all anchor ( `<a>` ) elements inside  `elem`  with  `href`  starting with  `@nav`  marker and\ntransforms them with an anchor element that properly triggers a navigation event to the path defined\nafter the  `@nav`  marker.\n\nThe processed anchors typically have the form  `<a href='@nav/path/to/link'>link</a>` .\nThe transformation is basically executing:\n<code-snippet language=\"javascript\">\nif (link.href.includes('@nav')) {\n    const path =  `nav=${link.href.split('@nav')[1]}` \n    link.href =  `${router.basePath}?${path}` \n    link.onclick = (e: MouseEvent) => {\n        e.preventDefault()\n        router.fireNavigateTo(path)\n    }\n}\n</code-snippet>\n\nIf  `fromMarkdown`  is  `true` , it processes metadata stored in the  `title`  attribute (e.g., additional CSS classes)\nfor links that were generated from Markdown content.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    },
                    {
                        "title": "Arguments",
                        "content": "\n*  **elem**: The HTML element containing links to be processed.\n*  **fromMarkdown**: Whether the links originate from Markdown content.\n*  **router**: The router instance used for navigation.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "arguments",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "replaceLinks",
            "navPath": "@nav/api/MainModule.replaceLinks",
            "code": {
                "filePath": "src/lib/markdown.ts",
                "declaration": "export function replaceLinks({\n    router,\n    elem,\n    fromMarkdown,\n}: {\n    router: Router\n    elem: HTMLElement\n    fromMarkdown: boolean\n})",
                "implementation": "export function replaceLinks({\n    router,\n    elem,\n    fromMarkdown,\n}: {\n    router: Router\n    elem: HTMLElement\n    fromMarkdown: boolean\n}) {\n    const links = elem.querySelectorAll('a')\n    links.forEach((link) => {\n        if (link.href.includes('@nav')) {\n            const path = `nav=${link.href.split('@nav')[1]}`\n            link.href = `${router.basePath}?${path}`\n            link.onclick = (e: MouseEvent) => {\n                e.preventDefault()\n                const target = parseUrl(path)\n                router.fireNavigateTo({ ...target, issuer: 'link' })\n            }\n            if (fromMarkdown && link.title) {\n                // When the anchor is generated from markdown, the title is used to append classes to the generated\n                // element.\n                const metadata_json = JSON.parse(\n                    link.title,\n                ) as unknown as Record<string, string | undefined>\n                link.title = ''\n                const classes = metadata_json.class?.split(' ') ?? []\n                link.classList.add(...classes)\n            }\n        }\n    })\n}",
                "startLine": 536,
                "endLine": 568,
                "references": {
                    "replaceLinks": "@nav/api/MainModule.replaceLinks",
                    "Router": "@nav/api/MainModule.Router"
                }
            },
            "semantic": {
                "role": "function",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "sanitizeNavPath",
            "documentation": {
                "sections": [
                    {
                        "content": "Sanitize an input navigation path:\n*  Ensures single starting '/'.\n*  Corrects for empty path sequence, *e.g.*  `foo//bar/.baz`  ->  `/foo/bar.baz`",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    },
                    {
                        "title": "Arguments",
                        "content": "\n*  **path**: The input path.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "arguments",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    },
                    {
                        "title": "Returns",
                        "content": "The sanitized path.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "returns",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "sanitizeNavPath",
            "navPath": "@nav/api/MainModule.sanitizeNavPath",
            "code": {
                "filePath": "src/lib/navigation.node.ts",
                "declaration": "export function sanitizeNavPath(path: string)",
                "implementation": "export function sanitizeNavPath(path: string) {\n    return (\n        '/' +\n        path\n            .replace(/^\\/+/, '') // Remove leading slashes\n            .replace(/\\/+/g, '/') // Collapse multiple slashes\n            .replace('/.', '.') // Fix misplaced dot\n            .replace(/\\/+$/, '') // Remove trailing slashes\n    )\n}",
                "startLine": 504,
                "endLine": 514,
                "references": {
                    "sanitizeNavPath": "@nav/api/MainModule.sanitizeNavPath"
                }
            },
            "semantic": {
                "role": "function",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "segment",
            "documentation": {
                "sections": [
                    {
                        "content": "Validates a static path segment at compile time.\n\nThis function uses the  [PathSegment](@nav/api/MainModule.PathSegment)  type to perform static validation\nof the provided segment ID. It ensures that the segment complies with the\nrequired format and restrictions.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    },
                    {
                        "title": "Arguments",
                        "content": "\n*  **p**: The segment ID to validate (e.g.,  `/foo` ).",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "arguments",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    },
                    {
                        "title": "Returns",
                        "content": "The validated segment if it passes all static checks.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "returns",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "segment",
            "navPath": "@nav/api/MainModule.segment",
            "code": {
                "filePath": "src/lib/navigation.node.ts",
                "declaration": "export function segment<T extends string>(p: PathSegment<T>)",
                "implementation": "export function segment<T extends string>(p: PathSegment<T>) {\n    return p\n}",
                "startLine": 559,
                "endLine": 562,
                "references": {
                    "segment": "@nav/api/MainModule.segment",
                    "PathSegment": "@nav/api/MainModule.PathSegment"
                }
            },
            "semantic": {
                "role": "function",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        }
    ],
    "files": [
        {
            "name": "index.ts",
            "path": "src/lib/default-layout/index.ts",
            "documentation": {
                "sections": [
                    {
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        },
                        "content": "This module gathers views definition.",
                        "contentType": "markdown"
                    }
                ]
            }
        },
        {
            "name": "index.ts",
            "path": "src/lib/md-widgets/index.ts",
            "documentation": {
                "sections": [
                    {
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        },
                        "content": "This module defines a collection of widgets that can be instantiated directly from Markdown\nsource when using the  function. Widgets are referenced within ,\nwhich maps `tag-name -> implementation` to enable seamless integration into Markdown content.\n\nEach widget provides a static `fromHTMLElement` method that specifies the attributes required for its instantiation.\n\n## Overview\n\nBelow are examples of the available widgets. For detailed documentation on their attributes and behavior,\nrefer to their respective sections. Additionally, you can create custom widgets and register them globally\nfor your application. See the section **New Widgets** for guidance.\n\n\n---\n\n### \n\n<md-cell>\n\n<note level=\"info\">\nLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna\naliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\n</note>\n</md-cell>\n\n---\n\n### \n\n<md-cell>\n<code-snippet language=\"javascript\" highlightedLines=\"8\">\n\nfunction compute({improbabilityFactor, babelFishCount, vogonPoetryExposure, towelAbsorbency }){\n    console.log(\"Computation complete! The result is 42\");\n    const result =\n        Math.log(improbabilityFactor + 42) +\n        babelFishCount === 1 ? 1 : Math.sqrt(babelFishCount) +\n        vogonPoetryExposure > 1000 ? -42 : vogonPoetryExposure / 100 +\n        towelAbsorbency * (Math.random() + 0.42)\n    return 42;\n}\n</code-snippet>\n</md-cell>\n\n---\n\n### \n\n<md-cell>\n<code-badges version=\"{{mkdocs-version}}\" npm=\"mkdocs-ts\" github=\"w3nest/mkdocs-ts\" license=\"mit\">\n</code-badges>\n</md-cell>\n\n---\n\n## New Widgets\nTo extend the functionality of , you can define and register custom widgets globally.\n\n---\n\n### Step 1: Define Implementation\n\n<js-cell>\nconst { MkDocs, TP } = await webpm.install({\n    esm:[\n        'mkdocs-ts#{{mkdocs-version}} as MkDocs',\n        'tweakpane#^4.0.1 as TP',\n    ]\n})\n\nconst customViewExample = (element) => {\n    const pane = new TP.Pane()\n    const getAttr = (name, defaultVal) => parseFloat(element.getAttribute(name) ?? defaultVal )\n    const params = {\n        improbabilityFactor: getAttr('improbabilityFactor', 3),\n        babelFishCount: getAttr('babelFishCount', 1),\n        vogonPoetryExposure: getAttr('vogonPoetryExposure', 250),\n        towelAbsorbency: getAttr('towelAbsorbency', 2),\n    };\n    Object.keys(params).forEach((k) => pane.addBinding(params, k))\n    pane.addButton({ title: 'Compute', label: ''}).on('click', () => computeCb(params));\n    return pane.element\n}\n</js-cell>\n\n---\n\n### Step 2: Register Element\n\n<js-cell>\nMkDocs.GlobalMarkdownViews.factory = {\n    ...MkDocs.GlobalMarkdownViews.factory,\n    'custom-view-example' : (element) => customViewExample(element)\n}\n</js-cell>\n\nSee  for details.\n\n---\n\n### Step 3: Enjoy\n\n<md-cell>\nBelow is the custom view `custom-view-example` instantiated with `improbabilityFactor=5`:\n\n<custom-view-example improbabilityFactor=\"5.00\">\n</custom-view-example>\n</md-cell>",
                        "contentType": "markdown"
                    }
                ]
            }
        },
        {
            "name": "composite-layout.view.ts",
            "path": "src/lib/composite-layout.view.ts",
            "documentation": {
                "sections": [
                    {
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        },
                        "content": "",
                        "contentType": "markdown"
                    }
                ]
            }
        },
        {
            "name": "context.ts",
            "path": "src/lib/context.ts",
            "documentation": {
                "sections": [
                    {
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        },
                        "content": "",
                        "contentType": "markdown"
                    }
                ]
            }
        },
        {
            "name": "markdown.ts",
            "path": "src/lib/markdown.ts",
            "documentation": {
                "sections": [
                    {
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        },
                        "content": "This file gathers entry points related to Mardown parsing.",
                        "contentType": "markdown"
                    }
                ]
            }
        },
        {
            "name": "browser.interface.ts",
            "path": "src/lib/browser.interface.ts",
            "documentation": {
                "sections": [
                    {
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        },
                        "content": "",
                        "contentType": "markdown"
                    }
                ]
            }
        },
        {
            "name": "navigation.node.ts",
            "path": "src/lib/navigation.node.ts",
            "documentation": {
                "sections": [
                    {
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        },
                        "content": "",
                        "contentType": "markdown"
                    }
                ]
            }
        },
        {
            "name": "router.ts",
            "path": "src/lib/router.ts",
            "documentation": {
                "sections": [
                    {
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        },
                        "content": "",
                        "contentType": "markdown"
                    }
                ]
            }
        },
        {
            "name": "plugins.ts",
            "path": "src/lib/plugins.ts",
            "documentation": {
                "sections": [
                    {
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        },
                        "content": "",
                        "contentType": "markdown"
                    }
                ]
            }
        },
        {
            "name": "index.ts",
            "path": "src/index.ts",
            "documentation": {
                "sections": [
                    {
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        },
                        "content": "# Overview\n\nThis is the **main module** of the library.\n\n## Core\n\nThe module defines the  class, responsible for handling navigation between  nodes.\n\n## Views\n\nIn terms of views, this module provides a , which can wrap multiple layout types.\nThe library also includes a default layout, defined in the  module.\n\n## Markdown\n\nThe module includes Markdown processing utilities through the  and  functions.\n\nVarious options are available, including support for defining custom views.\n\n## Logging\n\nThe module provides utilities for  management, offering structured logging across the package.\nIt includes two built-in reporters, both implementing :\n\n-  (logs to the console).\n\n-  (stores logs in memory).\n\n## Plugins\n\nTwo plugins are included:\n\n- **Code API Module** ()\n  - Installed using .\n  - Enables automatic generation of pages from code API documentation.\n\n- **Notebook Module** ()\n  - Installed using .\n  - Supports pages with live code execution.",
                        "contentType": "markdown"
                    }
                ]
            }
        }
    ],
    "children": [
        {
            "name": "DefaultLayout",
            "semantic": {
                "role": "module",
                "labels": [],
                "attributes": {},
                "relations": {}
            },
            "path": "mkdocs-ts/MainModule.DefaultLayout",
            "navPath": "@nav/api/MainModule/DefaultLayout",
            "isLeaf": true
        },
        {
            "name": "MdWidgets",
            "semantic": {
                "role": "module",
                "labels": [],
                "attributes": {},
                "relations": {}
            },
            "path": "mkdocs-ts/MainModule.MdWidgets",
            "navPath": "@nav/api/MainModule/MdWidgets",
            "isLeaf": true
        }
    ],
    "semantic": {
        "role": "module",
        "labels": [],
        "attributes": {},
        "relations": {}
    }
}
