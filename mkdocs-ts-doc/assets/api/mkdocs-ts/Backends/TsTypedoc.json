{
    "name": "TsTypedoc",
    "documentation": {
        "sections": [
            {
                "content": "Backend for generating API data for TypeScript projects using TypeDoc as the primary documentation generator.\n\nThis parser supports a subset of the tags available in TypeDoc. Many tags are omitted because their meaning is\nimplied by the entity declaration. For example, tags like  `@interface` ,  `@public` ,  `@private` ,  `@property` ,\n `@readonly` , and  `@virtual`  are unnecessary as their semantics are inherent in the code structure.\n\nSome tags are related to grouping, such as  `@group` ,  `@category` ,  `@categoryDescription` , and\n `@groupDescription` . Currently, entities are grouped based on the files they belong to, with the possibility of\nincluding documentation sections at the beginning of each file. Additional semantic grouping is not yet supported.\n\nIn practical terms, the essentials tags used are:\n[ `@param` ](https://typedoc.org/tags/param/), [ `@returns` ](https://typedoc.org/tags/returns/),\n[ `@typeParams` ](https://typedoc.org/tags/typeParam/), [ `@module` ](https://typedoc.org/tags/module/),\n[ `@link` ](https://typedoc.org/tags/link/).\n\n**Comparison**:\n\nOverall the documentation displayed by  `@youwol/mkdocs-ts`  is lighter than its typedoc counterpart,\nbut some resolution are (rarely) failing.\n\nSee for instance the  `parseCallable`  function:\n*  <a target=\"_blank\" href=\"/api/assets-gateway/cdn-backend/resources/QHlvdXdvbC9ta2RvY3MtdHM=/0.3.3/dist/docs/functions/Backends.TsTypedoc.parseCallable.html\">\n    Within typedoc</a>\n*  And here:  [parseCallable](@nav/api/Backends/TsTypedoc.parseCallable) \n\nThe missing type  `SignaturesTrait`  is an artifact due to loss of type information when using typedoc,\ngoing further will likely imply to manage our-self the entire process of code parsing using typescript AST API.\n\n**Important Notes**:\n- The parser does not handle namespaces. This functionality needs to be implemented separately\n(namespaces can be treated as modules in all practical terms concerning documentation purposes).\n- Only documented and exported symbols are included in the API documentation.\n\n**Hints**:\nWhen documenting a function with named parameters, you can document them as follows:\n\n ```javascript\n/* Foo documentation\n@params _args0 Not relevant: parameters starting with `_` are not displayed\n@params _args0.bar A bar property\n@params _args1 Not relevant: parameters starting with `_` are not displayed\n@params _args1.baz A baz property\n*/\nexport function foo({bar}: { bar: number }, {baz}: { baz: string }) {}\n\n``` \n\nThe general operations of the backend involve:\n- Gathering TypeScript information using  [generateTsInputs](@nav/api/Backends/TsTypedoc.generateTsInputs) .\n- Gathering TypeDoc information using  [generateTypedocInputs](@nav/api/Backends/TsTypedoc.generateTypedocInputs) .\n- Creating the output files using  [generateApiFiles](@nav/api/Backends/TsTypedoc.generateApiFiles) .\n\nFor consumers that want to generate API data, a binary is available in the node module of  `@youwol/mkdocs-ts` ,\nit is a simple script that call the  [generateApiFiles](@nav/api/Backends/TsTypedoc.generateApiFiles)  function.",
                "contentType": "markdown",
                "semantic": {
                    "role": "",
                    "labels": [],
                    "attributes": {},
                    "relations": {}
                }
            }
        ]
    },
    "path": "",
    "attributes": [
        {
            "name": "DOC_KINDS",
            "semantic": {
                "role": "global",
                "labels": [],
                "attributes": {},
                "relations": {}
            },
            "documentation": {
                "sections": [
                    {
                        "content": "Comment can have contribution from various kind.\nThose are the one handled by the backend.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "DOC_KINDS",
            "code": {
                "filePath": "src/backends/ts-typedoc/typedoc-models.ts",
                "declaration": "DOC_KINDS = {\n    /**\n     * Simple text.\n     */\n    TEXT: 'text',\n    /**\n     * An anchor.\n     */\n    INLINE_TAG: 'inline-tag',\n    /**\n     * A code snippet.\n     */\n    CODE: 'code',\n}",
                "implementation": "",
                "startLine": 35,
                "endLine": 36,
                "references": {
                    "DOC_KINDS": "@nav/api/Backends/TsTypedoc.DOC_KINDS"
                }
            }
        },
        {
            "name": "TYPEDOC_KINDS",
            "semantic": {
                "role": "global",
                "labels": [],
                "attributes": {},
                "relations": {}
            },
            "documentation": {
                "sections": [
                    {
                        "content": "The kind handles by the backend.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "TYPEDOC_KINDS",
            "code": {
                "filePath": "src/backends/ts-typedoc/typedoc-models.ts",
                "declaration": "TYPEDOC_KINDS = {\n    PROJECT: 1,\n    ENTRY_MODULE: 2,\n    MODULE: 4,\n    VARIABLE: 32,\n    FUNCTION: 64,\n    CLASS: 128,\n    INTERFACE: 256,\n    CONSTRUCTOR: 512,\n    ATTRIBUTE: 1024,\n    SIGNATURE: 4096,\n    METHOD: 2048,\n    ALIAS: 2097152,\n}",
                "implementation": "",
                "startLine": 11,
                "endLine": 12,
                "references": {
                    "TYPEDOC_KINDS": "@nav/api/Backends/TsTypedoc.TYPEDOC_KINDS"
                }
            }
        }
    ],
    "types": [
        {
            "name": "TsSrcElement",
            "documentation": {
                "sections": [
                    {
                        "content": "Gather additional source code information w/ typedoc required for parsing",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "TsSrcElement",
            "attributes": [
                {
                    "name": "comment",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "The code-comment of the symbol as included in the source file (if any).",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "TsSrcElement.comment",
                    "code": {
                        "filePath": "src/backends/ts-typedoc/generate-ts-inputs.ts",
                        "declaration": "comment?: string",
                        "implementation": "",
                        "startLine": 198,
                        "endLine": 199,
                        "references": {
                            "comment": "@nav/api/Backends/TsTypedoc.TsSrcElement.comment"
                        }
                    }
                },
                {
                    "name": "declaration",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "The declaration of the symbol as included in the source file (if any).",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "TsSrcElement.declaration",
                    "code": {
                        "filePath": "src/backends/ts-typedoc/generate-ts-inputs.ts",
                        "declaration": "declaration?: string",
                        "implementation": "",
                        "startLine": 190,
                        "endLine": 191,
                        "references": {
                            "declaration": "@nav/api/Backends/TsTypedoc.TsSrcElement.declaration"
                        }
                    }
                },
                {
                    "name": "implementation",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "The implementation of the symbol as included in the source file (if any).",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "TsSrcElement.implementation",
                    "code": {
                        "filePath": "src/backends/ts-typedoc/generate-ts-inputs.ts",
                        "declaration": "implementation?: string",
                        "implementation": "",
                        "startLine": 194,
                        "endLine": 195,
                        "references": {
                            "implementation": "@nav/api/Backends/TsTypedoc.TsSrcElement.implementation"
                        }
                    }
                }
            ],
            "callables": [],
            "code": {
                "filePath": "src/backends/ts-typedoc/generate-ts-inputs.ts",
                "declaration": "export interface TsSrcElement",
                "implementation": "export interface TsSrcElement {\n    /**\n     * The declaration of the symbol as included in the source file (if any).\n     */\n    declaration?: string\n    /**\n     * The implementation of the symbol as included in the source file (if any).\n     */\n    implementation?: string\n    /**\n     * The code-comment of the symbol as included in the source file (if any).\n     */\n    comment?: string\n}",
                "startLine": 186,
                "endLine": 200,
                "references": {
                    "TsSrcElement": "@nav/api/Backends/TsTypedoc.TsSrcElement"
                }
            },
            "semantic": {
                "role": "interface",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "ClassTrait",
            "documentation": {
                "sections": [
                    {
                        "content": "Trait specific of a class.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "ClassTrait",
            "attributes": [],
            "callables": [],
            "code": {
                "filePath": "src/backends/ts-typedoc/typedoc-models.ts",
                "declaration": "export type ClassTrait = SymbolTrait & {\n    extendedTypes: TypedocNode[] | null\n    implementedTypes: TypedocNode[] | null\n}",
                "implementation": "",
                "startLine": 115,
                "endLine": 116,
                "references": {
                    "ClassTrait": "@nav/api/Backends/TsTypedoc.ClassTrait",
                    "SymbolTrait": "@nav/api/Backends/TsTypedoc.SymbolTrait",
                    "TypedocNode": "@nav/api/Backends/TsTypedoc.TypedocNode"
                }
            },
            "semantic": {
                "role": "type-alias",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "Comment",
            "documentation": {
                "sections": [
                    {
                        "content": "A comment.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "Comment",
            "attributes": [],
            "callables": [],
            "code": {
                "filePath": "src/backends/ts-typedoc/typedoc-models.ts",
                "declaration": "export type Comment = {\n    /**\n     * The summary.\n     */\n    summary: CommentSection\n}",
                "implementation": "",
                "startLine": 84,
                "endLine": 85,
                "references": {
                    "Comment": "@nav/api/Backends/TsTypedoc.Comment",
                    "CommentSection": "@nav/api/Backends/TsTypedoc.CommentSection"
                }
            },
            "semantic": {
                "role": "type-alias",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "CommentSection",
            "documentation": {
                "sections": [
                    {
                        "content": "A typedocNodes in the comment.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "CommentSection",
            "attributes": [],
            "callables": [],
            "code": {
                "filePath": "src/backends/ts-typedoc/typedoc-models.ts",
                "declaration": "export type CommentSection = (DocText | DocInlineTag | DocCode)[]",
                "implementation": "",
                "startLine": 79,
                "endLine": 80,
                "references": {
                    "CommentSection": "@nav/api/Backends/TsTypedoc.CommentSection",
                    "DocText": "@nav/api/Backends/TsTypedoc.DocText",
                    "DocInlineTag": "@nav/api/Backends/TsTypedoc.DocInlineTag",
                    "DocCode": "@nav/api/Backends/TsTypedoc.DocCode"
                }
            },
            "semantic": {
                "role": "type-alias",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "DocCode",
            "documentation": {
                "sections": [
                    {
                        "content": "Code element in documentation.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "DocCode",
            "attributes": [],
            "callables": [],
            "code": {
                "filePath": "src/backends/ts-typedoc/typedoc-models.ts",
                "declaration": "export type DocCode = {\n    kind: 'code'\n    text: string\n}",
                "implementation": "",
                "startLine": 71,
                "endLine": 72,
                "references": {
                    "DocCode": "@nav/api/Backends/TsTypedoc.DocCode"
                }
            },
            "semantic": {
                "role": "type-alias",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "DocInlineTag",
            "documentation": {
                "sections": [
                    {
                        "content": "Anchor element in documentation.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "DocInlineTag",
            "attributes": [],
            "callables": [],
            "code": {
                "filePath": "src/backends/ts-typedoc/typedoc-models.ts",
                "declaration": "export type DocInlineTag = {\n    kind: 'inline-tag'\n    tag: '@link'\n    text: string\n    target: number\n}",
                "implementation": "",
                "startLine": 61,
                "endLine": 62,
                "references": {
                    "DocInlineTag": "@nav/api/Backends/TsTypedoc.DocInlineTag"
                }
            },
            "semantic": {
                "role": "type-alias",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "DocText",
            "documentation": {
                "sections": [
                    {
                        "content": "Simple text element in documentation.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "DocText",
            "attributes": [],
            "callables": [],
            "code": {
                "filePath": "src/backends/ts-typedoc/typedoc-models.ts",
                "declaration": "export type DocText = {\n    kind: 'text'\n    text: string\n}",
                "implementation": "",
                "startLine": 53,
                "endLine": 54,
                "references": {
                    "DocText": "@nav/api/Backends/TsTypedoc.DocText"
                }
            },
            "semantic": {
                "role": "type-alias",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "Kind",
            "documentation": {
                "sections": [
                    {
                        "content": "Type definition of all managed possible kinds.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "Kind",
            "attributes": [],
            "callables": [],
            "code": {
                "filePath": "src/backends/ts-typedoc/typedoc-models.ts",
                "declaration": "export type Kind = (typeof TYPEDOC_KINDS)[keyof typeof TYPEDOC_KINDS]",
                "implementation": "",
                "startLine": 29,
                "endLine": 30,
                "references": {
                    "Kind": "@nav/api/Backends/TsTypedoc.Kind",
                    "TYPEDOC_KINDS": "@nav/api/Backends/TsTypedoc.TYPEDOC_KINDS"
                }
            },
            "semantic": {
                "role": "type-alias",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "ProjectGlobals",
            "documentation": {
                "sections": [
                    {
                        "content": "Global project information.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "ProjectGlobals",
            "attributes": [],
            "callables": [],
            "code": {
                "filePath": "src/backends/ts-typedoc/typedoc-parser.ts",
                "declaration": "export type ProjectGlobals = {\n    /**\n     * Map `node.id` => navigation path\n     */\n    navigations: { [k: number]: string }\n    /**\n     * Map `navigation path` => source information\n     */\n    tsInputs: TsSrcElements\n    /**\n     * Map `node.id` => `TypedocNode`\n     */\n    typedocIdMap: { [k: number]: TypedocNode }\n    /**\n     * Map `node.id` => parent's node `TypedocNode`\n     */\n    typedocParentIdMap: { [k: number]: TypedocNode }\n}",
                "implementation": "",
                "startLine": 41,
                "endLine": 42,
                "references": {
                    "ProjectGlobals": "@nav/api/Backends/TsTypedoc.ProjectGlobals",
                    "TsSrcElements": "@nav/api/Backends/TsTypedoc.TsSrcElements",
                    "TypedocNode": "@nav/api/Backends/TsTypedoc.TypedocNode"
                }
            },
            "semantic": {
                "role": "type-alias",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "SignatureTrait",
            "documentation": {
                "sections": [
                    {
                        "content": "Trait specific of a signature.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "SignatureTrait",
            "attributes": [],
            "callables": [],
            "code": {
                "filePath": "src/backends/ts-typedoc/typedoc-models.ts",
                "declaration": "export type SignatureTrait = SymbolTrait & {\n    extendedTypes: TypedocNode[] | null\n    implementedTypes: TypedocNode[] | null\n    parameters: TypedocNode[] | null\n    type: TypedocNode\n    comment: string\n}",
                "implementation": "",
                "startLine": 123,
                "endLine": 124,
                "references": {
                    "SignatureTrait": "@nav/api/Backends/TsTypedoc.SignatureTrait",
                    "SymbolTrait": "@nav/api/Backends/TsTypedoc.SymbolTrait",
                    "TypedocNode": "@nav/api/Backends/TsTypedoc.TypedocNode"
                }
            },
            "semantic": {
                "role": "type-alias",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "SignaturesTrait",
            "documentation": {
                "sections": [
                    {
                        "content": "Trait specific of a function.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "SignaturesTrait",
            "attributes": [],
            "callables": [],
            "code": {
                "filePath": "src/backends/ts-typedoc/typedoc-models.ts",
                "declaration": "export type SignaturesTrait = SymbolTrait & {\n    signatures: (TypedocNode & SignatureTrait)[]\n}",
                "implementation": "",
                "startLine": 133,
                "endLine": 134,
                "references": {
                    "SignaturesTrait": "@nav/api/Backends/TsTypedoc.SignaturesTrait",
                    "SymbolTrait": "@nav/api/Backends/TsTypedoc.SymbolTrait",
                    "TypedocNode": "@nav/api/Backends/TsTypedoc.TypedocNode",
                    "SignatureTrait": "@nav/api/Backends/TsTypedoc.SignatureTrait"
                }
            },
            "semantic": {
                "role": "type-alias",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "Source",
            "documentation": {
                "sections": [
                    {
                        "content": "Source specification",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "Source",
            "attributes": [],
            "callables": [],
            "code": {
                "filePath": "src/backends/ts-typedoc/typedoc-models.ts",
                "declaration": "export type Source = {\n    /**\n     * Filename including the snippet.\n     */\n    fileName: string\n    /**\n     * Starting line.\n     */\n    line: number\n}",
                "implementation": "",
                "startLine": 94,
                "endLine": 95,
                "references": {
                    "Source": "@nav/api/Backends/TsTypedoc.Source"
                }
            },
            "semantic": {
                "role": "type-alias",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "SymbolTrait",
            "documentation": {
                "sections": [
                    {
                        "content": "Trait specific of a symbol.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "SymbolTrait",
            "attributes": [],
            "callables": [],
            "code": {
                "filePath": "src/backends/ts-typedoc/typedoc-models.ts",
                "declaration": "export type SymbolTrait = {\n    sources: Source[]\n    typeParameters?: TypedocNode[] | null\n}",
                "implementation": "",
                "startLine": 108,
                "endLine": 109,
                "references": {
                    "SymbolTrait": "@nav/api/Backends/TsTypedoc.SymbolTrait",
                    "Source": "@nav/api/Backends/TsTypedoc.Source",
                    "TypedocNode": "@nav/api/Backends/TsTypedoc.TypedocNode"
                }
            },
            "semantic": {
                "role": "type-alias",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "TsSrcElements",
            "documentation": {
                "sections": [
                    {
                        "content": "Gather additional  source code information w/ typedoc required for parsing for all files.\nKeys are in the form \"FILE_PATH:ENTITY_PATH\".",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "TsSrcElements",
            "attributes": [],
            "callables": [],
            "code": {
                "filePath": "src/backends/ts-typedoc/generate-ts-inputs.ts",
                "declaration": "export type TsSrcElements = { [k: string]: TsSrcElement }",
                "implementation": "",
                "startLine": 205,
                "endLine": 206,
                "references": {
                    "TsSrcElements": "@nav/api/Backends/TsTypedoc.TsSrcElements",
                    "TsSrcElement": "@nav/api/Backends/TsTypedoc.TsSrcElement"
                }
            },
            "semantic": {
                "role": "type-alias",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "TypedocNode",
            "documentation": {
                "sections": [
                    {
                        "content": "Base type for typedoc node.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "TypedocNode",
            "attributes": [],
            "callables": [],
            "code": {
                "filePath": "src/backends/ts-typedoc/typedoc-models.ts",
                "declaration": "export type TypedocNode = {\n    id: number\n    name: string\n    kind: Kind\n    flags: Record<string, string>\n    comment: Comment\n    children: TypedocNode[]\n}",
                "implementation": "",
                "startLine": 140,
                "endLine": 141,
                "references": {
                    "TypedocNode": "@nav/api/Backends/TsTypedoc.TypedocNode",
                    "Comment": "@nav/api/Backends/TsTypedoc.Comment",
                    "Kind": "@nav/api/Backends/TsTypedoc.Kind"
                }
            },
            "semantic": {
                "role": "type-alias",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        }
    ],
    "callables": [
        {
            "name": "generateApiFiles",
            "documentation": {
                "sections": [
                    {
                        "content": "Entry point function to generate API files.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    },
                    {
                        "title": "Arguments",
                        "content": "\n*  **baseNav**: The base path of the API node in the navigation (*e.g.*  `/api` ).\n*  **outputFolder**: The output folder.\n*  **projectFolder**: The folder of the project to document.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "arguments",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "generateApiFiles",
            "code": {
                "filePath": "src/backends/ts-typedoc/typedoc-parser.ts",
                "declaration": "export function generateApiFiles({\n    projectFolder,\n    outputFolder,\n    baseNav,\n}: {\n    projectFolder: string\n    outputFolder: string\n    baseNav: string\n})",
                "implementation": "export function generateApiFiles({\n    projectFolder,\n    outputFolder,\n    baseNav,\n}: {\n    projectFolder: string\n    outputFolder: string\n    baseNav: string\n}) {\n    const projectPackageJson = fs.readFileSync(\n        path.resolve(projectFolder, 'package.json'),\n        'utf8',\n    )\n    // module name should not include '/', before finding a better solution\n    const project = JSON.parse(projectPackageJson).name.split('/').slice(-1)[0]\n    function generateApiFilesRec(\n        modulePath: string,\n        typedocNode: TypedocNode & ProjectTrait,\n        tsInputs: TsSrcElements,\n        writeFolder: string,\n    ) {\n        const doc = parseModule({\n            baseNav,\n            typedocNode,\n            modulePath,\n            tsInputs: tsInputs,\n        })\n\n        const filePath = `${writeFolder}/${modulePath}.json`\n        const directory = Path.dirname(filePath)\n        // Create missing directories if they don't exist\n        mkdirSync(directory, { recursive: true })\n        writeFileSync(filePath, JSON.stringify(doc, null, 4) + '\\n', 'utf8')\n\n        for (const m of doc.children) {\n            generateApiFilesRec(\n                m.path.replace('.', '/'),\n                typedocNode,\n                tsInputs,\n                writeFolder,\n            )\n        }\n    }\n    deleteDirectoryIfExists(outputFolder)\n\n    const typedocData = generateTypedocInputs(projectFolder)\n    const files = gatherTsFiles({ typedocNode: typedocData })\n    const tsData = generateTsInputs(projectFolder, files, {})\n    generateApiFilesRec(project, typedocData, tsData, outputFolder)\n}",
                "startLine": 139,
                "endLine": 189,
                "references": {
                    "generateApiFiles": "@nav/api/Backends/TsTypedoc.generateApiFiles"
                }
            },
            "semantic": {
                "role": "function",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "generateTsInputs",
            "documentation": {
                "sections": [
                    {
                        "content": "Generate the global dictionary of typescript inputs required for parsing.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    },
                    {
                        "title": "Arguments",
                        "content": "\n*  **rootPath**: root path of the project to parse.\n*  **files**: set of files to process by typescript compiler.\n*  **elements**: aggregated entities so far.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "arguments",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "generateTsInputs",
            "code": {
                "filePath": "src/backends/ts-typedoc/generate-ts-inputs.ts",
                "declaration": "export function generateTsInputs(\n    rootPath: string,\n    files: Set<string>,\n    elements: TsSrcElements = {},\n): TsSrcElements",
                "implementation": "export function generateTsInputs(\n    rootPath: string,\n    files: Set<string>,\n    elements: TsSrcElements = {},\n): TsSrcElements {\n    rootPath = rootPath.endsWith('/') ? rootPath : `${rootPath}/`\n    files.forEach((file) => {\n        const filePath = path.join(rootPath, file)\n        processFile(rootPath, filePath, elements)\n    })\n    return elements\n}",
                "startLine": 214,
                "endLine": 226,
                "references": {
                    "generateTsInputs": "@nav/api/Backends/TsTypedoc.generateTsInputs",
                    "TsSrcElements": "@nav/api/Backends/TsTypedoc.TsSrcElements"
                }
            },
            "semantic": {
                "role": "function",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "generateTypedocInputs",
            "documentation": {
                "sections": [
                    {
                        "content": "Extract typedoc required inputs by running it from the given folder.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    },
                    {
                        "title": "Arguments",
                        "content": "\n*  **projectFolder**: The folder in which  `typedoc`  is run.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "arguments",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    },
                    {
                        "title": "Returns",
                        "content": "The  `typedoc`  node datastructure representing the project.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "returns",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "generateTypedocInputs",
            "code": {
                "filePath": "src/backends/ts-typedoc/generate-typedoc-inputs.ts",
                "declaration": "export function generateTypedocInputs(\n    projectFolder: string,\n): TypedocNode & ProjectTrait",
                "implementation": "export function generateTypedocInputs(\n    projectFolder: string,\n): TypedocNode & ProjectTrait {\n    const uid = randomUUID()\n    const folder = path.resolve(projectFolder)\n    console.log('Run typedoc from folder', folder)\n    const output = path.resolve(folder, `typedoc-out-${uid}.json`)\n    const typedoc = path.resolve(\n        folder,\n        'node_modules',\n        'typedoc',\n        'bin',\n        'typedoc',\n    )\n    const result = spawnSync(typedoc, ['--json', output], { cwd: folder })\n\n    if (result.stdout) {\n        console.log(`stdout: ${result.stdout}`)\n    }\n\n    // Log process exit code\n    console.log(`typedoc process exited with code ${result.status}`)\n    if (result.status > 0) {\n        console.error(\n            `Error executing typedoc: ${result.error} ${result.stderr}`,\n        )\n        throw Error(\n            `Typedoc exited with non zero status code (${result.status})`,\n        )\n    }\n    const fileContent = fs.readFileSync(output, 'utf8')\n    fs.unlinkSync(output)\n    return JSON.parse(fileContent)\n}",
                "startLine": 12,
                "endLine": 46,
                "references": {
                    "generateTypedocInputs": "@nav/api/Backends/TsTypedoc.generateTypedocInputs",
                    "TypedocNode": "@nav/api/Backends/TsTypedoc.TypedocNode",
                    "ProjectTrait": "@nav/api/Backends/TsTypedoc.ProjectTrait"
                }
            },
            "semantic": {
                "role": "function",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "parseAttribute",
            "documentation": {
                "sections": [
                    {
                        "content": "Parse an attribute.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    },
                    {
                        "title": "Arguments",
                        "content": "\n*  **parentElement**: Parent node of the documentation.\n*  **projectGlobals**: Project's global.\n*  **typedocNode**: Input node.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "arguments",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    },
                    {
                        "title": "Returns",
                        "content": "Callable element.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "returns",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "parseAttribute",
            "code": {
                "filePath": "src/backends/ts-typedoc/typedoc-parser.ts",
                "declaration": "export function parseAttribute({\n    typedocNode,\n    projectGlobals,\n    parentElement,\n}: {\n    typedocNode: TypedocNode & SymbolTrait\n    projectGlobals: ProjectGlobals\n    parentPath: string\n    parentElement?: TypedocNode\n}): Attribute",
                "implementation": "export function parseAttribute({\n    typedocNode,\n    projectGlobals,\n    parentElement,\n}: {\n    typedocNode: TypedocNode & SymbolTrait\n    projectGlobals: ProjectGlobals\n    parentPath: string\n    parentElement?: TypedocNode\n}): Attribute {\n    if (\n        typedocNode['inheritedFrom'] &&\n        !projectGlobals.typedocIdMap[typedocNode['inheritedFrom'].target]\n    ) {\n        return undefined\n    }\n    const name = typedocNode.name\n    if (typedocNode['inheritedFrom']) {\n        typedocNode = projectGlobals.typedocIdMap[\n            typedocNode['inheritedFrom'].target\n        ] as TypedocNode & SymbolTrait\n        parentElement = projectGlobals.typedocParentIdMap[typedocNode.id]\n    }\n    const references = gather_symbol_references(typedocNode, projectGlobals)\n    const documentation = parseDocumentationElements({\n        typedocNodes: typedocNode.comment.summary,\n        parent: parentElement,\n        projectGlobals,\n    })\n    const semantic = semantics[typedocNode.kind]\n    return {\n        name: name,\n        semantic: semantic,\n        documentation: getSummaryDoc(documentation),\n        path: parentElement ? `${parentElement.name}.${name}` : name,\n        code: parseCode({\n            typedocNode: typedocNode,\n            projectGlobals,\n            references,\n            parentElement,\n        }),\n    }\n}",
                "startLine": 824,
                "endLine": 867,
                "references": {
                    "parseAttribute": "@nav/api/Backends/TsTypedoc.parseAttribute",
                    "TypedocNode": "@nav/api/Backends/TsTypedoc.TypedocNode",
                    "ProjectGlobals": "@nav/api/Backends/TsTypedoc.ProjectGlobals",
                    "SymbolTrait": "@nav/api/Backends/TsTypedoc.SymbolTrait",
                    "Attribute": "@nav/api/CodeApi.Attribute"
                }
            },
            "semantic": {
                "role": "function",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "parseCallable",
            "documentation": {
                "sections": [
                    {
                        "content": "Parse a callable to extract code information.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    },
                    {
                        "title": "Arguments",
                        "content": "\n*  **parentElement**: Parent node of the documentation.\n*  **projectGlobals**: Project's global.\n*  **semantic**: Semantic definition of the callable.\n*  **typedocNode**: Input node.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "arguments",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    },
                    {
                        "title": "Returns",
                        "content": "Callable element.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "returns",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "parseCallable",
            "code": {
                "filePath": "src/backends/ts-typedoc/typedoc-parser.ts",
                "declaration": "export function parseCallable({\n    typedocNode,\n    semantic,\n    projectGlobals,\n    parentElement,\n}: {\n    typedocNode: TypedocNode & SignaturesTrait\n    parentPath: string\n    semantic: Semantic\n    projectGlobals?: ProjectGlobals\n    parentElement?: TypedocNode\n}): Callable",
                "implementation": "export function parseCallable({\n    typedocNode,\n    semantic,\n    projectGlobals,\n    parentElement,\n}: {\n    typedocNode: TypedocNode & SignaturesTrait\n    parentPath: string\n    semantic: Semantic\n    projectGlobals?: ProjectGlobals\n    parentElement?: TypedocNode\n}): Callable {\n    if (\n        typedocNode['inheritedFrom'] &&\n        !projectGlobals.typedocIdMap[typedocNode['inheritedFrom'].target]\n    ) {\n        return undefined\n    }\n    const typedocFct = typedocNode.signatures[0]\n    const name = typedocFct.name\n    const documentation = parseDocumentationElements({\n        typedocNodes: typedocFct.comment.summary,\n        parent: typedocFct,\n        projectGlobals,\n    })\n    const params_ref = gather_symbol_references(\n        typedocFct['parameters'] as unknown as TypedocNode,\n        projectGlobals,\n    )\n    const returns_ref = gather_symbol_references(\n        typedocFct.type,\n        projectGlobals,\n    )\n    if (name == 'getScore') {\n        console.log('getScore')\n    }\n    const functionDoc = getSummaryDoc(documentation)\n    const parametersDoc = parseArgumentsDoc({\n        fromElement: typedocFct,\n        title: 'Arguments',\n        parentElement: typedocFct,\n        projectGlobals,\n    })\n    const returnsDoc = parseReturnsDoc({\n        typedocNode: typedocFct,\n        projectGlobals,\n    })\n\n    functionDoc.sections.push(\n        ...[parametersDoc, returnsDoc].filter((c) => c !== undefined),\n    )\n    return {\n        name: name,\n        documentation: functionDoc,\n        path: parentElement ? `${parentElement.name}.${name}` : name, //`${typedocFct.sources[0].fileName}:${path}`,\n        code: parseCode({\n            typedocNode,\n            projectGlobals,\n            references: {\n                ...params_ref,\n                ...returns_ref,\n            },\n            parentElement,\n        }),\n        semantic,\n    }\n}",
                "startLine": 591,
                "endLine": 658,
                "references": {
                    "parseCallable": "@nav/api/Backends/TsTypedoc.parseCallable",
                    "TypedocNode": "@nav/api/Backends/TsTypedoc.TypedocNode",
                    "ProjectGlobals": "@nav/api/Backends/TsTypedoc.ProjectGlobals",
                    "Semantic": "@nav/api/CodeApi.Semantic",
                    "SymbolTrait": "@nav/api/Backends/TsTypedoc.SymbolTrait",
                    "Callable": "@nav/api/CodeApi.Callable"
                }
            },
            "semantic": {
                "role": "function",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "parseChildModule",
            "documentation": {
                "sections": [
                    {
                        "content": "Parse a child module.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    },
                    {
                        "title": "Arguments",
                        "content": "\n*  **parentPath**: Parent path.\n*  **typedocNode**: Input node.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "arguments",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    },
                    {
                        "title": "Returns",
                        "content": "Ouput structure.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "returns",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "parseChildModule",
            "code": {
                "filePath": "src/backends/ts-typedoc/typedoc-parser.ts",
                "declaration": "export function parseChildModule({\n    typedocNode,\n    parentPath,\n}: {\n    typedocNode: TypedocNode\n    parentPath: string\n}): ChildModule",
                "implementation": "export function parseChildModule({\n    typedocNode,\n    parentPath,\n}: {\n    typedocNode: TypedocNode\n    parentPath: string\n}): ChildModule {\n    return {\n        name: typedocNode.name,\n        path: `${parentPath}.${typedocNode.name}`,\n        isLeaf: !typedocNode.children.some((c) =>\n            [TYPEDOC_KINDS.MODULE, TYPEDOC_KINDS.ENTRY_MODULE].includes(c.kind),\n        ),\n    }\n}",
                "startLine": 408,
                "endLine": 423,
                "references": {
                    "parseChildModule": "@nav/api/Backends/TsTypedoc.parseChildModule",
                    "TypedocNode": "@nav/api/Backends/TsTypedoc.TypedocNode",
                    "ChildModule": "@nav/api/CodeApi.ChildModule"
                }
            },
            "semantic": {
                "role": "function",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "parseCode",
            "documentation": {
                "sections": [
                    {
                        "content": "Parse a symbol to extract code information.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    },
                    {
                        "title": "Arguments",
                        "content": "\n*  **parentElement**: Parent node of the documentation.\n*  **projectGlobals**: Project's global.\n*  **references**: Symbol's type references in declaration.\n*  **typedocNode**: Input node.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "arguments",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    },
                    {
                        "title": "Returns",
                        "content": "Code element.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "returns",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "parseCode",
            "code": {
                "filePath": "src/backends/ts-typedoc/typedoc-parser.ts",
                "declaration": "export function parseCode({\n    typedocNode,\n    projectGlobals,\n    references,\n    parentElement,\n}: {\n    typedocNode: TypedocNode & SymbolTrait\n    projectGlobals: ProjectGlobals\n    references: { [_name: string]: string }\n    parentElement?: TypedocNode\n}): Code",
                "implementation": "export function parseCode({\n    typedocNode,\n    projectGlobals,\n    references,\n    parentElement,\n}: {\n    typedocNode: TypedocNode & SymbolTrait\n    projectGlobals: ProjectGlobals\n    references: { [_name: string]: string }\n    parentElement?: TypedocNode\n}): Code {\n    const symbols = projectGlobals.tsInputs\n    const signatureNode =\n        typedocNode['signatures'] && typedocNode['signatures'][0]\n    const name = signatureNode?.name || typedocNode.name\n\n    const source = typedocNode.sources[0]\n    const file_path = source.fileName\n    const key = parentElement\n        ? `${file_path}:${parentElement.name}.${name}`\n        : `${file_path}:${name}`\n    if (!(key in symbols)) {\n        console.warn(`Can not find reference of ${key}`)\n        return {\n            filePath: '',\n            declaration: '',\n            implementation: '',\n            startLine: 1,\n            endLine: 2,\n            references: {},\n        }\n    }\n    const symbol = symbols[key]\n    const implementation = symbol.implementation || ''\n    const nav = projectGlobals.navigations[typedocNode.id]\n    return {\n        filePath: source.fileName,\n        declaration: symbol.declaration,\n        implementation,\n        startLine: source.line,\n        endLine: source.line + implementation.split('\\n').length,\n        references: { [name]: `${nav}`, ...references },\n    }\n}",
                "startLine": 536,
                "endLine": 580,
                "references": {
                    "parseCode": "@nav/api/Backends/TsTypedoc.parseCode",
                    "TypedocNode": "@nav/api/Backends/TsTypedoc.TypedocNode",
                    "ProjectGlobals": "@nav/api/Backends/TsTypedoc.ProjectGlobals",
                    "SymbolTrait": "@nav/api/Backends/TsTypedoc.SymbolTrait",
                    "Code": "@nav/api/CodeApi.Code"
                }
            },
            "semantic": {
                "role": "function",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "parseDocumentation",
            "documentation": {
                "sections": [
                    {
                        "content": "Parse documentation section.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    },
                    {
                        "title": "Arguments",
                        "content": "\n*  **parent**: Parent node.\n*  **projectGlobals**: Project's global.\n*  **title**: title of the document section.\n*  **typedocNode**: Input node.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "arguments",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    },
                    {
                        "title": "Returns",
                        "content": "Documentation structure.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "returns",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "parseDocumentation",
            "code": {
                "filePath": "src/backends/ts-typedoc/typedoc-parser.ts",
                "declaration": "export function parseDocumentation({\n    semantic,\n    title,\n    typedocNode,\n    parent,\n    projectGlobals,\n}: {\n    semantic: Semantic\n    title?: string\n    typedocNode: CommentSection\n    parent: TypedocNode\n    projectGlobals: ProjectGlobals\n}): Documentation",
                "implementation": "export function parseDocumentation({\n    semantic,\n    title,\n    typedocNode,\n    parent,\n    projectGlobals,\n}: {\n    semantic: Semantic\n    title?: string\n    typedocNode: CommentSection\n    parent: TypedocNode\n    projectGlobals: ProjectGlobals\n}): Documentation {\n    return {\n        sections: [\n            {\n                title,\n                content: parseDocumentationElements({\n                    typedocNodes: typedocNode,\n                    parent,\n                    projectGlobals,\n                }),\n                contentType: 'markdown',\n                semantic,\n            },\n        ],\n    }\n}",
                "startLine": 466,
                "endLine": 494,
                "references": {
                    "parseDocumentation": "@nav/api/Backends/TsTypedoc.parseDocumentation",
                    "TypedocNode": "@nav/api/Backends/TsTypedoc.TypedocNode",
                    "ProjectGlobals": "@nav/api/Backends/TsTypedoc.ProjectGlobals",
                    "Semantic": "@nav/api/CodeApi.Semantic",
                    "CommentSection": "@nav/api/Backends/TsTypedoc.CommentSection",
                    "Documentation": "@nav/api/CodeApi.Documentation"
                }
            },
            "semantic": {
                "role": "function",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "parseFile",
            "documentation": {
                "sections": [
                    {
                        "content": "Parse a file.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    },
                    {
                        "title": "Arguments",
                        "content": "\n*  **path**: Path of the file.\n*  **projectGlobals**: Global project information.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "arguments",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    },
                    {
                        "title": "Returns",
                        "content": "Ouput structure.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "returns",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "parseFile",
            "code": {
                "filePath": "src/backends/ts-typedoc/typedoc-parser.ts",
                "declaration": "export function parseFile({\n    path,\n    projectGlobals,\n}: {\n    path: string\n    projectGlobals: ProjectGlobals\n}): File",
                "implementation": "export function parseFile({\n    path,\n    projectGlobals,\n}: {\n    path: string\n    projectGlobals: ProjectGlobals\n}): File {\n    const symbols = projectGlobals.tsInputs\n    const comment = symbols[path].comment\n    return {\n        name: Path.basename(path),\n        path: path,\n        documentation: {\n            sections: [\n                {\n                    semantic: noSemantic,\n                    content: comment,\n                    contentType: 'markdown',\n                },\n            ],\n        },\n    }\n}",
                "startLine": 432,
                "endLine": 455,
                "references": {
                    "parseFile": "@nav/api/Backends/TsTypedoc.parseFile",
                    "ProjectGlobals": "@nav/api/Backends/TsTypedoc.ProjectGlobals",
                    "File": "@nav/api/CodeApi.File"
                }
            },
            "semantic": {
                "role": "function",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "parseModule",
            "documentation": {
                "sections": [
                    {
                        "content": "Parse a module from typedoc & TS inputs.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    },
                    {
                        "title": "Arguments",
                        "content": "\n*  **modulePath**: The module path.\n*  **tsInputs**: The (global) typescript inputs.\n*  **typedocNode**: Typedoc's module node.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "arguments",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "parseModule",
            "code": {
                "filePath": "src/backends/ts-typedoc/typedoc-parser.ts",
                "declaration": "export function parseModule({\n    typedocNode,\n    modulePath,\n    tsInputs,\n    baseNav,\n}: {\n    typedocNode: TypedocNode\n    modulePath: string\n    tsInputs: TsSrcElements\n    baseNav: string\n}): Module",
                "implementation": "export function parseModule({\n    typedocNode,\n    modulePath,\n    tsInputs,\n    baseNav,\n}: {\n    typedocNode: TypedocNode\n    modulePath: string\n    tsInputs: TsSrcElements\n    baseNav: string\n}): Module {\n    const symbolIdMap: { [key: number]: TypedocNode } = {}\n    const parentSymbolIdMap: { [key: number]: TypedocNode } = {}\n    const navMap = generateNavigationPathsInModule(baseNav, '', typedocNode)\n    function constructSymbolsMap(elem: TypedocNode, parentId: number | null) {\n        symbolIdMap[elem.id] = elem\n        if (parentId) {\n            parentSymbolIdMap[elem.id] = symbolIdMap[parentId]\n        }\n        if (!elem.children) {\n            return\n        }\n        for (const child of elem.children) {\n            constructSymbolsMap(child, elem.id)\n        }\n    }\n\n    constructSymbolsMap(typedocNode, null)\n    const projectGlobals: ProjectGlobals = {\n        navigations: navMap,\n        tsInputs,\n        typedocIdMap: symbolIdMap,\n        typedocParentIdMap: parentSymbolIdMap,\n    }\n\n    function getModuleRec(fromElem: TypedocNode, parts: string[]): TypedocNode {\n        if (parts.length === 0) {\n            return fromElem\n        }\n        if (\n            parts.length === 1 &&\n            fromElem.name === parts[0] &&\n            [TYPEDOC_KINDS.PROJECT, TYPEDOC_KINDS.MODULE].includes(\n                fromElem.kind,\n            )\n        ) {\n            return fromElem\n        }\n        const child = fromElem.children.find(\n            (c) =>\n                [TYPEDOC_KINDS.MODULE, TYPEDOC_KINDS.ENTRY_MODULE].includes(\n                    c.kind,\n                ) && c.name === parts[0],\n        )\n        if (child) {\n            return getModuleRec(child, parts.slice(1))\n        }\n        throw new Error(`Module not found: ${parts.join('.')}`)\n    }\n\n    const module = getModuleRec(typedocNode, modulePath.split('/').slice(1))\n\n    if (\n        ![\n            TYPEDOC_KINDS.MODULE,\n            TYPEDOC_KINDS.PROJECT,\n            TYPEDOC_KINDS.ENTRY_MODULE,\n        ].includes(module.kind)\n    ) {\n        throw new Error(`Kind of module not knows (got ${module.kind})`)\n    }\n\n    const path = modulePath\n\n    const subModules = module.children.filter((child) =>\n        [TYPEDOC_KINDS.MODULE, TYPEDOC_KINDS.ENTRY_MODULE].includes(child.kind),\n    )\n    const types = module.children\n        .filter((child) =>\n            [\n                TYPEDOC_KINDS.CLASS,\n                TYPEDOC_KINDS.INTERFACE,\n                TYPEDOC_KINDS.ALIAS,\n            ].includes(child.kind),\n        )\n        .filter((cls) => cls.comment)\n        .map((cls) => cls as unknown as TypedocNode & SymbolTrait & ClassTrait)\n        .map((cls) =>\n            parseType({\n                typedocNode: cls,\n                parentPath: path,\n                projectGlobals,\n            }),\n        )\n    const functions = module.children\n        .filter((child) => child.kind === TYPEDOC_KINDS.FUNCTION)\n        .map((func) => func as unknown as TypedocNode & SignaturesTrait)\n        .filter((func) => func.signatures[0].comment)\n        .map((func) =>\n            parseCallable({\n                typedocNode: func,\n                parentPath: path,\n                projectGlobals,\n                semantic: { ...noSemantic, role: 'function' },\n            }),\n        )\n    const globals = module.children\n        .filter((child) => child.kind === TYPEDOC_KINDS.VARIABLE)\n        .filter((attr) => attr.comment)\n        .map((attr) => attr as unknown as TypedocNode & SymbolTrait)\n        .map((attr) =>\n            parseAttribute({\n                typedocNode: attr,\n                projectGlobals,\n                parentPath: modulePath,\n            }),\n        )\n\n    const documentation = module.comment\n        ? parseDocumentation({\n              semantic: noSemantic,\n              typedocNode: module.comment.summary,\n              parent: module,\n              projectGlobals,\n          })\n        : noDoc\n\n    const files = [\n        ...new Set(\n            module.children.map((child) => child['sources'][0].fileName),\n        ),\n    ].map((file) => parseFile({ path: file, projectGlobals }))\n\n    return {\n        name: module.name,\n        documentation,\n        path: '',\n        attributes: globals,\n        types: types,\n        callables: functions,\n        files,\n        children: subModules.map((child) =>\n            parseChildModule({ typedocNode: child, parentPath: path }),\n        ),\n        semantic: noSemantic,\n    }\n}",
                "startLine": 252,
                "endLine": 399,
                "references": {
                    "parseModule": "@nav/api/Backends/TsTypedoc.parseModule",
                    "TsSrcElements": "@nav/api/Backends/TsTypedoc.TsSrcElements",
                    "TypedocNode": "@nav/api/Backends/TsTypedoc.TypedocNode",
                    "Module": "@nav/api/CodeApi.Module"
                }
            },
            "semantic": {
                "role": "function",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "parseType",
            "documentation": {
                "sections": [
                    {
                        "content": "Parse a type to extract code information.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    },
                    {
                        "title": "Arguments",
                        "content": "\n*  **parentPath**: Parent navigation path.\n*  **projectGlobals**: Project's global.\n*  **typedocNode**: Input node.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "arguments",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    },
                    {
                        "title": "Returns",
                        "content": "Type element.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "returns",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "parseType",
            "code": {
                "filePath": "src/backends/ts-typedoc/typedoc-parser.ts",
                "declaration": "export function parseType({\n    typedocNode,\n    parentPath,\n    projectGlobals,\n}: {\n    typedocNode: TypedocNode & ClassTrait\n    parentPath: string\n    projectGlobals: ProjectGlobals\n}): Type",
                "implementation": "export function parseType({\n    typedocNode,\n    parentPath,\n    projectGlobals,\n}: {\n    typedocNode: TypedocNode & ClassTrait\n    parentPath: string\n    projectGlobals: ProjectGlobals\n}): Type {\n    const name = typedocNode.name\n    const semantic = semantics[typedocNode.kind]\n    const path = `${parentPath}.${name}`\n    const documentation = parseDocumentationElements({\n        typedocNodes: typedocNode.comment.summary,\n        parent: typedocNode,\n        projectGlobals,\n    })\n    const attributes =\n        typedocNode.children?.filter(\n            (child) => child.kind === TYPEDOC_KINDS.ATTRIBUTE,\n        ) || []\n    const methods =\n        typedocNode.children?.filter((child) =>\n            [TYPEDOC_KINDS.CONSTRUCTOR, TYPEDOC_KINDS.METHOD].includes(\n                child.kind,\n            ),\n        ) || []\n\n    const references = gather_symbol_references(typedocNode, projectGlobals)\n    const doc = getSummaryDoc(documentation)\n    const tParamDoc = parseArgumentsDoc({\n        fromElement: typedocNode.typeParameters,\n        title: 'Generics',\n        parentElement: typedocNode,\n        projectGlobals,\n    })\n    tParamDoc && doc.sections.push(tParamDoc)\n    return {\n        name: typedocNode.name,\n        documentation: doc,\n        path: typedocNode.name,\n        attributes: attributes\n            .filter((attr) => attr.comment)\n            .map((attr) => attr as unknown as TypedocNode & SymbolTrait)\n            .map((attr) =>\n                parseAttribute({\n                    typedocNode: attr,\n                    projectGlobals,\n                    parentPath: path,\n                    parentElement: typedocNode,\n                }),\n            )\n            .filter((attr) => attr),\n        callables: methods\n            .map((meth) => meth as unknown as TypedocNode & SignaturesTrait)\n            .filter((meth) => meth.signatures[0].comment)\n            .map((meth) =>\n                parseCallable({\n                    typedocNode: meth,\n                    parentPath: path,\n                    projectGlobals,\n                    semantic: semantics[meth.kind],\n                    parentElement: typedocNode,\n                }),\n            )\n            .filter((meth) => meth),\n        code: parseCode({\n            typedocNode: typedocNode,\n            projectGlobals,\n            references,\n        }),\n        semantic,\n    }\n}",
                "startLine": 740,
                "endLine": 814,
                "references": {
                    "parseType": "@nav/api/Backends/TsTypedoc.parseType",
                    "ProjectGlobals": "@nav/api/Backends/TsTypedoc.ProjectGlobals",
                    "TypedocNode": "@nav/api/Backends/TsTypedoc.TypedocNode",
                    "SymbolTrait": "@nav/api/Backends/TsTypedoc.SymbolTrait",
                    "Type": "@nav/api/CodeApi.Type"
                }
            },
            "semantic": {
                "role": "function",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "processFile",
            "documentation": {
                "sections": [
                    {
                        "content": "Process a typescript file to extract associated  [TsSrcElements](@nav/api/Backends/TsTypedoc.TsSrcElements) .",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    },
                    {
                        "title": "Arguments",
                        "content": "\n*  **rootPath**: Project's root path.\n*  **filePath**: File to process\n*  **elements**: Dictionary in which new elements are added.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "arguments",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "processFile",
            "code": {
                "filePath": "src/backends/ts-typedoc/generate-ts-inputs.ts",
                "declaration": "export function processFile(\n    rootPath: string,\n    filePath: string,\n    elements: TsSrcElements,\n)",
                "implementation": "export function processFile(\n    rootPath: string,\n    filePath: string,\n    elements: TsSrcElements,\n) {\n    const sourceFile = ts.createSourceFile(\n        filePath,\n        fs.readFileSync(filePath, 'utf8'),\n        ts.ScriptTarget.Latest,\n    )\n    const file = filePath\n    function visit(node: ts.Node) {\n        if (node.kind === ts.SyntaxKind.SourceFile) {\n            elements[getPrefix(rootPath, file)] = {\n                comment: getFileDoc(node),\n            }\n        }\n        if (ts.isVariableDeclaration(node) && node.name) {\n            elements[getPrefix(rootPath, file, node)] = {\n                declaration: node.getText(sourceFile),\n            }\n        }\n\n        if (ts.isTypeAliasDeclaration(node) && node.name) {\n            elements[getPrefix(rootPath, file, node)] = {\n                declaration: node.getText(sourceFile),\n            }\n        }\n        if (ts.isFunctionDeclaration(node) && node.name) {\n            elements[getPrefix(rootPath, file, node)] = {\n                declaration: getDeclaration(node, sourceFile),\n                implementation: node.getText(sourceFile),\n            }\n        }\n        if (ts.isClassDeclaration(node) || ts.isInterfaceDeclaration(node)) {\n            if (ts.isClassDeclaration(node)) {\n                const constructor = node.members.find((member) =>\n                    ts.isConstructorDeclaration(member),\n                )\n                if (constructor) {\n                    const className = node.name.escapedText\n                    const prefix = `${file.replace(rootPath, '')}:${className}.new ${className}`\n                    elements[prefix] = {\n                        declaration: getDeclaration(constructor, sourceFile),\n                        implementation: constructor.getText(sourceFile),\n                    }\n                }\n            }\n            elements[getPrefix(rootPath, file, node)] = {\n                declaration: getDeclaration(node, sourceFile),\n                implementation: node.getText(sourceFile),\n            }\n            node.members.forEach((member) => {\n                if (ts.isMethodDeclaration(member)) {\n                    elements[\n                        `${getPrefix(rootPath, file, node)}.${member.name['escapedText']}`\n                    ] = {\n                        declaration: getDeclaration(member, sourceFile),\n                        implementation: member.getText(sourceFile),\n                    }\n                }\n                if (ts.isPropertyDeclaration(member)) {\n                    elements[\n                        `${getPrefix(rootPath, file, node)}.${member.name['escapedText']}`\n                    ] = { declaration: member.getText(sourceFile) }\n                }\n                if (\n                    ts.isPropertySignature(member) ||\n                    ts.isMethodSignature(member)\n                ) {\n                    elements[\n                        `${getPrefix(rootPath, file, node)}.${member.name['escapedText']}`\n                    ] = { declaration: member.getText(sourceFile) }\n                }\n            })\n        }\n        ts.forEachChild(node, visit)\n    }\n\n    visit(sourceFile)\n}",
                "startLine": 101,
                "endLine": 182,
                "references": {
                    "processFile": "@nav/api/Backends/TsTypedoc.processFile",
                    "TsSrcElements": "@nav/api/Backends/TsTypedoc.TsSrcElements"
                }
            },
            "semantic": {
                "role": "function",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        }
    ],
    "files": [
        {
            "name": "generate-ts-inputs.ts",
            "path": "src/backends/ts-typedoc/generate-ts-inputs.ts",
            "documentation": {
                "sections": [
                    {
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        },
                        "content": "This file gathers implementations that parse project's source code using typescript's AST parser to\nextract additional information required by the backend.",
                        "contentType": "markdown"
                    }
                ]
            }
        },
        {
            "name": "typedoc-models.ts",
            "path": "src/backends/ts-typedoc/typedoc-models.ts",
            "documentation": {
                "sections": [
                    {
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        },
                        "content": "This file gathers the models of typedoc's generated outputs.\n\nOnly the subset used in the backend is described.The kind handles by the backend.",
                        "contentType": "markdown"
                    }
                ]
            }
        },
        {
            "name": "typedoc-parser.ts",
            "path": "src/backends/ts-typedoc/typedoc-parser.ts",
            "documentation": {
                "sections": [
                    {
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        },
                        "content": "This file gathers parsing function to convert typedoc + typescript data into mkdocs [CodeApi](@nav:/api/CodeApi)\nmodels.",
                        "contentType": "markdown"
                    }
                ]
            }
        },
        {
            "name": "generate-typedoc-inputs.ts",
            "path": "src/backends/ts-typedoc/generate-typedoc-inputs.ts",
            "documentation": {
                "sections": [
                    {
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        },
                        "content": "",
                        "contentType": "markdown"
                    }
                ]
            }
        }
    ],
    "children": [],
    "semantic": {
        "role": "",
        "labels": [],
        "attributes": {},
        "relations": {}
    }
}
