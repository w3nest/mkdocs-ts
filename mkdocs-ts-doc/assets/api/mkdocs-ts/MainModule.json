{
    "name": "MainModule",
    "documentation": {
        "sections": [
            {
                "content": "Main module of the library.",
                "contentType": "markdown",
                "semantic": {
                    "role": "",
                    "labels": [],
                    "attributes": {},
                    "relations": {}
                }
            }
        ]
    },
    "path": "",
    "attributes": [
        {
            "name": "CatchAllKey",
            "semantic": {
                "role": "global",
                "labels": [],
                "attributes": {},
                "relations": {}
            },
            "documentation": {
                "sections": [
                    {
                        "content": "Key representing an implicit 'catch-all' navigation referenced in  [Navigation](@nav/api/MainModule.Navigation) .",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "CatchAllKey",
            "code": {
                "filePath": "src/lib/navigation.node.ts",
                "declaration": "CatchAllKey = '...'",
                "implementation": "",
                "startLine": 311,
                "endLine": 312,
                "references": {
                    "CatchAllKey": "@nav/api/MainModule.CatchAllKey"
                }
            }
        }
    ],
    "types": [
        {
            "name": "GlobalMarkdownViews",
            "documentation": {
                "sections": [
                    {
                        "content": "Represents global Markdown views that can be referenced when using  [parseMd](@nav/api/MainModule.parseMd) .\n\nBy default, it is populated with  `code-snippet` , more information in  [CodeSnippetView](@nav/api/MainModule/MdWidgets.CodeSnippetView) .\n\nThe definition of a custom view is provided using a function that:\n*  Takes as single argument the HTML element as declared in the markdown file.\nThe raw text content within the DOM element can be accessed using  `elem.textContent`  and attributes using\n `elem.getAttribute` .\n*  Returns a virtual dom defining the corresponding implementation of the HTML element.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "GlobalMarkdownViews",
            "attributes": [
                {
                    "name": "factory",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "Static factory for markdown inlined views.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "GlobalMarkdownViews.factory",
                    "code": {
                        "filePath": "src/lib/markdown.ts",
                        "declaration": "static factory: { [k: string]: viewGenerator } = {\n        'code-snippet': (elem: HTMLElement) => {\n            return new CodeSnippetView({\n                language: elem.getAttribute('language') as CodeLanguage,\n                highlightedLines: elem.getAttribute('highlightedLines'),\n                content: elem.textContent,\n            })\n        },\n    }",
                        "implementation": "",
                        "startLine": 58,
                        "endLine": 59,
                        "references": {
                            "factory": "@nav/api/MainModule.GlobalMarkdownViews.factory",
                            "viewGenerator": "@nav/api/MainModule.viewGenerator"
                        }
                    }
                }
            ],
            "callables": [],
            "code": {
                "filePath": "src/lib/markdown.ts",
                "declaration": "export class GlobalMarkdownViews",
                "implementation": "export class GlobalMarkdownViews {\n    /**\n     * Static factory for markdown inlined views.\n     */\n    static factory: { [k: string]: viewGenerator } = {\n        'code-snippet': (elem: HTMLElement) => {\n            return new CodeSnippetView({\n                language: elem.getAttribute('language') as CodeLanguage,\n                highlightedLines: elem.getAttribute('highlightedLines'),\n                content: elem.textContent,\n            })\n        },\n    }\n}",
                "startLine": 54,
                "endLine": 68,
                "references": {
                    "GlobalMarkdownViews": "@nav/api/MainModule.GlobalMarkdownViews",
                    "viewGenerator": "@nav/api/MainModule.viewGenerator"
                }
            },
            "semantic": {
                "role": "class",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "Router",
            "documentation": {
                "sections": [
                    {
                        "content": "Represents the router of the application.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "Router",
            "attributes": [
                {
                    "name": "basePath",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "The base path on which the router is defined.\n\nIf the application is served from  `https://my-domain/my-app/version`  it is  `/my-app/version` .",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "Router.basePath",
                    "code": {
                        "filePath": "src/lib/router.ts",
                        "declaration": "public readonly basePath: string",
                        "implementation": "",
                        "startLine": 50,
                        "endLine": 51,
                        "references": {
                            "basePath": "@nav/api/MainModule.Router.basePath"
                        }
                    }
                },
                {
                    "name": "currentHtml$",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "Observable that emit the current main HTML page.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "Router.currentHtml$",
                    "code": {
                        "filePath": "src/lib/router.ts",
                        "declaration": "public readonly currentHtml$: Subject<HTMLElement> =\n        new ReplaySubject<HTMLElement>(1)",
                        "implementation": "",
                        "startLine": 67,
                        "endLine": 68,
                        "references": {
                            "currentHtml$": "@nav/api/MainModule.Router.currentHtml$"
                        }
                    }
                },
                {
                    "name": "currentNode$",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "Observable that emit the current navigation node.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "Router.currentNode$",
                    "code": {
                        "filePath": "src/lib/router.ts",
                        "declaration": "public readonly currentNode$: Subject<NavigationCommon> =\n        new ReplaySubject<NavigationCommon>(1)",
                        "implementation": "",
                        "startLine": 77,
                        "endLine": 78,
                        "references": {
                            "currentNode$": "@nav/api/MainModule.Router.currentNode$",
                            "NavigationCommon": "@nav/api/MainModule.NavigationCommon"
                        }
                    }
                },
                {
                    "name": "currentPage$",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "Observable that emit the current page.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "Router.currentPage$",
                    "code": {
                        "filePath": "src/lib/router.ts",
                        "declaration": "public readonly currentPage$: Subject<Destination> =\n        new ReplaySubject<Destination>(1)",
                        "implementation": "",
                        "startLine": 72,
                        "endLine": 73,
                        "references": {
                            "currentPage$": "@nav/api/MainModule.Router.currentPage$",
                            "Destination": "@nav/api/MainModule.Destination"
                        }
                    }
                },
                {
                    "name": "explorerState",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "Encapsulates the state of the navigation view (node selected, expanded, *etc.*)",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "Router.explorerState",
                    "code": {
                        "filePath": "src/lib/router.ts",
                        "declaration": "public readonly explorerState: ImmutableTree.State<NavNodeBase>",
                        "implementation": "",
                        "startLine": 83,
                        "endLine": 84,
                        "references": {
                            "explorerState": "@nav/api/MainModule.Router.explorerState",
                            "NavNodeBase": "@nav/api/MainModule.NavNodeBase"
                        }
                    }
                },
                {
                    "name": "navigation",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "Definition of the navigation.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "Router.navigation",
                    "code": {
                        "filePath": "src/lib/router.ts",
                        "declaration": "public readonly navigation: Navigation",
                        "implementation": "",
                        "startLine": 62,
                        "endLine": 63,
                        "references": {
                            "navigation": "@nav/api/MainModule.Router.navigation",
                            "Navigation": "@nav/api/MainModule.Navigation"
                        }
                    }
                },
                {
                    "name": "retryNavPeriod",
                    "semantic": {
                        "role": "attribute",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    },
                    "documentation": {
                        "sections": [
                            {
                                "content": "When using a dynamic definition of the routes (see  [Navigation](@nav/api/MainModule.Navigation) ),\nit may be the case that the routes are not yet available when navigating to a page.\nAttempt to re-navigate to the page is executed every  `retryNavPeriod`  second.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "Router.retryNavPeriod",
                    "code": {
                        "filePath": "src/lib/router.ts",
                        "declaration": "public readonly retryNavPeriod: number = 1000",
                        "implementation": "",
                        "startLine": 57,
                        "endLine": 58,
                        "references": {
                            "retryNavPeriod": "@nav/api/MainModule.Router.retryNavPeriod"
                        }
                    }
                }
            ],
            "callables": [
                {
                    "name": "new Router",
                    "documentation": {
                        "sections": [
                            {
                                "content": "Initialize a router instance.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            },
                            {
                                "title": "Arguments",
                                "content": "\n*  **params**: see corresponding documentation in the class's attributes\n*  **basePath**: the base path\n*  **navigation**: navigation object\n*  **retryNavPeriod**: wehn to retry",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "arguments",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "Router.new Router",
                    "code": {
                        "filePath": "src/lib/router.ts",
                        "declaration": "constructor(params: {\n        navigation: Navigation\n        basePath?: string\n        retryNavPeriod?: number\n    })",
                        "implementation": "constructor(params: {\n        navigation: Navigation\n        basePath?: string\n        retryNavPeriod?: number\n    }) {\n        Object.assign(this, params)\n        this.basePath = this.basePath || document.location.pathname\n        const { rootNode, reactiveNavs } = createRootNode({\n            navigation: this.navigation,\n            router: this,\n        })\n        this.explorerState = new ImmutableTree.State({\n            rootNode,\n            expandedNodes: ['/'],\n        })\n        Object.entries(reactiveNavs).forEach(([href, v]) => {\n            v.subscribe((resolver) => {\n                this.navUpdates[href] = resolver\n                const oldNode = this.explorerState.getNode(href)\n                const children = createImplicitChildren$({\n                    resolver: resolver,\n                    hrefBase: href,\n                    path: '',\n                    withExplicit: [],\n                    router: this,\n                })\n                const newNode = new oldNode.factory({\n                    ...oldNode,\n                    children,\n                })\n                this.explorerState.replaceNode(oldNode, newNode)\n            })\n        })\n\n        this.navigateTo({ path: this.getCurrentPath() })\n\n        window.onpopstate = (event: PopStateEvent) => {\n            const state = event.state\n            if (state) {\n                this.navigateTo(state)\n            } else {\n                this.navigateTo({ path: '/' })\n            }\n        }\n        this.currentHtml$.subscribe(() => {\n            console.log('Status', this.status)\n        })\n    }",
                        "startLine": 104,
                        "endLine": 152,
                        "references": {
                            "new Router": "@nav/api/MainModule.Router.constructor",
                            "Navigation": "@nav/api/MainModule.Navigation",
                            "Router": "@nav/api/MainModule.Router"
                        }
                    },
                    "semantic": {
                        "role": "constructor",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    }
                },
                {
                    "name": "emitHtmlUpdated",
                    "documentation": {
                        "sections": [
                            {
                                "content": "Clients need to invoke this function when dynamic change on the current main HTML page have occurred after the\ninitial rendering. Other views dependening on it (*e.g.* the table of content) will refresh as well.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "Router.emitHtmlUpdated",
                    "code": {
                        "filePath": "src/lib/router.ts",
                        "declaration": "emitHtmlUpdated()",
                        "implementation": "emitHtmlUpdated() {\n        this.htmlUpdated$.next(true)\n    }",
                        "startLine": 403,
                        "endLine": 406,
                        "references": {
                            "emitHtmlUpdated": "@nav/api/MainModule.Router.emitHtmlUpdated"
                        }
                    },
                    "semantic": {
                        "role": "method",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    }
                },
                {
                    "name": "getCurrentPath",
                    "documentation": {
                        "sections": [
                            {
                                "content": "Returns the current navigation path.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "Router.getCurrentPath",
                    "code": {
                        "filePath": "src/lib/router.ts",
                        "declaration": "getCurrentPath(): string",
                        "implementation": "getCurrentPath(): string {\n        const urlParams = new URLSearchParams(window.location.search)\n        return urlParams.get('nav') || '/'\n    }",
                        "startLine": 156,
                        "endLine": 160,
                        "references": {
                            "getCurrentPath": "@nav/api/MainModule.Router.getCurrentPath"
                        }
                    },
                    "semantic": {
                        "role": "method",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    }
                },
                {
                    "name": "getParentPath",
                    "documentation": {
                        "sections": [
                            {
                                "content": "Returns the parent path of the current navigation path.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "Router.getParentPath",
                    "code": {
                        "filePath": "src/lib/router.ts",
                        "declaration": "getParentPath(): string",
                        "implementation": "getParentPath(): string {\n        const currentPath = this.getCurrentPath()\n        return currentPath.split('/').slice(0, -1).join('/')\n    }",
                        "startLine": 164,
                        "endLine": 168,
                        "references": {
                            "getParentPath": "@nav/api/MainModule.Router.getParentPath"
                        }
                    },
                    "semantic": {
                        "role": "method",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    }
                },
                {
                    "name": "navigateTo",
                    "documentation": {
                        "sections": [
                            {
                                "content": "Navigate to a specific path.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            },
                            {
                                "title": "Arguments",
                                "content": "\n*  **path**: The path to navigate to.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "arguments",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "Router.navigateTo",
                    "code": {
                        "filePath": "src/lib/router.ts",
                        "declaration": "navigateTo({ path }: { path: string })",
                        "implementation": "navigateTo({ path }: { path: string }) {\n        const pagePath = path.split('.')[0]\n        const sectionId = path.split('.').slice(1).join('.')\n\n        const nav = this.getNav({ path: pagePath })\n        if (!nav) {\n            console.log('Try to wait...')\n            setTimeout(() => this.navigateTo({ path }), this.retryNavPeriod)\n            return\n        }\n        // This part is to resolve the html content of the selected page.\n        nav.pipe(\n            switchMap((resolved: NavigationCommon) => {\n                this.currentNode$.next(resolved)\n                const html = resolved.html({ router: this })\n                if (html instanceof Promise) {\n                    return from(html)\n                }\n                if (html instanceof Observable) {\n                    return html.pipe(take(1))\n                }\n                return of(html)\n            }),\n            map((html) => ({\n                html,\n                sectionId: sectionId == '' ? undefined : sectionId,\n            })),\n        ).subscribe((d) => {\n            this.currentPage$.next(d)\n        })\n        // This part is to select the appropriate node in the navigation.\n        this.expand(pagePath)\n        history.pushState({ path }, undefined, `${this.basePath}?nav=${path}`)\n    }",
                        "startLine": 174,
                        "endLine": 208,
                        "references": {
                            "navigateTo": "@nav/api/MainModule.Router.navigateTo"
                        }
                    },
                    "semantic": {
                        "role": "method",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    }
                },
                {
                    "name": "navigateToParent",
                    "documentation": {
                        "sections": [
                            {
                                "content": "Navigate to the parent node.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "Router.navigateToParent",
                    "code": {
                        "filePath": "src/lib/router.ts",
                        "declaration": "navigateToParent()",
                        "implementation": "navigateToParent() {\n        const path = this.getCurrentPath()\n        const parentPath = path.split('/').slice(0, -1).join('/')\n        this.navigateTo({ path: parentPath })\n    }",
                        "startLine": 212,
                        "endLine": 217,
                        "references": {
                            "navigateToParent": "@nav/api/MainModule.Router.navigateToParent"
                        }
                    },
                    "semantic": {
                        "role": "method",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    }
                },
                {
                    "name": "scrollTo",
                    "documentation": {
                        "sections": [
                            {
                                "content": "Scroll the main HTML content to focus on an HTML element.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            },
                            {
                                "title": "Arguments",
                                "content": "\n*  **target**: The target HTML element, or its id.",
                                "contentType": "markdown",
                                "semantic": {
                                    "role": "arguments",
                                    "labels": [],
                                    "attributes": {},
                                    "relations": {}
                                }
                            }
                        ]
                    },
                    "path": "Router.scrollTo",
                    "code": {
                        "filePath": "src/lib/router.ts",
                        "declaration": "scrollTo(target: string | HTMLElement)",
                        "implementation": "scrollTo(target: string | HTMLElement) {\n        if (!this.scrollableElement) {\n            return\n        }\n        const br = this.scrollableElement.getBoundingClientRect()\n        if (!target) {\n            this.scrollableElement.scrollTo({\n                top: br.top,\n                left: 0,\n            })\n            return\n        }\n        const div: HTMLElement =\n            target instanceof HTMLElement\n                ? target\n                : findElementById(this.scrollableElement, target)\n\n        if (!div) {\n            console.warn(`Can not scroll to element #${target}`)\n            return\n        }\n        const tinyMarginPx = 5\n        this.scrollableElement.scrollTo({\n            top: div.offsetTop + br.top - tinyMarginPx,\n            left: 0,\n            behavior: 'smooth',\n        })\n        const currentPath = this.getCurrentPath().split('.')[0]\n        const path = `${currentPath}.${div.id}`\n        history.pushState({ path }, undefined, `${this.basePath}?nav=${path}`)\n    }",
                        "startLine": 223,
                        "endLine": 254,
                        "references": {
                            "scrollTo": "@nav/api/MainModule.Router.scrollTo"
                        }
                    },
                    "semantic": {
                        "role": "method",
                        "labels": [],
                        "attributes": {},
                        "relations": {}
                    }
                }
            ],
            "code": {
                "filePath": "src/lib/router.ts",
                "declaration": "export class Router",
                "implementation": "export class Router {\n    /**\n     * The base path on which the router is defined.\n     *\n     * If the application is served from `https://my-domain/my-app/version` it is `/my-app/version`.\n     */\n    public readonly basePath: string\n\n    /**\n     * When using a dynamic definition of the routes (see {@link Navigation}),\n     * it may be the case that the routes are not yet available when navigating to a page.\n     * Attempt to re-navigate to the page is executed every `retryNavPeriod` second.\n     */\n    public readonly retryNavPeriod: number = 1000\n\n    /**\n     * Definition of the navigation.\n     */\n    public readonly navigation: Navigation\n\n    /**\n     * Observable that emit the current main HTML page.\n     */\n    public readonly currentHtml$: Subject<HTMLElement> =\n        new ReplaySubject<HTMLElement>(1)\n    /**\n     * Observable that emit the current page.\n     */\n    public readonly currentPage$: Subject<Destination> =\n        new ReplaySubject<Destination>(1)\n    /**\n     * Observable that emit the current navigation node.\n     */\n    public readonly currentNode$: Subject<NavigationCommon> =\n        new ReplaySubject<NavigationCommon>(1)\n\n    /**\n     * Encapsulates the state of the navigation view (node selected, expanded, *etc.*)\n     */\n    public readonly explorerState: ImmutableTree.State<NavNodeBase>\n\n    public scrollableElement: HTMLElement\n\n    public readonly htmlUpdated$ = new Subject<unknown>()\n\n    public readonly status: Record<\n        'Warning' | 'Error',\n        { [k: string]: unknown[] }\n    > = { Warning: {}, Error: {} }\n\n    private navUpdates: { [href: string]: LazyNavResolver } = {}\n\n    /**\n     * Initialize a router instance.\n     *\n     * @param params see corresponding documentation in the class's attributes\n     * @param params.navigation navigation object\n     * @param params.basePath the base path\n     * @param params.retryNavPeriod wehn to retry\n     */\n    constructor(params: {\n        navigation: Navigation\n        basePath?: string\n        retryNavPeriod?: number\n    }) {\n        Object.assign(this, params)\n        this.basePath = this.basePath || document.location.pathname\n        const { rootNode, reactiveNavs } = createRootNode({\n            navigation: this.navigation,\n            router: this,\n        })\n        this.explorerState = new ImmutableTree.State({\n            rootNode,\n            expandedNodes: ['/'],\n        })\n        Object.entries(reactiveNavs).forEach(([href, v]) => {\n            v.subscribe((resolver) => {\n                this.navUpdates[href] = resolver\n                const oldNode = this.explorerState.getNode(href)\n                const children = createImplicitChildren$({\n                    resolver: resolver,\n                    hrefBase: href,\n                    path: '',\n                    withExplicit: [],\n                    router: this,\n                })\n                const newNode = new oldNode.factory({\n                    ...oldNode,\n                    children,\n                })\n                this.explorerState.replaceNode(oldNode, newNode)\n            })\n        })\n\n        this.navigateTo({ path: this.getCurrentPath() })\n\n        window.onpopstate = (event: PopStateEvent) => {\n            const state = event.state\n            if (state) {\n                this.navigateTo(state)\n            } else {\n                this.navigateTo({ path: '/' })\n            }\n        }\n        this.currentHtml$.subscribe(() => {\n            console.log('Status', this.status)\n        })\n    }\n\n    /**\n     * Returns the current navigation path.\n     */\n    getCurrentPath(): string {\n        const urlParams = new URLSearchParams(window.location.search)\n        return urlParams.get('nav') || '/'\n    }\n\n    /**\n     * Returns the parent path of the current navigation path.\n     */\n    getParentPath(): string {\n        const currentPath = this.getCurrentPath()\n        return currentPath.split('/').slice(0, -1).join('/')\n    }\n\n    /**\n     * Navigate to a specific path.\n     *\n     * @param path The path to navigate to.\n     */\n    navigateTo({ path }: { path: string }) {\n        const pagePath = path.split('.')[0]\n        const sectionId = path.split('.').slice(1).join('.')\n\n        const nav = this.getNav({ path: pagePath })\n        if (!nav) {\n            console.log('Try to wait...')\n            setTimeout(() => this.navigateTo({ path }), this.retryNavPeriod)\n            return\n        }\n        // This part is to resolve the html content of the selected page.\n        nav.pipe(\n            switchMap((resolved: NavigationCommon) => {\n                this.currentNode$.next(resolved)\n                const html = resolved.html({ router: this })\n                if (html instanceof Promise) {\n                    return from(html)\n                }\n                if (html instanceof Observable) {\n                    return html.pipe(take(1))\n                }\n                return of(html)\n            }),\n            map((html) => ({\n                html,\n                sectionId: sectionId == '' ? undefined : sectionId,\n            })),\n        ).subscribe((d) => {\n            this.currentPage$.next(d)\n        })\n        // This part is to select the appropriate node in the navigation.\n        this.expand(pagePath)\n        history.pushState({ path }, undefined, `${this.basePath}?nav=${path}`)\n    }\n\n    /**\n     * Navigate to the parent node.\n     */\n    navigateToParent() {\n        const path = this.getCurrentPath()\n        const parentPath = path.split('/').slice(0, -1).join('/')\n        this.navigateTo({ path: parentPath })\n    }\n\n    /**\n     * Scroll the main HTML content to focus on an HTML element.\n     *\n     * @param target The target HTML element, or its id.\n     */\n    scrollTo(target: string | HTMLElement) {\n        if (!this.scrollableElement) {\n            return\n        }\n        const br = this.scrollableElement.getBoundingClientRect()\n        if (!target) {\n            this.scrollableElement.scrollTo({\n                top: br.top,\n                left: 0,\n            })\n            return\n        }\n        const div: HTMLElement =\n            target instanceof HTMLElement\n                ? target\n                : findElementById(this.scrollableElement, target)\n\n        if (!div) {\n            console.warn(`Can not scroll to element #${target}`)\n            return\n        }\n        const tinyMarginPx = 5\n        this.scrollableElement.scrollTo({\n            top: div.offsetTop + br.top - tinyMarginPx,\n            left: 0,\n            behavior: 'smooth',\n        })\n        const currentPath = this.getCurrentPath().split('.')[0]\n        const path = `${currentPath}.${div.id}`\n        history.pushState({ path }, undefined, `${this.basePath}?nav=${path}`)\n    }\n\n    refresh({\n        resolverPath,\n        path,\n        redirectTo,\n    }: {\n        resolverPath: string\n        path?: string\n        redirectTo?: string\n    }) {\n        const currentPath = this.getCurrentPath()\n        path = path || this.getCurrentPath()\n        const resolver =\n            this.navUpdates[resolverPath] ||\n            this.navigation[resolverPath][CatchAllKey]\n        const oldNode = this.explorerState.getNode(path)\n        const children = createImplicitChildren$({\n            resolver: resolver,\n            hrefBase: resolverPath,\n            path: path.split(resolverPath)[1],\n            withExplicit: [],\n            router: this,\n        })\n        const newNode = new oldNode.factory({\n            ...oldNode,\n            children,\n        }) as NavNodeBase\n        this.explorerState.replaceNode(oldNode, newNode)\n        //this.explorerState.selectNodeAndExpand(newNode)\n        if (redirectTo) {\n            this.navigateTo({ path })\n            return\n        }\n        this.navigateTo({ path: currentPath })\n    }\n\n    private getNav({\n        path,\n    }: {\n        path: string\n    }): Observable<NavigationCommon> | undefined {\n        const parts = path\n            .split('/')\n            .slice(1)\n            .filter((d) => d !== '')\n\n        if (parts.length === 0) {\n            return of(this.navigation)\n        }\n\n        const node = parts.reduce(\n            ({ tree, path, keepGoing }, part) => {\n                if (!keepGoing) {\n                    return { tree, path, keepGoing }\n                }\n                const treePart = tree[`/${part}`]\n                if (!treePart && !tree[CatchAllKey]) {\n                    console.error({ path, tree })\n                    throw Error(`Can not find target navigation ${path}`)\n                }\n                if (!treePart) {\n                    return {\n                        tree: this.navUpdates[path] || tree[CatchAllKey],\n                        path: `${path}`,\n                        keepGoing: false,\n                    }\n                }\n                return {\n                    tree: treePart,\n                    path: `${path}/${part}`,\n                    keepGoing: true,\n                }\n            },\n            { tree: this.navigation, path: ``, keepGoing: true },\n        )\n        // node.tree: Navigation | LazyNavResolver | ReactiveLazyNavResolver\n        if (node.tree instanceof Observable) {\n            // case: ReactiveLazyNavResolver -> a retry in some period of time will be executed\n            return undefined\n        }\n        // node.tree: Navigation | LazyNavResolver\n        if (typeof node.tree === 'function') {\n            // case: LazyNavResolver\n            const relative = path.split(node.path)[1]\n            const nav = node.tree({ path: relative, router: this })\n            return nav instanceof Observable\n                ? nav\n                : nav instanceof Promise\n                  ? from(nav)\n                  : of(nav)\n        }\n        // node.tree: Navigation\n        return of(node.tree)\n    }\n\n    private expand(path: string) {\n        const parts = path.split('/')\n        const ids = parts\n            .map((p, i) => parts.slice(0, i + 1).join('/'))\n            .slice(1)\n        const getLastResolved = (ids: string[]) => {\n            if (ids.length == 0) {\n                return this.explorerState.getNode('/')\n            }\n            const id = ids.slice(-1)[0]\n            const childNode = this.explorerState.getNode(id)\n            return childNode || getLastResolved(ids.slice(0, -1))\n        }\n        const node = getLastResolved(ids)\n        if (node.id == ids.slice(-1)[0]) {\n            this.explorerState.selectNodeAndExpand(node)\n            return\n        }\n\n        const idsRemaining = ids.slice(ids.indexOf(node.id) + 1)\n        if (idsRemaining.length == 0) {\n            this.explorerState.selectNodeAndExpand(node)\n            return\n        }\n        const expandRec = (ids: string[], node: NavNodeBase) => {\n            if (ids.length == 0) {\n                return this.explorerState.selectNodeAndExpand(node)\n            }\n            const maybeChildResolved = this.explorerState.getNode(ids[0])\n            return maybeChildResolved\n                ? expandRec(ids.slice(1), maybeChildResolved)\n                : this.explorerState.getChildren(node, (_, children) => {\n                      const nodeNew = children.find(\n                          (child) => child.id === ids[0],\n                      )\n                      if (!nodeNew) {\n                          console.warn(`Can not find node ${ids[0]} (yet?)`)\n                      }\n                      if (nodeNew) {\n                          expandRec(ids.slice(1), nodeNew)\n                      }\n                  })\n        }\n        expandRec(idsRemaining, node)\n    }\n\n    setDisplayedPage({ page }: { page: HTMLElement }) {\n        this.currentHtml$.next(page)\n    }\n\n    /**\n     * Clients need to invoke this function when dynamic change on the current main HTML page have occurred after the\n     * initial rendering. Other views dependening on it (*e.g.* the table of content) will refresh as well.\n     */\n    emitHtmlUpdated() {\n        this.htmlUpdated$.next(true)\n    }\n}",
                "startLine": 44,
                "endLine": 407,
                "references": {
                    "Router": "@nav/api/MainModule.Router",
                    "Navigation": "@nav/api/MainModule.Navigation",
                    "NavigationCommon": "@nav/api/MainModule.NavigationCommon",
                    "Destination": "@nav/api/MainModule.Destination",
                    "NavNodeBase": "@nav/api/MainModule.NavNodeBase",
                    "LazyNavResolver": "@nav/api/MainModule.LazyNavResolver"
                }
            },
            "semantic": {
                "role": "class",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "CatchAllNav",
            "documentation": {
                "sections": [
                    {
                        "content": "Node definition when using implicit 'catch-all' sub-navigation resolver,\nsee  [Navigation](@nav/api/MainModule.Navigation) .",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "CatchAllNav",
            "attributes": [],
            "callables": [],
            "code": {
                "filePath": "src/lib/navigation.node.ts",
                "declaration": "export type CatchAllNav = Resolvable<\n    NavigationCommon & { children: NavNodeInput[] }\n>",
                "implementation": "",
                "startLine": 284,
                "endLine": 285,
                "references": {
                    "CatchAllNav": "@nav/api/MainModule.CatchAllNav",
                    "Resolvable": "@nav/api/MainModule.Resolvable",
                    "NavigationCommon": "@nav/api/MainModule.NavigationCommon",
                    "NavNodeInput": "@nav/api/MainModule.NavNodeInput"
                }
            },
            "semantic": {
                "role": "type-alias",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "Decoration",
            "documentation": {
                "sections": [
                    {
                        "content": "Defines attributes regarding the visual rendering of the node if the navigation view.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "Decoration",
            "attributes": [],
            "callables": [],
            "code": {
                "filePath": "src/lib/navigation.node.ts",
                "declaration": "export type Decoration = {\n    /**\n     * Optional class added as wrapper to the HTML element representing the node.\n     */\n    wrapperClass?: AttributeLike<string>\n    /**\n     * Optional icon, inserted before the node's name.\n     */\n    icon?: ChildLike\n    /**\n     * Optional actions, inserted after the node's name.\n     */\n    actions?: ChildrenLike\n}",
                "implementation": "",
                "startLine": 14,
                "endLine": 15,
                "references": {
                    "Decoration": "@nav/api/MainModule.Decoration"
                }
            },
            "semantic": {
                "role": "type-alias",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "Destination",
            "documentation": {
                "sections": [
                    {
                        "content": "Gathers the resolved elements when navigating to a specific path.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "Destination",
            "attributes": [],
            "callables": [],
            "code": {
                "filePath": "src/lib/router.ts",
                "declaration": "export type Destination = {\n    /**\n     * The table of content view.\n     */\n    tableOfContent?: HTMLElement | AnyVirtualDOM\n    /**\n     * The main page view.\n     */\n    html: HTMLElement | AnyVirtualDOM\n    /**\n     * The typedocNodes's ID if provided in the URL.\n     */\n    sectionId?: string\n}",
                "implementation": "",
                "startLine": 26,
                "endLine": 27,
                "references": {
                    "Destination": "@nav/api/MainModule.Destination"
                }
            },
            "semantic": {
                "role": "type-alias",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "LazyNavResolver",
            "documentation": {
                "sections": [
                    {
                        "content": "Represents a lazy navigation resolver, used when the navigation is only known at runtime.\n\nIt is a function that takes the target path and router's instance as parameters, and returns\nthe instance of  [CatchAllNav](@nav/api/MainModule.CatchAllNav)  that explicits node attributes ( `name` ,  `id` ,  `children` , *etc.*).",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "LazyNavResolver",
            "attributes": [],
            "callables": [],
            "code": {
                "filePath": "src/lib/navigation.node.ts",
                "declaration": "export type LazyNavResolver = (p: {\n    // The targeted path in the navigation\n    path: string\n    // Router instance\n    router: Router\n}) => CatchAllNav",
                "implementation": "",
                "startLine": 294,
                "endLine": 295,
                "references": {
                    "LazyNavResolver": "@nav/api/MainModule.LazyNavResolver",
                    "Router": "@nav/api/MainModule.Router",
                    "CatchAllNav": "@nav/api/MainModule.CatchAllNav"
                }
            },
            "semantic": {
                "role": "type-alias",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "NavNodeInput",
            "documentation": {
                "sections": [
                    {
                        "content": "Arguments defining the children part of a navigation node when using dynamic  [CatchAllNav](@nav/api/MainModule.CatchAllNav) .",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "NavNodeInput",
            "attributes": [],
            "callables": [],
            "code": {
                "filePath": "src/lib/navigation.node.ts",
                "declaration": "export type NavNodeInput = Omit<NavNodeParams, 'href' | 'children'> & {\n    /**\n     * Whether the node is a leaf (no children expected).\n     */\n    leaf?: boolean\n}",
                "implementation": "",
                "startLine": 84,
                "endLine": 85,
                "references": {
                    "NavNodeInput": "@nav/api/MainModule.NavNodeInput",
                    "NavNodeParams": "@nav/api/MainModule.NavNodeParams"
                }
            },
            "semantic": {
                "role": "type-alias",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "NavNodeParams",
            "documentation": {
                "sections": [
                    {
                        "content": "Fully resolved navigation node when using  [CatchAllNav](@nav/api/MainModule.CatchAllNav) .\nIn practical usage, consumers of the library only needs to provide  [NavNodeInput](@nav/api/MainModule.NavNodeInput) .",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "NavNodeParams",
            "attributes": [],
            "callables": [],
            "code": {
                "filePath": "src/lib/navigation.node.ts",
                "declaration": "export type NavNodeParams = {\n    /**\n     * Id of the node.\n     */\n    id: string\n    /**\n     * Name of the node.\n     */\n    name: string\n    /**\n     * Hyperlink reference.\n     */\n    href: string\n    /**\n     * Optional data associated to the node.\n     */\n    data?: unknown\n    /**\n     * Optional children.\n     */\n    children?: NavNodeBase[] | Observable<NavNodeBase[]>\n    /**\n     * Optional decoration.\n     */\n    decoration?: Decoration\n}",
                "implementation": "",
                "startLine": 33,
                "endLine": 34,
                "references": {
                    "NavNodeParams": "@nav/api/MainModule.NavNodeParams",
                    "NavNodeBase": "@nav/api/MainModule.NavNodeBase",
                    "Decoration": "@nav/api/MainModule.Decoration"
                }
            },
            "semantic": {
                "role": "type-alias",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "Navigation",
            "documentation": {
                "sections": [
                    {
                        "content": "Represents a node in the navigation.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "Navigation",
            "attributes": [],
            "callables": [],
            "code": {
                "filePath": "src/lib/navigation.node.ts",
                "declaration": "export type Navigation = NavigationCommon & {\n    /**\n     * Name of the node.\n     */\n    name: string\n\n    /**\n     * Decoration configuration for the node.\n     */\n    decoration?: Decoration\n\n    /**\n     * Dynamic 'catch-all' sub-navigation resolver, used when the navigation is only known at runtime.\n     *\n     * The sub-paths defined in it can also be made reaction (using {@link ReactiveLazyNavResolver})\n     * if changes in organisation over time are expected.\n     */\n    [CatchAllKey]?: LazyNavResolver | ReactiveLazyNavResolver\n\n    /**\n     * Static sub-navigation resolver.\n     */\n    [key: `/${string}`]: Navigation\n}",
                "implementation": "",
                "startLine": 316,
                "endLine": 317,
                "references": {
                    "Navigation": "@nav/api/MainModule.Navigation",
                    "NavigationCommon": "@nav/api/MainModule.NavigationCommon",
                    "LazyNavResolver": "@nav/api/MainModule.LazyNavResolver",
                    "ReactiveLazyNavResolver": "@nav/api/MainModule.ReactiveLazyNavResolver",
                    "Decoration": "@nav/api/MainModule.Decoration"
                }
            },
            "semantic": {
                "role": "type-alias",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "NavigationCommon",
            "documentation": {
                "sections": [
                    {
                        "content": "The common part of a navigation node, whether it is static or dynamic.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "NavigationCommon",
            "attributes": [],
            "callables": [],
            "code": {
                "filePath": "src/lib/navigation.node.ts",
                "declaration": "export type NavigationCommon = {\n    /**\n     * This function represents the view of the main content.\n     *\n     * @param router Router instance.\n     * @returns A resolvable view\n     */\n    html: ({ router }) => Resolvable<AnyVirtualDOM>\n    /**\n     * This function represents the view of the table of content in the page.\n     *\n     * @param p arguments of the view generator:\n     *   *  html : Content of the HTML page\n     *   *  router : Router instance.\n     * @returns A promise on the view\n     */\n    tableOfContent?: (p: {\n        html: HTMLElement\n        router: Router\n    }) => Promise<AnyVirtualDOM>\n}",
                "implementation": "",
                "startLine": 258,
                "endLine": 259,
                "references": {
                    "NavigationCommon": "@nav/api/MainModule.NavigationCommon",
                    "Resolvable": "@nav/api/MainModule.Resolvable",
                    "Router": "@nav/api/MainModule.Router"
                }
            },
            "semantic": {
                "role": "type-alias",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "ParsingArguments",
            "documentation": {
                "sections": [
                    {
                        "content": "Options for parsing Markdown content.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "ParsingArguments",
            "attributes": [],
            "callables": [],
            "code": {
                "filePath": "src/lib/markdown.ts",
                "declaration": "export type ParsingArguments = {\n    /**\n     * Placeholders to account for. A form of preprocessing that replace any occurrences of the keys\n     * in the source by their corresponding values.\n     */\n    placeholders?: { [k: string]: string }\n    /**\n     * Preprocessing step. This callback is called to transform the source before parsing is executed.\n     * @param text original text\n     * @return transformed text\n     */\n    preprocessing?: (text: string) => string\n    /**\n     *  Custom views referenced in the source. See details in the documentation of {@link parseMd} to register views.\n     */\n    views?: { [k: string]: viewGenerator }\n    /**\n     * If true, call {@link Router.emitHtmlUpdated} when the markdown is rendered.\n     */\n    emitHtmlUpdated?: boolean\n}",
                "implementation": "",
                "startLine": 21,
                "endLine": 22,
                "references": {
                    "ParsingArguments": "@nav/api/MainModule.ParsingArguments",
                    "viewGenerator": "@nav/api/MainModule.viewGenerator"
                }
            },
            "semantic": {
                "role": "type-alias",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "ReactiveLazyNavResolver",
            "documentation": {
                "sections": [
                    {
                        "content": "Represents a reactive lazy navigation resolver, used when changes in a navigation node children are expected\n(within  [Navigation](@nav/api/MainModule.Navigation) ).",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "ReactiveLazyNavResolver",
            "attributes": [],
            "callables": [],
            "code": {
                "filePath": "src/lib/navigation.node.ts",
                "declaration": "export type ReactiveLazyNavResolver = Observable<LazyNavResolver>",
                "implementation": "",
                "startLine": 305,
                "endLine": 306,
                "references": {
                    "ReactiveLazyNavResolver": "@nav/api/MainModule.ReactiveLazyNavResolver",
                    "LazyNavResolver": "@nav/api/MainModule.LazyNavResolver"
                }
            },
            "semantic": {
                "role": "type-alias",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "Resolvable",
            "documentation": {
                "sections": [
                    {
                        "content": "Represents something resolvable.\n\nImportant:\n    When an observable is provided, only its **first emission** is accounted.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "Resolvable",
            "attributes": [],
            "callables": [],
            "code": {
                "filePath": "src/lib/navigation.node.ts",
                "declaration": "export type Resolvable<T> = T | Promise<T> | Observable<T>",
                "implementation": "",
                "startLine": 253,
                "endLine": 254,
                "references": {
                    "Resolvable": "@nav/api/MainModule.Resolvable",
                    "T": "650"
                }
            },
            "semantic": {
                "role": "type-alias",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "viewGenerator",
            "documentation": {
                "sections": [
                    {
                        "content": "Type definition for custom view generators.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "viewGenerator",
            "attributes": [],
            "callables": [],
            "code": {
                "filePath": "src/lib/markdown.ts",
                "declaration": "export type viewGenerator = (e: HTMLElement) => AnyVirtualDOM",
                "implementation": "",
                "startLine": 16,
                "endLine": 17,
                "references": {
                    "viewGenerator": "@nav/api/MainModule.viewGenerator"
                }
            },
            "semantic": {
                "role": "type-alias",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        }
    ],
    "callables": [
        {
            "name": "fetchMarkdown",
            "documentation": {
                "sections": [
                    {
                        "content": "Fetch & parse a Markdown file from specified with a URL.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    },
                    {
                        "title": "Arguments",
                        "content": "\n*  **params**: see  [ParsingArguments](@nav/api/MainModule.ParsingArguments)  for additional options.\n*  **url**: The URL of the file.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "arguments",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "fetchMarkdown",
            "code": {
                "filePath": "src/lib/markdown.ts",
                "declaration": "export function fetchMarkdown(\n    params: {\n        url: string\n    } & ParsingArguments,\n): ({ router }: { router: Router }) => Promise<VirtualDOM<'div'>>",
                "implementation": "export function fetchMarkdown(\n    params: {\n        url: string\n    } & ParsingArguments,\n): ({ router }: { router: Router }) => Promise<VirtualDOM<'div'>> {\n    setOptions({\n        langPrefix: 'hljs language-',\n        highlight: function (code, lang) {\n            return highlight.highlightAuto(code, [lang]).value\n        },\n    })\n\n    return ({ router }: { router: Router }) => {\n        return fetch(params.url)\n            .then((resp) => resp.text())\n            .then((src) => {\n                return parseMd({\n                    src,\n                    router,\n                    ...params,\n                })\n            })\n    }\n}",
                "startLine": 75,
                "endLine": 99,
                "references": {
                    "fetchMarkdown": "@nav/api/MainModule.fetchMarkdown",
                    "ParsingArguments": "@nav/api/MainModule.ParsingArguments",
                    "Router": "@nav/api/MainModule.Router"
                }
            },
            "semantic": {
                "role": "function",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "installCodeApiModule",
            "documentation": {
                "sections": [
                    {
                        "content": "Install and returns the  [CodeApiModule](@nav/api/CodeApi)  module.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "installCodeApiModule",
            "code": {
                "filePath": "src/index.ts",
                "declaration": "export async function installCodeApiModule()",
                "implementation": "export async function installCodeApiModule() {\n    const module: typeof CodeApiModule = await setup.installAuxiliaryModule({\n        name: 'CodeApi',\n        cdnClient: webpmClient,\n    })\n    return module\n}",
                "startLine": 17,
                "endLine": 24,
                "references": {
                    "installCodeApiModule": "@nav/api/MainModule.installCodeApiModule",
                    "__module": "@nav/api/CodeApi"
                }
            },
            "semantic": {
                "role": "function",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        },
        {
            "name": "parseMd",
            "documentation": {
                "sections": [
                    {
                        "content": "Parse a Markdown file specified with a URL.\n\nNote that custom views provided using the attribute `views ̀ comes in addition to those registered globally in\n [GlobalMarkdownViews](@nav/api/MainModule.GlobalMarkdownViews) .",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    },
                    {
                        "title": "Arguments",
                        "content": "\n*  **args**: see  [ParsingArguments](@nav/api/MainModule.ParsingArguments)  for additional options.\n*  **navigations**: Specify custom redirections for HTMLAnchorElement.\n*  **router**: The router instance.\n*  **src**: Markdown source.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "arguments",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    },
                    {
                        "title": "Returns",
                        "content": "A virtual DOM encapsulating the parsed Markdown.",
                        "contentType": "markdown",
                        "semantic": {
                            "role": "returns",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        }
                    }
                ]
            },
            "path": "parseMd",
            "code": {
                "filePath": "src/lib/markdown.ts",
                "declaration": "export function parseMd({\n    src,\n    router,\n    navigations,\n    views,\n    placeholders,\n    preprocessing,\n    emitHtmlUpdated,\n}: {\n    src: string\n    router?: Router\n    navigations?: { [k: string]: (e: HTMLAnchorElement) => void }\n} & ParsingArguments): VirtualDOM<'div'>",
                "implementation": "export function parseMd({\n    src,\n    router,\n    navigations,\n    views,\n    placeholders,\n    preprocessing,\n    emitHtmlUpdated,\n}: {\n    src: string\n    router?: Router\n    navigations?: { [k: string]: (e: HTMLAnchorElement) => void }\n} & ParsingArguments): VirtualDOM<'div'> {\n    if (typeof src !== 'string') {\n        console.error('Given MD source is not a string', src)\n        return {\n            tag: 'div',\n            innerText: 'Error: given MD source is not a string\"',\n        }\n    }\n    src = preprocessing?.(src) || src\n    if (placeholders) {\n        const regex = new RegExp(Object.keys(placeholders || {}).join('|'), 'g')\n        src = src.replace(regex, (match) => placeholders[match])\n    }\n    views = { ...views, ...GlobalMarkdownViews.factory }\n    const div = fixedMarkedParseCustomViews({ input: src, views: views })\n\n    const customs = div.querySelectorAll('.language-custom-view')\n    customs.forEach((custom) => {\n        const fct = new Function(custom['innerText'])()({ webpm })\n        const view = render({\n            tag: 'div',\n            children: [\n                {\n                    source$: from(fct),\n                    vdomMap: (vDom) => vDom as AnyVirtualDOM,\n                },\n            ],\n        })\n        custom.parentNode.parentNode.replaceChild(view, custom.parentNode)\n    })\n\n    // Navigation links\n    const links = div.querySelectorAll('a')\n    links.forEach((link) => {\n        if (link.href.includes('@nav') && router) {\n            const path = link.href.split('@nav')[1]\n            link.href = `${router.basePath}?nav=${path}`\n            link.onclick = (e: MouseEvent) => {\n                e.preventDefault()\n                router.navigateTo({ path })\n            }\n        }\n        if (navigations) {\n            Object.entries(navigations).forEach(([k, v]) => {\n                if (link.href.includes(`@${k}`)) {\n                    link.onclick = (e: MouseEvent) => {\n                        e.preventDefault()\n                        v(link)\n                    }\n                }\n            })\n        }\n    })\n    Object.entries(views || {}).forEach(([k, v]) => {\n        const elems = div.querySelectorAll(k)\n        elems.forEach((elem) => {\n            elem.parentNode.replaceChild(render(v(elem as HTMLElement)), elem)\n        })\n    })\n    return {\n        tag: 'div',\n        children: [div],\n        connectedCallback: () => emitHtmlUpdated && router.emitHtmlUpdated(),\n    }\n}",
                "startLine": 134,
                "endLine": 211,
                "references": {
                    "parseMd": "@nav/api/MainModule.parseMd",
                    "Router": "@nav/api/MainModule.Router",
                    "ParsingArguments": "@nav/api/MainModule.ParsingArguments"
                }
            },
            "semantic": {
                "role": "function",
                "labels": [],
                "attributes": {},
                "relations": {}
            }
        }
    ],
    "files": [
        {
            "name": "index.ts",
            "path": "src/index.ts",
            "documentation": {
                "sections": [
                    {
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        },
                        "content": "Main module of the library.",
                        "contentType": "markdown"
                    }
                ]
            }
        },
        {
            "name": "index.ts",
            "path": "src/lib/md-widgets/index.ts",
            "documentation": {
                "sections": [
                    {
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        },
                        "content": "Gathers markdown widgets definition.",
                        "contentType": "markdown"
                    }
                ]
            }
        },
        {
            "name": "index.ts",
            "path": "src/lib/views/index.ts",
            "documentation": {
                "sections": [
                    {
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        },
                        "content": "This module gathers views definition.",
                        "contentType": "markdown"
                    }
                ]
            }
        },
        {
            "name": "markdown.ts",
            "path": "src/lib/markdown.ts",
            "documentation": {
                "sections": [
                    {
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        },
                        "content": "This file gathers entry points related to Mardown parsing.",
                        "contentType": "markdown"
                    }
                ]
            }
        },
        {
            "name": "navigation.node.ts",
            "path": "src/lib/navigation.node.ts",
            "documentation": {
                "sections": [
                    {
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        },
                        "content": "",
                        "contentType": "markdown"
                    }
                ]
            }
        },
        {
            "name": "router.ts",
            "path": "src/lib/router.ts",
            "documentation": {
                "sections": [
                    {
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        },
                        "content": "",
                        "contentType": "markdown"
                    }
                ]
            }
        },
        {
            "name": "auto-generated.ts",
            "path": "src/auto-generated.ts",
            "documentation": {
                "sections": [
                    {
                        "semantic": {
                            "role": "",
                            "labels": [],
                            "attributes": {},
                            "relations": {}
                        },
                        "content": "",
                        "contentType": "markdown"
                    }
                ]
            }
        }
    ],
    "children": [
        {
            "name": "MdWidgets",
            "path": "mkdocs-ts/MainModule.MdWidgets",
            "isLeaf": true
        },
        {
            "name": "Views",
            "path": "mkdocs-ts/MainModule.Views",
            "isLeaf": true
        }
    ],
    "semantic": {
        "role": "",
        "labels": [],
        "attributes": {},
        "relations": {}
    }
}
